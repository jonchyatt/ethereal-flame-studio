---
phase: 10-guardrails-safety
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/jarvis/memory/toolExecutor.ts
  - src/lib/jarvis/notion/toolExecutor.ts
  - src/app/api/jarvis/chat/route.ts
autonomous: true

must_haves:
  truths:
    - "Every tool execution is logged to dailyLogs table"
    - "User can ask 'what did you do?' and get audit history"
    - "Logs include tool name, success/failure, and context"
  artifacts:
    - path: "src/lib/jarvis/memory/toolExecutor.ts"
      provides: "Audit logging for memory tool executions"
      contains: "logEvent"
    - path: "src/lib/jarvis/notion/toolExecutor.ts"
      provides: "Audit logging for Notion tool executions"
      contains: "logEvent"
  key_links:
    - from: "src/app/api/jarvis/chat/route.ts"
      to: "toolExecutors"
      via: "sessionId passed to tool executors"
      pattern: "sessionId"
    - from: "toolExecutors"
      to: "dailyLogs"
      via: "logEvent calls"
      pattern: "logEvent.*tool_invocation"
---

<objective>
Wire audit logging to tool executors so every tool call is recorded.

Purpose: Enable GUARD-02 (all tool invocations logged) and support "what did you do?" queries. The dailyLogs infrastructure exists but isn't being called from tool executors.

Output: Both memory and Notion tool executors log every invocation with tool name, success/failure, and context.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@jarvis/.planning/PROJECT.md
@jarvis/.planning/ROADMAP.md
@jarvis/.planning/STATE.md
@jarvis/.planning/phases/10-guardrails-safety/10-CONTEXT.md
@jarvis/.planning/phases/10-guardrails-safety/10-RESEARCH.md

# Current implementation
@src/lib/jarvis/memory/toolExecutor.ts
@src/lib/jarvis/notion/toolExecutor.ts
@src/lib/jarvis/memory/queries/dailyLogs.ts
@src/app/api/jarvis/chat/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Propagate sessionId to tool executors</name>
  <files>src/app/api/jarvis/chat/route.ts</files>
  <action>
Modify the Chat API route to pass sessionId to tool executors.

1. Import getOrCreateSession from memory:
```typescript
import { getOrCreateSession } from '@/lib/jarvis/memory/queries/sessions';
```

2. At the start of POST handler, get/create session:
```typescript
// Get or create session for audit logging
const session = await getOrCreateSession();
const sessionId = session.id;
```

3. Update the tool execution calls to include sessionId:
```typescript
// In the tool execution loop, pass sessionId:
if (memoryToolNames.includes(toolUse.name)) {
  result = await executeMemoryTool(
    toolUse.name,
    toolUse.input as Record<string, unknown>,
    sessionId  // Add this parameter
  );
} else {
  result = await executeNotionTool(
    toolUse.name,
    toolUse.input as Record<string, unknown>,
    sessionId  // Add this parameter
  );
}
```

Note: getOrCreateSession may not exist yet. Check sessions.ts - if not, create a simple function that finds active session or creates one.
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit -p . 2>&1 | head -20
```
  </verify>
  <done>Chat API route passes sessionId to both tool executors</done>
</task>

<task type="auto">
  <name>Task 2: Add audit logging to memory tool executor</name>
  <files>src/lib/jarvis/memory/toolExecutor.ts</files>
  <action>
Update executeMemoryTool to log every invocation:

1. Import logEvent:
```typescript
import { logEvent, type ToolInvocationData } from './queries/dailyLogs';
```

2. Update function signature:
```typescript
export async function executeMemoryTool(
  toolName: string,
  input: Record<string, unknown>,
  sessionId?: number  // Optional for backward compatibility
): Promise<string> {
```

3. Add logging after successful execution (inside try block, before return):
```typescript
// Log successful invocation
if (sessionId) {
  await logEvent(sessionId, 'tool_invocation', {
    toolName,
    success: true,
    context: summarizeToolContext(toolName, input, result),
  } as ToolInvocationData);
}
```

4. Add logging for errors (in catch block, before return):
```typescript
// Log failed invocation
if (sessionId) {
  await logEvent(sessionId, 'tool_invocation', {
    toolName,
    success: false,
    error: errorMessage,
  } as ToolInvocationData);
}
```

5. Add helper function to summarize context (keep logs readable):
```typescript
function summarizeToolContext(
  toolName: string,
  input: Record<string, unknown>,
  result: string
): string {
  switch (toolName) {
    case 'remember_fact':
      return `Stored: "${(input.content as string)?.slice(0, 50)}..."`;
    case 'forget_fact':
      return input.confirm_ids
        ? `Deleted IDs: ${input.confirm_ids}`
        : `Searching: "${input.query}"`;
    case 'list_memories':
      return 'Listed memories';
    case 'delete_all_memories':
      return input.confirm === 'true' ? 'Deleted all memories' : 'Confirmation required';
    case 'restore_memory':
      return `Restored ID: ${input.id}`;
    case 'observe_pattern':
      return `Pattern: ${input.pattern}`;
    default:
      return toolName;
  }
}
```
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit -p . 2>&1 | head -20
```
  </verify>
  <done>Memory tool executor logs all invocations to dailyLogs</done>
</task>

<task type="auto">
  <name>Task 3: Add audit logging to Notion tool executor</name>
  <files>src/lib/jarvis/notion/toolExecutor.ts</files>
  <action>
Update executeNotionTool to log every invocation:

1. Import logEvent:
```typescript
import { logEvent, type ToolInvocationData } from '../memory/queries/dailyLogs';
```

2. Update function signature:
```typescript
export async function executeNotionTool(
  toolName: string,
  input: Record<string, unknown>,
  sessionId?: number  // Optional for backward compatibility
): Promise<string> {
```

3. Add try-catch wrapper if not present, add logging:
```typescript
try {
  // ... existing tool execution logic ...

  // Log successful invocation
  if (sessionId) {
    await logEvent(sessionId, 'tool_invocation', {
      toolName,
      success: true,
      context: summarizeNotionContext(toolName, input),
    } as ToolInvocationData);
  }

  return result;
} catch (error) {
  const errorMessage = error instanceof Error ? error.message : 'Unknown error';

  // Log failed invocation
  if (sessionId) {
    await logEvent(sessionId, 'tool_invocation', {
      toolName,
      success: false,
      error: errorMessage,
    } as ToolInvocationData);
  }

  return JSON.stringify({ error: errorMessage });
}
```

4. Add helper function:
```typescript
function summarizeNotionContext(
  toolName: string,
  input: Record<string, unknown>
): string {
  switch (toolName) {
    case 'create_task':
      return `Created task: "${input.title}"`;
    case 'update_task_status':
      return `Updated "${input.title}" to ${input.status}`;
    case 'mark_bill_paid':
      return `Marked "${input.title}" as paid`;
    case 'pause_task':
      return `Paused "${input.title}"`;
    case 'add_project_item':
      return `Added "${input.text}" to ${input.project}`;
    default:
      // Query tools
      return `Queried ${toolName.replace('query_', '')}`;
  }
}
```
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit -p . 2>&1 | head -20
```
  </verify>
  <done>Notion tool executor logs all invocations to dailyLogs</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Run the app and execute a tool (e.g., "remember that I like coffee")
3. Check database for tool_invocation entries:
```sql
SELECT * FROM daily_logs WHERE event_type = 'tool_invocation' ORDER BY timestamp DESC LIMIT 5;
```
</verification>

<success_criteria>
- Every memory tool call creates a daily_logs entry
- Every Notion tool call creates a daily_logs entry
- Logs include tool name, success/failure, and human-readable context
- sessionId flows from Chat API through to tool executors
</success_criteria>

<output>
After completion, create `.planning/phases/10-guardrails-safety/10-01-SUMMARY.md`
</output>
