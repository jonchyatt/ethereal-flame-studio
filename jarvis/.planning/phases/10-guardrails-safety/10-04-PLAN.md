---
phase: 10-guardrails-safety
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/jarvis/memory/decay.ts
  - src/app/api/jarvis/chat/route.ts
  - src/lib/jarvis/config.ts
autonomous: true

must_haves:
  truths:
    - "Explicit memories (user_explicit source) never decay"
    - "Only inferred memories can be archived via decay"
    - "Context window utilization is logged when approaching limits"
  artifacts:
    - path: "src/lib/jarvis/memory/decay.ts"
      provides: "Source-aware decay calculation"
      contains: "user_explicit.*return 0"
    - path: "src/app/api/jarvis/chat/route.ts"
      provides: "Context window monitoring"
      contains: "estimatedTokens"
  key_links:
    - from: "decay.ts"
      to: "schema.ts source field"
      via: "checks entry.source before decay"
      pattern: "entry.source.*user_explicit"
    - from: "chat/route.ts"
      to: "console.warn"
      via: "warns at high context utilization"
      pattern: "Context.*utilization"
---

<objective>
Update decay logic to respect memory provenance, and add context window monitoring.

Purpose: Per CONTEXT.md, explicit memories never decay (permanent until user says "forget"). Also adds GUARD-05 (context window utilization monitoring) to prevent instruction drift.

Output: Explicit memories exempt from decay, and chat route logs warnings at high context utilization.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@jarvis/.planning/PROJECT.md
@jarvis/.planning/ROADMAP.md
@jarvis/.planning/STATE.md
@jarvis/.planning/phases/10-guardrails-safety/10-CONTEXT.md
@jarvis/.planning/phases/10-guardrails-safety/10-RESEARCH.md

# Current implementation
@src/lib/jarvis/memory/decay.ts
@src/lib/jarvis/memory/schema.ts
@src/app/api/jarvis/chat/route.ts
@src/lib/jarvis/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Exempt explicit memories from decay</name>
  <files>src/lib/jarvis/memory/decay.ts</files>
  <action>
Update calculateDecay to return 0 for user_explicit memories:

1. Modify the calculateDecay function to check source first:

```typescript
/**
 * Calculate decay factor for a memory entry.
 * Returns 0-1 where 0 = no decay (fresh) and 1 = fully decayed.
 *
 * Per CONTEXT.md:
 * - Explicit memories never decay (permanent until user says "forget")
 * - Only inferred memories can decay based on access patterns
 *
 * Factors:
 * - Days since last access (exponential decay with half-life)
 * - Source: explicit memories exempt, inferred memories use base decay
 *
 * @param entry - Memory entry to calculate decay for
 * @param now - Reference time (default: current time)
 * @returns Decay factor (0 = fresh/exempt, 1 = fully decayed)
 */
export function calculateDecay(entry: MemoryEntry, now: Date = new Date()): number {
  // Explicit memories never decay - permanent until user deletes
  if (entry.source === 'user_explicit') {
    return 0;
  }

  const config = getJarvisConfig();
  const lastAccessDate = new Date(entry.lastAccessed || entry.createdAt);
  const daysSinceAccess = Math.floor(
    (now.getTime() - lastAccessDate.getTime()) / (24 * 60 * 60 * 1000)
  );

  // Base decay: exponential with configurable half-life
  // At half-life days, decay = 0.5
  const baseDecay = 1 - Math.pow(0.5, daysSinceAccess / config.decayHalfLifeDays);

  // Note: explicitDecayMultiplier no longer used since explicit memories
  // are exempt. This is cleaner than a 0.5x multiplier.

  return Math.min(1, baseDecay);
}
```

2. Update cleanupDecayedMemories to also skip explicit memories (redundant but clear):

```typescript
export async function cleanupDecayedMemories(): Promise<number> {
  const config = getJarvisConfig();
  const entries = await getMemoryEntries(1000);
  const now = new Date();
  let archivedCount = 0;

  for (const entry of entries) {
    // Skip explicit memories entirely - they're permanent
    if (entry.source === 'user_explicit') {
      continue;
    }

    const decay = calculateDecay(entry, now);
    if (decay >= config.decayThreshold) {
      await softDeleteMemoryEntry(entry.id);
      archivedCount++;
      console.log(`[Decay] Archived inferred memory ${entry.id}: "${entry.content.slice(0, 30)}..." (decay: ${decay.toFixed(2)})`);
    }
  }

  if (archivedCount > 0) {
    console.log(`[Decay] Archived ${archivedCount} decayed memories (inferred only)`);
  }

  return archivedCount;
}
```

3. Optionally remove explicitDecayMultiplier from config (or leave it for future use).
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit -p . 2>&1 | head -20
```
  </verify>
  <done>Explicit memories exempt from decay, only inferred memories can be archived</done>
</task>

<task type="auto">
  <name>Task 2: Add context window monitoring</name>
  <files>src/app/api/jarvis/chat/route.ts</files>
  <action>
Add context window utilization monitoring to the Chat API route.

1. Add constants at the top (after imports):
```typescript
// Context window monitoring (GUARD-05)
// Claude 3.5 Haiku context: 200K tokens, but we're conservative
const MAX_CONTEXT_TOKENS = 100_000;  // Conservative limit
const WARN_THRESHOLD_PERCENT = 80;
const CHARS_PER_TOKEN = 4;  // Per STATE.md decision
```

2. Add monitoring before the Claude API call (inside the stream start function, before the while loop):

```typescript
// Monitor context window utilization (GUARD-05)
const systemPromptChars = serverSystemPrompt.length;
const messagesChars = JSON.stringify(claudeMessages).length;
const totalChars = systemPromptChars + messagesChars;
const estimatedTokens = Math.ceil(totalChars / CHARS_PER_TOKEN);
const utilizationPercent = (estimatedTokens / MAX_CONTEXT_TOKENS) * 100;

console.log(`[Chat] Context utilization: ${utilizationPercent.toFixed(1)}% (${estimatedTokens} tokens estimated)`);

if (utilizationPercent > WARN_THRESHOLD_PERCENT) {
  console.warn(`[Chat] High context utilization: ${utilizationPercent.toFixed(1)}% - consider summarizing conversation`);

  // Could add a hint to the system prompt, but per CONTEXT.md
  // we just log for now - no automatic truncation
}
```

3. This monitoring runs once per request. For long conversations with multiple tool iterations, the context grows - but the toolResults are short, so this is acceptable.

Note: Per CONTEXT.md, Claude's discretion on what to do at high utilization. For now, we just log the warning. Future enhancement could add automatic summarization.
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit -p . 2>&1 | head -20
```
  </verify>
  <done>Context window utilization logged, warnings at 80%+ utilization</done>
</task>

<task type="auto">
  <name>Task 3: Add test for decay exemption</name>
  <files>src/lib/jarvis/memory/__tests__/decay.test.ts</files>
  <action>
Create a simple test file to verify decay behavior:

```typescript
/**
 * Decay module tests
 *
 * Verifies that:
 * - Explicit memories never decay (CONTEXT.md decision)
 * - Inferred memories decay over time
 */

import { calculateDecay } from '../decay';
import type { MemoryEntry } from '../schema';

describe('calculateDecay', () => {
  const baseEntry: MemoryEntry = {
    id: 1,
    content: 'Test memory',
    contentHash: 'abc123',
    category: 'fact',
    source: 'jarvis_inferred',
    createdAt: new Date().toISOString(),
    lastAccessed: new Date().toISOString(),
    deletedAt: null,
  };

  it('should return 0 decay for user_explicit memories regardless of age', () => {
    const explicitEntry: MemoryEntry = {
      ...baseEntry,
      source: 'user_explicit',
      // Very old - 365 days ago
      lastAccessed: new Date(Date.now() - 365 * 24 * 60 * 60 * 1000).toISOString(),
    };

    expect(calculateDecay(explicitEntry)).toBe(0);
  });

  it('should return 0 decay for fresh inferred memories', () => {
    const freshEntry: MemoryEntry = {
      ...baseEntry,
      source: 'jarvis_inferred',
      lastAccessed: new Date().toISOString(),
    };

    // Fresh memories should have very low decay
    expect(calculateDecay(freshEntry)).toBeLessThan(0.1);
  });

  it('should return positive decay for old inferred memories', () => {
    const oldEntry: MemoryEntry = {
      ...baseEntry,
      source: 'jarvis_inferred',
      // 60 days ago - should be well past half-life
      lastAccessed: new Date(Date.now() - 60 * 24 * 60 * 60 * 1000).toISOString(),
    };

    const decay = calculateDecay(oldEntry);
    expect(decay).toBeGreaterThan(0.5);  // Past half-life
    expect(decay).toBeLessThan(1);       // Not fully decayed
  });
});
```

Note: If __tests__ directory doesn't exist, create it.
  </action>
  <verify>
Run the test:
```bash
npm test -- --testPathPattern="decay" 2>&1 | head -30
```
  </verify>
  <done>Tests verify explicit memories exempt from decay</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Decay tests pass
3. Start app and have a conversation - check logs for context utilization
4. Check that cleanupDecayedMemories skips explicit memories
</verification>

<success_criteria>
- calculateDecay returns 0 for user_explicit source
- cleanupDecayedMemories only archives inferred memories
- Context utilization logged on every chat request
- Warning logged when utilization exceeds 80%
- Tests verify decay exemption behavior
</success_criteria>

<output>
After completion, create `.planning/phases/10-guardrails-safety/10-04-SUMMARY.md`
</output>
