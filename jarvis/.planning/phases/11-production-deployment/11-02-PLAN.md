---
phase: 11-production-deployment
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/middleware.ts
  - src/lib/jarvis/api/fetchWithAuth.ts
  - src/app/jarvis/page.tsx
autonomous: true
user_setup:
  - service: vercel
    why: "API authentication secret"
    env_vars:
      - name: JARVIS_API_SECRET
        source: "Generate random string (e.g., openssl rand -hex 32)"
      - name: NEXT_PUBLIC_JARVIS_SECRET
        source: "Same value as JARVIS_API_SECRET"
    dashboard_config:
      - task: "Add JARVIS_API_SECRET and NEXT_PUBLIC_JARVIS_SECRET to environment variables"
        location: "Vercel Dashboard -> Project -> Settings -> Environment Variables"

must_haves:
  truths:
    - "Unauthenticated requests to /api/jarvis/* return 401"
    - "Authenticated requests with correct secret succeed"
    - "Client automatically includes X-Jarvis-Secret header"
  artifacts:
    - path: "src/middleware.ts"
      provides: "API authentication gate"
      contains: "X-Jarvis-Secret"
    - path: "src/lib/jarvis/api/fetchWithAuth.ts"
      provides: "Authenticated fetch wrapper"
      exports: ["fetchJarvisAPI"]
  key_links:
    - from: "src/app/jarvis/page.tsx"
      to: "src/lib/jarvis/api/fetchWithAuth.ts"
      via: "import fetchJarvisAPI"
      pattern: "fetchJarvisAPI.*api/jarvis"
---

<objective>
Add API authentication to protect Jarvis endpoints from unauthorized access

Purpose: Currently /api/jarvis/* routes are publicly accessible. Add X-Jarvis-Secret header validation to prevent unauthorized access while maintaining single-user simplicity.

Output:
- middleware.ts validates X-Jarvis-Secret header on all /api/jarvis/* routes
- fetchWithAuth.ts provides authenticated fetch wrapper for client
- All existing API calls updated to use authenticated fetch
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@jarvis/.planning/phases/11-production-deployment/11-CONTEXT.md
@jarvis/.planning/phases/11-production-deployment/11-RESEARCH.md
@src/middleware.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add API authentication to middleware</name>
  <files>src/middleware.ts</files>
  <action>
Update middleware.ts to validate X-Jarvis-Secret header on /api/jarvis/* routes:

```typescript
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

/**
 * Middleware for subdomain routing and API authentication
 *
 * jarvis.whatamiappreciatingnow.com -> serves /jarvis content at /
 * www.whatamiappreciatingnow.com -> serves main flame visualizer
 *
 * API Authentication:
 * /api/jarvis/* routes require X-Jarvis-Secret header
 */
export function middleware(request: NextRequest) {
  const hostname = request.headers.get('host') || '';
  const pathname = request.nextUrl.pathname;

  // Check if this is the jarvis subdomain
  const isJarvisSubdomain = hostname.startsWith('jarvis.');

  // API Authentication for Jarvis routes
  if (pathname.startsWith('/api/jarvis/')) {
    const secret = request.headers.get('X-Jarvis-Secret');
    const expectedSecret = process.env.JARVIS_API_SECRET;

    // In development without secret set, allow requests (for local testing)
    if (process.env.NODE_ENV === 'development' && !expectedSecret) {
      console.warn('[Middleware] JARVIS_API_SECRET not set - allowing unauthenticated requests in development');
    } else if (!expectedSecret || secret !== expectedSecret) {
      console.log(`[Middleware] Unauthorized request to ${pathname}`);
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }
  }

  if (isJarvisSubdomain) {
    // On jarvis subdomain: rewrite / to /jarvis
    if (pathname === '/') {
      return NextResponse.rewrite(new URL('/jarvis', request.url));
    }

    // Rewrite /api/* to /api/jarvis/* (except already jarvis routes)
    if (pathname.startsWith('/api/') && !pathname.startsWith('/api/jarvis/')) {
      // Block non-jarvis API routes on jarvis subdomain
      return NextResponse.json({ error: 'Not found' }, { status: 404 });
    }

    // Allow /api/jarvis/* routes as-is
    // Allow static assets and other paths
  }

  // On main domain: optionally block /jarvis routes if you want separation
  // For now, allow both to coexist

  return NextResponse.next();
}

export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public files (images, etc)
     */
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp|ico)$).*)',
  ],
};
```

Key changes:
- Added API authentication block before subdomain routing
- Validates X-Jarvis-Secret header against JARVIS_API_SECRET env var
- Returns 401 Unauthorized for missing/invalid secret
- Development mode allows unauthenticated if secret not set (for local testing)
  </action>
  <verify>
- File compiles: `npx tsc --noEmit src/middleware.ts`
- Contains auth check: `grep "X-Jarvis-Secret" src/middleware.ts`
  </verify>
  <done>Middleware validates X-Jarvis-Secret header on /api/jarvis/* routes</done>
</task>

<task type="auto">
  <name>Task 2: Create authenticated fetch wrapper</name>
  <files>src/lib/jarvis/api/fetchWithAuth.ts</files>
  <action>
Create new file src/lib/jarvis/api/fetchWithAuth.ts:

```typescript
/**
 * Authenticated Fetch Wrapper for Jarvis API
 *
 * Automatically includes:
 * - X-Jarvis-Secret header for authentication
 * - X-Timezone header for date boundary handling
 * - Content-Type for JSON requests
 */

/**
 * Fetch wrapper that adds authentication headers for Jarvis API calls
 *
 * @param endpoint - API endpoint path (e.g., 'session', 'chat')
 * @param options - Standard fetch options
 * @returns Fetch response
 */
export async function fetchJarvisAPI(
  endpoint: string,
  options: RequestInit = {}
): Promise<Response> {
  // Get secret from environment (client-side needs NEXT_PUBLIC_ prefix)
  const secret = process.env.NEXT_PUBLIC_JARVIS_SECRET || '';

  // Get user's timezone
  const timezone = typeof window !== 'undefined'
    ? Intl.DateTimeFormat().resolvedOptions().timeZone
    : 'America/New_York';

  // Build full URL - handle both relative and absolute endpoints
  const url = endpoint.startsWith('/api/')
    ? endpoint
    : `/api/jarvis/${endpoint}`;

  const response = await fetch(url, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      'X-Jarvis-Secret': secret,
      'X-Timezone': timezone,
      ...options.headers,
    },
  });

  return response;
}

/**
 * POST request helper
 */
export async function postJarvisAPI(
  endpoint: string,
  body: unknown
): Promise<Response> {
  return fetchJarvisAPI(endpoint, {
    method: 'POST',
    body: JSON.stringify(body),
  });
}

/**
 * GET request helper
 */
export async function getJarvisAPI(endpoint: string): Promise<Response> {
  return fetchJarvisAPI(endpoint, {
    method: 'GET',
  });
}

/**
 * PATCH request helper
 */
export async function patchJarvisAPI(
  endpoint: string,
  body: unknown
): Promise<Response> {
  return fetchJarvisAPI(endpoint, {
    method: 'PATCH',
    body: JSON.stringify(body),
  });
}
```

Note: The client needs NEXT_PUBLIC_JARVIS_SECRET to include in requests.
This is intentionally exposed to the client since Jarvis is single-user.
For multi-user, would need proper auth (sessions, JWT, etc).
  </action>
  <verify>
- File exists and compiles: `npx tsc --noEmit src/lib/jarvis/api/fetchWithAuth.ts`
- Exports correct: `grep "export.*function" src/lib/jarvis/api/fetchWithAuth.ts`
  </verify>
  <done>fetchWithAuth.ts provides authenticated fetch wrapper with X-Jarvis-Secret and X-Timezone headers</done>
</task>

<task type="auto">
  <name>Task 3: Update existing API calls to use authenticated fetch</name>
  <files>
    src/app/jarvis/page.tsx
    src/lib/jarvis/voice/VoicePipeline.ts
    src/components/jarvis/Dashboard.tsx
  </files>
  <action>
Search for all fetch calls to /api/jarvis/* and update to use fetchJarvisAPI:

1. Find all files with Jarvis API calls:
   ```bash
   grep -r "fetch.*api/jarvis" src/ --include="*.ts" --include="*.tsx"
   ```

2. For each file found, update the imports and fetch calls:

   ```typescript
   // OLD:
   const response = await fetch('/api/jarvis/session');

   // NEW:
   import { fetchJarvisAPI, getJarvisAPI, postJarvisAPI } from '@/lib/jarvis/api/fetchWithAuth';
   const response = await getJarvisAPI('session');
   ```

   ```typescript
   // OLD:
   const response = await fetch('/api/jarvis/chat', {
     method: 'POST',
     headers: { 'Content-Type': 'application/json' },
     body: JSON.stringify({ ... }),
   });

   // NEW:
   const response = await postJarvisAPI('chat', { ... });
   ```

3. Common locations to check:
   - src/app/jarvis/page.tsx (session management)
   - src/lib/jarvis/voice/VoicePipeline.ts (chat API)
   - src/components/jarvis/Dashboard.tsx (data fetching)
   - Any hooks or utilities that call Jarvis APIs

4. Do NOT update:
   - Server-side code (API routes calling other API routes - these should use direct function calls)
   - Test files (unless they test client-side behavior)
  </action>
  <verify>
- No direct fetch to /api/jarvis without auth headers:
  ```bash
  grep -r "fetch.*api/jarvis" src/ --include="*.ts" --include="*.tsx" | grep -v fetchWithAuth | grep -v "api/" | wc -l
  ```
  Should return 0 (excluding API routes themselves)
  </verify>
  <done>All client-side Jarvis API calls use authenticated fetch wrapper</done>
</task>

</tasks>

<verification>
1. Build passes:
   ```bash
   npm run build
   ```

2. Test unauthenticated request returns 401:
   ```bash
   # Start dev server
   npm run dev &

   # Test without header (should fail)
   curl -s http://localhost:3000/api/jarvis/session | grep -q "Unauthorized" && echo "PASS: 401 without secret"

   # Test with wrong header (should fail)
   curl -s -H "X-Jarvis-Secret: wrong" http://localhost:3000/api/jarvis/session | grep -q "Unauthorized" && echo "PASS: 401 with wrong secret"
   ```

3. Verify auth header is included in client code:
   ```bash
   grep -r "X-Jarvis-Secret" src/lib/jarvis/api/
   ```
</verification>

<success_criteria>
1. middleware.ts checks X-Jarvis-Secret header on /api/jarvis/* routes
2. fetchWithAuth.ts exists and exports fetchJarvisAPI
3. All client-side API calls use authenticated fetch
4. Unauthenticated requests return 401
5. Development mode works without secret set (for local testing)
</success_criteria>

<output>
After completion, create `.planning/phases/11-production-deployment/11-02-SUMMARY.md`
</output>
