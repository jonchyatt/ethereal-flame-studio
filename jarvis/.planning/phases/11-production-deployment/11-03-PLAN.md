---
phase: 11-production-deployment
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/jarvis/memory/queries/memoryEntries.ts
  - src/app/api/jarvis/session/route.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Memory dedup handles race condition gracefully (no unique constraint errors)"
    - "Session API does not leak env details or stack traces in production"
    - "Duplicate memory content updates lastAccessed instead of failing"
  artifacts:
    - path: "src/lib/jarvis/memory/queries/memoryEntries.ts"
      provides: "Atomic upsert with onConflictDoUpdate"
      contains: "onConflictDoUpdate"
    - path: "src/app/api/jarvis/session/route.ts"
      provides: "Sanitized error responses in production"
      contains: "NODE_ENV"
  key_links:
    - from: "src/lib/jarvis/memory/queries/memoryEntries.ts"
      to: "src/lib/jarvis/memory/schema.ts"
      via: "memoryEntries.contentHash unique constraint"
      pattern: "onConflictDoUpdate.*contentHash"
---

<objective>
Fix production hardening issues: memory dedup race condition and session API information leakage

Purpose: Two bugs that could cause production issues:
1. Memory dedup uses check-then-write pattern that fails under concurrent requests
2. Session API returns full error stack traces and env details in production

Output:
- memoryEntries.ts uses atomic onConflictDoUpdate instead of check-then-write
- session/route.ts sanitizes error responses based on NODE_ENV
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@jarvis/.planning/phases/11-production-deployment/11-CONTEXT.md
@jarvis/.planning/phases/11-production-deployment/11-RESEARCH.md
@src/lib/jarvis/memory/queries/memoryEntries.ts
@src/lib/jarvis/memory/schema.ts
@src/app/api/jarvis/session/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix memory dedup race condition with onConflictDoUpdate</name>
  <files>src/lib/jarvis/memory/queries/memoryEntries.ts</files>
  <action>
Replace the check-then-write pattern in storeMemoryEntry with atomic upsert:

```typescript
/**
 * Store a memory entry with deduplication using atomic upsert.
 *
 * If identical content (by hash) exists:
 * - Updates lastAccessed timestamp atomically
 * - Returns the entry (no duplicate created)
 *
 * If new content:
 * - Creates new entry with hash
 * - Returns new entry
 *
 * Uses onConflictDoUpdate to handle race conditions where two requests
 * try to insert the same content simultaneously.
 *
 * @param content - The fact to store
 * @param category - 'preference' | 'fact' | 'pattern'
 * @param source - 'user_explicit' | 'jarvis_inferred'
 * @returns The entry (existing or new)
 */
export async function storeMemoryEntry(
  content: string,
  category: MemoryCategory,
  source: MemorySource
): Promise<MemoryEntry> {
  const contentHash = hashContent(content);
  const now = new Date().toISOString();

  // Atomic upsert: insert or update lastAccessed if contentHash exists
  const result = await db
    .insert(memoryEntries)
    .values({
      content,
      contentHash,
      category,
      source,
      lastAccessed: now,
    })
    .onConflictDoUpdate({
      target: memoryEntries.contentHash,
      set: { lastAccessed: now },
    })
    .returning();

  return result[0];
}
```

Key changes:
- Removed the select-then-insert pattern that had a race condition
- Single atomic operation using onConflictDoUpdate
- If contentHash already exists, just updates lastAccessed
- If contentHash is new, inserts the full entry
- Uses `.returning()` to get the result (inserted or updated)

Note: The schema already has `.unique()` on contentHash (line 23 of schema.ts).
Drizzle's onConflictDoUpdate works with this unique constraint.
  </action>
  <verify>
- File compiles: `npx tsc --noEmit src/lib/jarvis/memory/queries/memoryEntries.ts`
- Contains onConflictDoUpdate: `grep "onConflictDoUpdate" src/lib/jarvis/memory/queries/memoryEntries.ts`
- No check-then-write pattern: `grep -A5 "const existing = await db" src/lib/jarvis/memory/queries/memoryEntries.ts` returns nothing
  </verify>
  <done>storeMemoryEntry uses atomic onConflictDoUpdate for race-condition-free deduplication</done>
</task>

<task type="auto">
  <name>Task 2: Sanitize session API error responses in production</name>
  <files>src/app/api/jarvis/session/route.ts</files>
  <action>
Update the GET handler to not leak env details or stack traces in production:

1. Remove the env logging that exposes whether variables are set:
```typescript
// REMOVE these lines:
console.log('[Session API] DATABASE_URL set:', !!process.env.DATABASE_URL);
console.log('[Session API] DATABASE_AUTH_TOKEN set:', !!process.env.DATABASE_AUTH_TOKEN);
```

2. Update the error response to sanitize in production:
```typescript
} catch (error) {
  console.error('[Session API] Error:', error);

  // Sanitize error response based on environment
  const isDev = process.env.NODE_ENV === 'development';

  return NextResponse.json(
    {
      error: isDev
        ? (error instanceof Error ? error.message : 'Unknown error')
        : 'Internal server error',
      // Only include stack trace in development
      ...(isDev && error instanceof Error && { stack: error.stack }),
    },
    { status: 500 }
  );
}
```

3. Apply same pattern to POST and PATCH handlers if they return detailed errors

Full updated GET handler:
```typescript
export async function GET() {
  try {
    // Development-only logging
    if (process.env.NODE_ENV === 'development') {
      console.log('[Session API] GET request received');
    }

    const sessionId = await MemoryService.initSession('user_initiated');
    const session = await getSessionById(sessionId);

    if (!session) {
      return NextResponse.json(
        { error: 'Failed to get session' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      id: session.id,
      startedAt: session.startedAt,
      active: true,
    });
  } catch (error) {
    console.error('[Session API] Error:', error);

    const isDev = process.env.NODE_ENV === 'development';

    return NextResponse.json(
      {
        error: isDev
          ? (error instanceof Error ? error.message : 'Unknown error')
          : 'Internal server error',
        ...(isDev && error instanceof Error && { stack: error.stack }),
      },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>
- File compiles: `npx tsc --noEmit src/app/api/jarvis/session/route.ts`
- No env logging: `grep "DATABASE_URL set\|DATABASE_AUTH_TOKEN set" src/app/api/jarvis/session/route.ts` returns nothing
- Has NODE_ENV check: `grep "NODE_ENV" src/app/api/jarvis/session/route.ts`
  </verify>
  <done>Session API error responses sanitized in production, detailed only in development</done>
</task>

<task type="auto">
  <name>Task 3: Add X-Timezone header handling for date boundaries</name>
  <files>
    src/lib/jarvis/notion/schemas.ts
    src/lib/jarvis/executive/CheckInManager.ts
  </files>
  <action>
The X-Timezone header is sent by the client (added in 11-02). Now handle it server-side:

1. In schemas.ts, update date filter functions to accept optional timezone:

For buildTaskFilter and similar functions, check if they use hardcoded "today":
```typescript
// Find current "today" calculation
const today = new Date().toISOString().split('T')[0];

// Update to accept timezone parameter:
export function buildTaskFilter(options: {
  filter?: 'today' | 'this_week' | 'overdue' | 'all';
  status?: 'pending' | 'completed' | 'all';
  timezone?: string;  // Add timezone parameter
}): object {
  const { filter = 'today', status = 'pending', timezone } = options;

  // Calculate "today" in user's timezone
  const today = getLocalDate(timezone);

  // ... rest of function
}

function getLocalDate(timezone?: string): string {
  const tz = timezone || 'America/New_York';  // Default to Eastern
  const formatter = new Intl.DateTimeFormat('en-CA', {
    timeZone: tz,
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
  });
  return formatter.format(new Date());  // Returns YYYY-MM-DD
}
```

2. In API routes that call Notion tools, read the X-Timezone header:
```typescript
// In route handler:
const timezone = request.headers.get('X-Timezone') || 'America/New_York';
// Pass to tool executor or filter builders
```

3. Thread timezone through toolExecutor.ts if needed

Note: This is a minimal change - the main fix is ensuring date calculations
use the user's timezone rather than server UTC.
  </action>
  <verify>
- schemas.ts compiles: `npx tsc --noEmit src/lib/jarvis/notion/schemas.ts`
- Has timezone handling: `grep "timezone\|X-Timezone\|Intl.DateTimeFormat" src/lib/jarvis/notion/schemas.ts`
  </verify>
  <done>Date filters use client timezone from X-Timezone header</done>
</task>

</tasks>

<verification>
1. Build passes:
   ```bash
   npm run build
   ```

2. Memory dedup doesn't fail on duplicate:
   ```bash
   # Start dev server and test via API or direct function call
   # Two rapid inserts of same content should both succeed
   ```

3. Production error response is sanitized:
   ```bash
   NODE_ENV=production npm run build
   # Error responses should say "Internal server error", not full stack
   ```

4. No sensitive logging in production:
   ```bash
   grep -r "DATABASE_URL set\|DATABASE_AUTH_TOKEN set\|Full error" src/app/api/jarvis/
   # Should return nothing (these logs removed)
   ```
</verification>

<success_criteria>
1. storeMemoryEntry uses onConflictDoUpdate (grep confirms)
2. Session API errors return "Internal server error" in production (not full message/stack)
3. No env variable existence logging in production code
4. Build passes
5. Timezone parameter added to date filter functions
</success_criteria>

<output>
After completion, create `.planning/phases/11-production-deployment/11-03-SUMMARY.md`
</output>
