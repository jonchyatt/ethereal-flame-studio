---
phase: 11-production-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/jarvis/notion/NotionClient.ts
  - src/lib/jarvis/notion/NotionClient.mcp.ts
  - src/lib/jarvis/notion/toolExecutor.ts
  - package.json
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Build succeeds without child_process error"
    - "Notion queries return real data (not mock)"
    - "Notion writes create/update pages in database"
  artifacts:
    - path: "src/lib/jarvis/notion/NotionClient.ts"
      provides: "Direct Notion SDK client"
      exports: ["queryDatabase", "createPage", "updatePage"]
    - path: "src/lib/jarvis/notion/NotionClient.mcp.ts"
      provides: "Parked MCP code for future MacBook integration"
    - path: "package.json"
      contains: "@notionhq/client"
  key_links:
    - from: "src/lib/jarvis/notion/toolExecutor.ts"
      to: "src/lib/jarvis/notion/NotionClient.ts"
      via: "import { queryDatabase, createPage, updatePage }"
      pattern: "import.*from.*NotionClient"
---

<objective>
Replace MCP-based Notion integration with Direct SDK to enable Vercel serverless deployment

Purpose: The current NotionClient.ts uses child_process.spawn() to run MCP server, which breaks Vercel builds. Direct SDK eliminates the child_process dependency while maintaining identical functionality.

Output:
- NotionClient.ts rewritten with @notionhq/client direct API calls
- Existing MCP code preserved as NotionClient.mcp.ts for future MacBook integration
- toolExecutor.ts updated to use new SDK-based functions
- Build passes without child_process error
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@jarvis/.planning/phases/11-production-deployment/11-CONTEXT.md
@jarvis/.planning/phases/11-production-deployment/11-RESEARCH.md
@src/lib/jarvis/notion/NotionClient.ts
@src/lib/jarvis/notion/toolExecutor.ts
@src/lib/jarvis/notion/schemas.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Notion SDK and park MCP code</name>
  <files>
    package.json
    src/lib/jarvis/notion/NotionClient.mcp.ts
  </files>
  <action>
1. Install @notionhq/client:
   ```bash
   npm install @notionhq/client
   ```

2. Rename existing NotionClient.ts to NotionClient.mcp.ts:
   - This preserves the MCP implementation for future MacBook integration
   - Add header comment: `/** PARKED: MCP implementation for MacBook daemon - see 11-CONTEXT.md */`

3. Verify package.json includes the new dependency
  </action>
  <verify>
- `npm ls @notionhq/client` shows package installed
- `NotionClient.mcp.ts` exists with MCP code preserved
  </verify>
  <done>Notion SDK installed and MCP code safely parked</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite NotionClient.ts with Direct SDK</name>
  <files>src/lib/jarvis/notion/NotionClient.ts</files>
  <action>
Create new NotionClient.ts with direct @notionhq/client usage:

```typescript
/**
 * Notion Direct SDK Client
 *
 * Direct API calls to Notion for Vercel serverless compatibility.
 * Replaces MCP stdio transport which requires child_process.
 *
 * MCP code preserved in NotionClient.mcp.ts for future MacBook integration.
 */

import { Client } from '@notionhq/client';

// Singleton client instance
let notionClient: Client | null = null;

/**
 * Get or create Notion client singleton
 */
function getNotionClient(): Client {
  if (!notionClient) {
    const token = process.env.NOTION_TOKEN;
    if (!token) {
      throw new Error('NOTION_TOKEN environment variable is required');
    }
    notionClient = new Client({ auth: token });
  }
  return notionClient;
}

/**
 * Query a Notion database (replaces API-query-data-source MCP tool)
 *
 * @param databaseId - The database UUID to query
 * @param filter - Optional Notion filter object
 * @param sorts - Optional sort array
 * @returns Query results with pages array
 */
export async function queryDatabase(
  databaseId: string,
  filter?: object,
  sorts?: object[]
): Promise<unknown> {
  const notion = getNotionClient();
  console.log(`[NotionClient] Querying database: ${databaseId}`);

  const response = await notion.databases.query({
    database_id: databaseId,
    filter: filter as Parameters<typeof notion.databases.query>[0]['filter'],
    sorts: sorts as Parameters<typeof notion.databases.query>[0]['sorts'],
  });

  return response;
}

/**
 * Create a page in a Notion database (replaces API-post-page MCP tool)
 *
 * @param parentDatabaseId - The parent database UUID
 * @param properties - Page properties object
 * @returns Created page object
 */
export async function createPage(
  parentDatabaseId: string,
  properties: object
): Promise<unknown> {
  const notion = getNotionClient();
  console.log(`[NotionClient] Creating page in database: ${parentDatabaseId}`);

  const response = await notion.pages.create({
    parent: { database_id: parentDatabaseId },
    properties: properties as Parameters<typeof notion.pages.create>[0]['properties'],
  });

  return response;
}

/**
 * Update a Notion page (replaces API-patch-page MCP tool)
 *
 * @param pageId - The page UUID to update
 * @param properties - Properties to update
 * @returns Updated page object
 */
export async function updatePage(
  pageId: string,
  properties: object
): Promise<unknown> {
  const notion = getNotionClient();
  console.log(`[NotionClient] Updating page: ${pageId}`);

  const response = await notion.pages.update({
    page_id: pageId,
    properties: properties as Parameters<typeof notion.pages.update>[0]['properties'],
  });

  return response;
}

/**
 * Retrieve a single page by ID (replaces API-retrieve-a-page MCP tool)
 *
 * @param pageId - The page UUID
 * @returns Page object
 */
export async function retrievePage(pageId: string): Promise<unknown> {
  const notion = getNotionClient();
  console.log(`[NotionClient] Retrieving page: ${pageId}`);

  const response = await notion.pages.retrieve({
    page_id: pageId,
  });

  return response;
}

/**
 * Search Notion workspace (replaces API-post-search MCP tool)
 *
 * @param query - Search query string
 * @param filter - Optional filter (e.g., { property: 'object', value: 'page' })
 * @returns Search results
 */
export async function searchNotion(
  query: string,
  filter?: { property: string; value: string }
): Promise<unknown> {
  const notion = getNotionClient();
  console.log(`[NotionClient] Searching for: ${query}`);

  const response = await notion.search({
    query,
    filter: filter as Parameters<typeof notion.search>[0]['filter'],
  });

  return response;
}
```

Key implementation notes:
- Uses singleton pattern (same as MCP version) to avoid multiple client instances
- Functions match the interface that toolExecutor.ts expects
- Console logging preserved for debugging
- TypeScript types cast to Notion SDK types for proper typing
  </action>
  <verify>
- File compiles: `npx tsc --noEmit src/lib/jarvis/notion/NotionClient.ts`
- Exports are correct: grep for "export async function"
  </verify>
  <done>NotionClient.ts provides queryDatabase, createPage, updatePage, retrievePage, searchNotion</done>
</task>

<task type="auto">
  <name>Task 3: Update toolExecutor.ts to use Direct SDK</name>
  <files>src/lib/jarvis/notion/toolExecutor.ts</files>
  <action>
Update toolExecutor.ts to use direct SDK functions instead of callMCPTool:

1. Replace import:
   ```typescript
   // OLD:
   import { callMCPTool } from './NotionClient';

   // NEW:
   import { queryDatabase, createPage, updatePage } from './NotionClient';
   ```

2. Update query_tasks case (and similar query cases):
   ```typescript
   // OLD:
   const result = await callMCPTool('API-query-data-source', {
     data_source_id: databaseId,
     ...filter,
   });

   // NEW:
   const result = await queryDatabase(databaseId, filter.filter, filter.sorts);
   ```

3. Update create_task case:
   ```typescript
   // OLD:
   await callMCPTool('API-post-page', {
     parent: { database_id: databaseId },
     properties,
   });

   // NEW:
   await createPage(databaseId, properties);
   ```

4. Update update_task_status, mark_bill_paid, pause_task cases:
   ```typescript
   // OLD:
   await callMCPTool('API-patch-page', {
     page_id: taskId,
     properties,
   });

   // NEW:
   await updatePage(taskId, properties);
   ```

5. Update add_project_item case similarly to create_task

Note: The LIFE_OS_DATABASES constants map to data_source_id (used for queries).
      The LIFE_OS_DATABASE_IDS constants map to database_id (used for creates).
      Direct SDK uses database_id for both - check if they're the same values.
  </action>
  <verify>
- File compiles: `npx tsc --noEmit src/lib/jarvis/notion/toolExecutor.ts`
- No references to callMCPTool remain: `grep -c "callMCPTool" src/lib/jarvis/notion/toolExecutor.ts` returns 0
  </verify>
  <done>toolExecutor.ts uses direct SDK functions for all Notion operations</done>
</task>

</tasks>

<verification>
1. Build passes:
   ```bash
   npm run build
   ```
   Should complete without "Module not found: Can't resolve 'child_process'" error

2. Type check passes:
   ```bash
   npx tsc --noEmit
   ```

3. No MCP references in active code:
   ```bash
   grep -r "callMCPTool\|child_process" src/lib/jarvis/notion/*.ts
   ```
   Should only show matches in NotionClient.mcp.ts (parked code)
</verification>

<success_criteria>
1. `npm run build` completes successfully (no child_process error)
2. NotionClient.ts exports queryDatabase, createPage, updatePage
3. toolExecutor.ts imports from NotionClient.ts (not MCP)
4. MCP code preserved in NotionClient.mcp.ts for future use
5. @notionhq/client in package.json dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/11-production-deployment/11-01-SUMMARY.md`
</output>
