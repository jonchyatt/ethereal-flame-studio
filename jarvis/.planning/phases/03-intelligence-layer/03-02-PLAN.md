---
phase: 03-intelligence-layer
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/jarvis/intelligence/ConversationManager.ts
  - src/lib/jarvis/intelligence/MemoryStore.ts
autonomous: true

must_haves:
  truths:
    - "Recent messages are preserved in context for multi-turn conversation"
    - "Older messages are summarized to stay within token limits"
    - "Key facts persist across page refreshes"
  artifacts:
    - path: "src/lib/jarvis/intelligence/ConversationManager.ts"
      provides: "Sliding window context management"
      exports: ["ConversationManager"]
      min_lines: 60
    - path: "src/lib/jarvis/intelligence/MemoryStore.ts"
      provides: "Cross-session persistence in localStorage"
      exports: ["MemoryStore"]
      min_lines: 40
  key_links:
    - from: "src/lib/jarvis/intelligence/ConversationManager.ts"
      to: "src/lib/jarvis/intelligence/MemoryStore.ts"
      via: "loads/saves memory"
      pattern: "memoryStore\\.(load|save)"
---

<objective>
Implement conversation context management with sliding window and cross-session persistence.

Purpose: Enable Jarvis to remember conversation history within a session and key facts across sessions. This is required for multi-turn conversations where user can reference previous statements.

Output: ConversationManager that maintains message history with token limits, and MemoryStore for localStorage persistence.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@jarvis/.planning/PROJECT.md
@jarvis/.planning/ROADMAP.md
@jarvis/.planning/STATE.md
@jarvis/.planning/phases/03-intelligence-layer/03-RESEARCH.md
@jarvis/.planning/phases/03-intelligence-layer/03-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MemoryStore for cross-session persistence</name>
  <files>src/lib/jarvis/intelligence/MemoryStore.ts</files>
  <action>
Create localStorage-based persistence for conversation memory. Match pattern from 03-RESEARCH.md.

Interface:
```typescript
interface SessionMemory {
  summary: string;           // Summarized older context
  keyFacts: string[];        // Important facts extracted from conversation
  lastUpdated: string;       // ISO timestamp
}

export class MemoryStore {
  load(): SessionMemory | null;
  save(memory: SessionMemory): void;
  addKeyFact(fact: string): void;
  updateSummary(summary: string): void;
  clear(): void;
}
```

Implementation:
1. Use localStorage key: 'jarvis_memory'
2. load(): Return null if no stored data or SSR (typeof window === 'undefined')
3. save(): Store with current timestamp
4. addKeyFact(): Add fact if not duplicate, keep max 20 most recent
5. updateSummary(): Update summary field and save
6. clear(): Remove from localStorage

Guard all methods against SSR (check typeof window).

Export the class and SessionMemory interface.
  </action>
  <verify>
- File exists at correct path
- TypeScript compiles: `npx tsc --noEmit src/lib/jarvis/intelligence/MemoryStore.ts`
- MemoryStore class and SessionMemory interface exported
  </verify>
  <done>MemoryStore persists key facts and summary to localStorage</done>
</task>

<task type="auto">
  <name>Task 2: Create ConversationManager with sliding window</name>
  <files>src/lib/jarvis/intelligence/ConversationManager.ts</files>
  <action>
Create conversation context manager with sliding window. Match pattern from 03-RESEARCH.md.

Interface:
```typescript
interface Message {
  role: 'user' | 'assistant';
  content: string;
}

export class ConversationManager {
  constructor(memoryStore?: MemoryStore);

  addMessage(message: Message): void;
  getContextMessages(): Message[];
  getKeyFacts(): string[];
  extractKeyFact(fact: string): void;
  shouldSummarize(): boolean;
  clear(): void;
}
```

Implementation:
1. Configuration:
   - maxRecentMessages: 10 (keep last 10 full messages)
   - maxKeyFacts: 20
2. Message storage:
   - In-memory array of recent messages
   - Load any existing summary/keyFacts from MemoryStore on construction
3. getContextMessages():
   - If summary exists, prepend as synthetic user/assistant exchange:
     - user: "[Previous conversation summary: {summary}]"
     - assistant: "I understand. I have context from our previous conversation."
   - Then append recent messages (slice -maxRecentMessages)
4. shouldSummarize():
   - Return true when messages.length > maxRecentMessages * 2
   - This signals that summarization should happen (actual summarization in 03-03)
5. extractKeyFact(): Add to memoryStore via addKeyFact()
6. clear(): Reset in-memory messages, optionally clear memoryStore

Important: Do NOT implement summarization logic here - that requires Claude API and is wired in 03-03.

Export the class and Message interface.
  </action>
  <verify>
- File exists at correct path
- TypeScript compiles: `npx tsc --noEmit src/lib/jarvis/intelligence/ConversationManager.ts`
- ConversationManager class and Message interface exported
  </verify>
  <done>ConversationManager maintains sliding window of recent messages with memory integration</done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npx tsc --noEmit src/lib/jarvis/intelligence/*.ts`
2. Manual verification in browser console:
```javascript
// Test MemoryStore
import { MemoryStore } from './src/lib/jarvis/intelligence/MemoryStore';
const store = new MemoryStore();
store.addKeyFact('User prefers morning meetings');
store.load(); // Should show the fact

// Test ConversationManager
import { ConversationManager } from './src/lib/jarvis/intelligence/ConversationManager';
const manager = new ConversationManager(store);
manager.addMessage({ role: 'user', content: 'Hello' });
manager.addMessage({ role: 'assistant', content: 'Hi there!' });
manager.getContextMessages(); // Should return messages with any prior summary
```
3. Verify localStorage persistence survives page refresh
</verification>

<success_criteria>
- ConversationManager maintains sliding window of recent messages
- MemoryStore persists key facts and summary to localStorage
- getContextMessages() returns properly formatted message array
- SSR-safe (no window errors on server)
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `jarvis/.planning/phases/03-intelligence-layer/03-02-SUMMARY.md`
</output>
