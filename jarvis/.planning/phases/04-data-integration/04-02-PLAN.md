---
phase: 04-data-integration
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/app/api/jarvis/chat/route.ts
  - src/lib/jarvis/notion/toolExecutor.ts
  - src/lib/jarvis/intelligence/tools.ts
autonomous: true

must_haves:
  truths:
    - "User says 'What tasks do I have?' and Jarvis reads from Notion"
    - "User says 'What bills are due?' and Jarvis reads from Notion"
    - "Claude tool_use triggers actual Notion query via MCP"
    - "Results are formatted as natural speech"
  artifacts:
    - path: "src/app/api/jarvis/chat/route.ts"
      provides: "Tool execution loop for Claude tool_use"
      contains: "stop_reason === 'tool_use'"
    - path: "src/lib/jarvis/notion/toolExecutor.ts"
      provides: "Routes tool calls to MCP operations"
      exports: ["executeNotionTool"]
    - path: "src/lib/jarvis/intelligence/tools.ts"
      provides: "Updated tool definitions (no changes needed for read)"
  key_links:
    - from: "chat/route.ts"
      to: "toolExecutor.ts"
      via: "executeNotionTool call"
      pattern: "executeNotionTool\\(toolUse\\.name"
    - from: "toolExecutor.ts"
      to: "NotionClient.ts"
      via: "callMCPTool"
      pattern: "callMCPTool\\("
---

<objective>
Implement the tool execution loop and read operations for tasks and bills.

Purpose: Enable Jarvis to answer questions like "What tasks do I have?" and "What bills are due?" by actually querying Notion via MCP. This is the core capability that makes Jarvis useful.

Output: Working read operations for tasks and bills with natural language responses.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@jarvis/.planning/PROJECT.md
@jarvis/.planning/ROADMAP.md
@jarvis/.planning/phases/04-data-integration/04-RESEARCH.md
@jarvis/.planning/phases/04-data-integration/04-01-SUMMARY.md

# Existing architecture
@src/app/api/jarvis/chat/route.ts
@src/lib/jarvis/intelligence/tools.ts
@src/lib/jarvis/notion/NotionClient.ts
@src/lib/jarvis/notion/schemas.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tool executor module</name>
  <files>
    - src/lib/jarvis/notion/toolExecutor.ts
  </files>
  <action>
Create `src/lib/jarvis/notion/toolExecutor.ts` to route tool calls to MCP operations:

1. Import callMCPTool from NotionClient
2. Import buildTaskFilter, buildBillFilter, formatTaskResults, formatBillResults from schemas
3. Read database IDs from environment:
   - NOTION_TASKS_DATA_SOURCE_ID
   - NOTION_BILLS_DATA_SOURCE_ID
4. Create `executeNotionTool(toolName: string, input: Record<string, unknown>): Promise<string>`:
   ```typescript
   switch (toolName) {
     case 'query_tasks':
       // Call MCP 'query-data-source' with tasks database
       // Format results for speech
     case 'query_bills':
       // Call MCP 'query-data-source' with bills database
       // Format results for speech
     case 'create_task':
     case 'update_task_status':
     case 'mark_bill_paid':
       // Return "coming soon" for now (implemented in 04-03)
       return 'This capability is being set up. For now, I can help you think through it.';
   }
   ```
5. Handle errors gracefully - return user-friendly error messages

Key implementation details:
- Use `query-data-source` MCP tool (NOT `query-database` - deprecated)
- Pass `data_source_id` from env vars
- Build filter using query builder functions
- Format results to be speech-friendly (no markdown, readable)

PITFALL: Property names are case-sensitive. If queries return empty, check property names match exactly.
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit src/lib/jarvis/notion/toolExecutor.ts
```
  </verify>
  <done>Tool executor routes query_tasks and query_bills to MCP operations</done>
</task>

<task type="auto">
  <name>Task 2: Update chat route with tool execution loop</name>
  <files>
    - src/app/api/jarvis/chat/route.ts
  </files>
  <action>
Update the existing chat route to implement the tool execution loop:

1. Import executeNotionTool from toolExecutor
2. Replace the streaming approach with a loop-based approach when tools are involved:
   - First call: messages.create (not stream) to detect tool_use
   - If stop_reason === 'tool_use':
     a. Execute tools in parallel with Promise.all
     b. Build tool_result content blocks (CRITICAL: tool_use_id must match toolUse.id exactly)
     c. Add assistant response and tool_results to messages
     d. Call Claude again with updated messages
     e. Repeat until stop_reason !== 'tool_use' (max 5 iterations)
   - Stream final text response to client
3. Keep SSE format for client compatibility
4. Add MAX_TOOL_ITERATIONS = 5 constant to prevent infinite loops

CRITICAL PITFALLS (from research):
- tool_result.tool_use_id MUST match toolUse.id exactly
- tool_result blocks must come FIRST in the user message content array
- Do NOT add text before tool_result blocks

The existing streaming pattern should be kept for the final response - only the tool loop uses non-streaming calls.

Remove the handleToolNotImplemented fallback - actual tool execution replaces it.
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit src/app/api/jarvis/chat/route.ts
```
  </verify>
  <done>Chat route executes tools via MCP when Claude uses tool_use</done>
</task>

<task type="auto">
  <name>Task 3: End-to-end verification</name>
  <files>None - testing only</files>
  <action>
Test the complete read flow:

1. Ensure .env.local has:
   - ANTHROPIC_API_KEY (valid)
   - NOTION_TOKEN (valid)
   - NOTION_TASKS_DATA_SOURCE_ID (from discovery)
   - NOTION_BILLS_DATA_SOURCE_ID (from discovery)

2. Start the dev server:
   ```bash
   npm run dev
   ```

3. Test via Jarvis UI (localhost:3000/jarvis):
   - Say "What tasks do I have?"
   - Verify Jarvis responds with actual task data from Notion
   - Say "What bills are due this week?"
   - Verify Jarvis responds with bill data

4. Check server logs for:
   - MCP process starting
   - Tool execution logging
   - No errors in tool loop

If tests fail:
- Check database IDs are correct
- Check property names match the user's Life OS schema
- Check MCP process is spawning correctly
- Look for JSON-RPC errors in logs

NOTE: If database IDs are not yet configured, the test may return "No tasks found" - that's acceptable if the MCP communication works.
  </action>
  <verify>
Server starts without errors, tool execution produces responses (even if "no results"):
```bash
# Start server, test manually via browser
npm run dev
# Check server output for MCP communication logs
```
  </verify>
  <done>Read operations work end-to-end: user voice -> STT -> Claude -> tool_use -> MCP -> Notion -> response</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all modified files
2. Server starts without errors
3. "What tasks do I have?" triggers Notion query (visible in logs)
4. "What bills are due?" triggers Notion query
5. Results formatted as natural speech (no JSON, no markdown)
</verification>

<success_criteria>
- User can ask about tasks and get real Notion data
- User can ask about bills and get real Notion data
- Tool loop handles multiple iterations correctly
- Errors are reported gracefully to user
- Ready for Plan 04-03 to add write operations
</success_criteria>

<output>
After completion, create `jarvis/.planning/phases/04-data-integration/04-02-SUMMARY.md`
</output>
