---
phase: 04-data-integration
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/app/api/jarvis/chat/route.ts
  - src/lib/jarvis/notion/toolExecutor.ts
  - src/lib/jarvis/intelligence/tools.ts
autonomous: true

must_haves:
  truths:
    - "User says 'What tasks do I have?' and Jarvis reads from Notion"
    - "User says 'What bills are due?' and Jarvis reads from Notion"
    - "User says 'What projects am I working on?' and Jarvis reads from Notion"
    - "User says 'What are my goals?' and Jarvis reads from Notion"
    - "User says 'How are my habits going?' and Jarvis reads from Notion"
    - "Claude tool_use triggers actual Notion query via MCP"
    - "Results are formatted as natural speech"
    - "All 5 Life OS read operations work (NOT-02, NOT-03 complete)"
  artifacts:
    - path: "src/app/api/jarvis/chat/route.ts"
      provides: "Tool execution loop for Claude tool_use"
      contains: "stop_reason === 'tool_use'"
    - path: "src/lib/jarvis/notion/toolExecutor.ts"
      provides: "Routes ALL read tool calls to MCP operations"
      exports: ["executeNotionTool"]
    - path: "src/lib/jarvis/intelligence/tools.ts"
      provides: "Tool definitions for ALL Life OS read operations"
      contains: "query_projects|query_goals|query_habits"
  key_links:
    - from: "chat/route.ts"
      to: "toolExecutor.ts"
      via: "executeNotionTool call"
      pattern: "executeNotionTool\\(toolUse\\.name"
    - from: "toolExecutor.ts"
      to: "NotionClient.ts"
      via: "callMCPTool"
      pattern: "callMCPTool\\("
---

<objective>
Implement the tool execution loop and read operations for ALL Life OS databases.

Purpose: Enable Jarvis to answer questions about tasks, bills, projects, goals, and habits by querying Notion via MCP. This covers NOT-02 (read tasks/projects) and NOT-03 (read goals/habits), and prepares for Phase 5 briefings that need project/goal/habit data.

Output: Working read operations for all 5 Life OS databases with natural language responses.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@jarvis/.planning/PROJECT.md
@jarvis/.planning/ROADMAP.md
@jarvis/.planning/phases/04-data-integration/04-RESEARCH.md
@jarvis/.planning/phases/04-data-integration/04-01-SUMMARY.md

# Existing architecture
@src/app/api/jarvis/chat/route.ts
@src/lib/jarvis/intelligence/tools.ts
@src/lib/jarvis/notion/NotionClient.ts
@src/lib/jarvis/notion/schemas.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tool executor module with ALL Life OS read operations</name>
  <files>
    - src/lib/jarvis/notion/toolExecutor.ts
  </files>
  <action>
Create `src/lib/jarvis/notion/toolExecutor.ts` to route tool calls to MCP operations:

1. Import callMCPTool from NotionClient
2. Import ALL filter builders and formatters from schemas:
   - buildTaskFilter, buildBillFilter, buildProjectFilter, buildGoalFilter, buildHabitFilter
   - formatTaskResults, formatBillResults, formatProjectResults, formatGoalResults, formatHabitResults
3. Import LIFE_OS_DATABASES from schemas (database IDs)
4. Create `executeNotionTool(toolName: string, input: Record<string, unknown>): Promise<string>`:
   ```typescript
   switch (toolName) {
     case 'query_tasks':
       // Call MCP 'query-data-source' with tasks database
       // Format results for speech
     case 'query_bills':
       // Call MCP 'query-data-source' with bills database
       // Format results for speech
     case 'query_projects':
       // Call MCP 'query-data-source' with projects database
       // Format results: name, status, timeline
     case 'query_goals':
       // Call MCP 'query-data-source' with goals database
       // Format results: name, progress, target date
     case 'query_habits':
       // Call MCP 'query-data-source' with habits database
       // Format results: name, streak, frequency
     // Write operations - coming soon placeholders for 04-03
     case 'create_task':
     case 'update_task_status':
     case 'mark_bill_paid':
     case 'pause_task':
     case 'add_project_item':
       return 'This capability is being set up. For now, I can help you think through it.';
   }
   ```
5. Handle errors gracefully - return user-friendly error messages

Key implementation details:
- Use `query-data-source` MCP tool (NOT `query-database` - deprecated)
- Pass `data_source_id` from LIFE_OS_DATABASES config
- Build filter using query builder functions
- Format results to be speech-friendly (no markdown, readable)
- Include IDs in formatted results for later update operations

PITFALL: Property names are case-sensitive. If queries return empty, check property names match exactly.
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit src/lib/jarvis/notion/toolExecutor.ts
```
  </verify>
  <done>Tool executor routes ALL 5 Life OS read operations to MCP</done>
</task>

<task type="auto">
  <name>Task 2: Add tool definitions for Projects, Goals, Habits</name>
  <files>
    - src/lib/jarvis/intelligence/tools.ts
  </files>
  <action>
Update `src/lib/jarvis/intelligence/tools.ts` to add tool definitions for all Life OS databases:

Add these new tool definitions (following existing pattern from Phase 3):

```typescript
{
  name: 'query_projects',
  description: 'Get projects from Notion. Use when user asks about their projects, what they are working on, or project status.',
  input_schema: {
    type: 'object',
    properties: {
      status: { type: 'string', enum: ['active', 'paused', 'completed', 'all'], description: 'Filter by project status' }
    }
  }
},
{
  name: 'query_goals',
  description: 'Get goals from Notion. Use when user asks about their goals, objectives, or what they are working towards.',
  input_schema: {
    type: 'object',
    properties: {
      timeframe: { type: 'string', enum: ['current', 'this_year', 'all'], description: 'Filter by goal timeframe' }
    }
  }
},
{
  name: 'query_habits',
  description: 'Get habits and their progress from Notion. Use when user asks about habits, routines, streaks, or consistency.',
  input_schema: {
    type: 'object',
    properties: {
      frequency: { type: 'string', enum: ['daily', 'weekly', 'all'], description: 'Filter by habit frequency' }
    }
  }
}
```

Add placeholder for write tool (implemented in 04-03):
```typescript
{
  name: 'add_project_item',
  description: 'Add an item to a project\'s needs list. Use when user wants to add requirements, sub-tasks, or notes to a project.',
  input_schema: {
    type: 'object',
    properties: {
      project_id: { type: 'string', description: 'The project ID or title' },
      item: { type: 'string', description: 'The item to add' },
      type: { type: 'string', enum: ['need', 'task', 'note'], description: 'Type of item' }
    },
    required: ['project_id', 'item']
  }
}
```

Export updated notionTools array with all 10 tools.
  </action>
  <verify>
TypeScript compiles and tools array has 10 items:
```bash
npx tsc --noEmit src/lib/jarvis/intelligence/tools.ts
```
  </verify>
  <done>Tool definitions exist for all 5 read operations and 5 write operations</done>
</task>

<task type="auto">
  <name>Task 3: Update chat route with tool execution loop</name>
  <files>
    - src/app/api/jarvis/chat/route.ts
  </files>
  <action>
Update the existing chat route to implement the tool execution loop:

1. Import executeNotionTool from toolExecutor
2. Replace the streaming approach with a loop-based approach when tools are involved:
   - First call: messages.create (not stream) to detect tool_use
   - If stop_reason === 'tool_use':
     a. Execute tools in parallel with Promise.all
     b. Build tool_result content blocks (CRITICAL: tool_use_id must match toolUse.id exactly)
     c. Add assistant response and tool_results to messages
     d. Call Claude again with updated messages
     e. Repeat until stop_reason !== 'tool_use' (max 5 iterations)
   - Stream final text response to client
3. Keep SSE format for client compatibility
4. Add MAX_TOOL_ITERATIONS = 5 constant to prevent infinite loops

CRITICAL PITFALLS (from research):
- tool_result.tool_use_id MUST match toolUse.id exactly
- tool_result blocks must come FIRST in the user message content array
- Do NOT add text before tool_result blocks

The existing streaming pattern should be kept for the final response - only the tool loop uses non-streaming calls.

Remove the handleToolNotImplemented fallback - actual tool execution replaces it.
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit src/app/api/jarvis/chat/route.ts
```
  </verify>
  <done>Chat route executes tools via MCP when Claude uses tool_use</done>
</task>

<task type="auto">
  <name>Task 4: End-to-end verification of ALL read operations</name>
  <files>None - testing only</files>
  <action>
Test the complete read flow for ALL Life OS databases:

1. Ensure .env.local has ALL database IDs (from discovery script):
   - ANTHROPIC_API_KEY (valid)
   - NOTION_TOKEN (valid)
   - NOTION_TASKS_DATA_SOURCE_ID
   - NOTION_BILLS_DATA_SOURCE_ID
   - NOTION_PROJECTS_DATA_SOURCE_ID
   - NOTION_GOALS_DATA_SOURCE_ID
   - NOTION_HABITS_DATA_SOURCE_ID

2. Start the dev server:
   ```bash
   npm run dev
   ```

3. Test ALL read operations via Jarvis UI (localhost:3000/jarvis):
   - "What tasks do I have?" → Jarvis reads from Tasks database
   - "What bills are due this week?" → Jarvis reads from Bills database
   - "What projects am I working on?" → Jarvis reads from Projects database
   - "What are my goals?" → Jarvis reads from Goals database
   - "How are my habits going?" → Jarvis reads from Habits database

4. Check server logs for:
   - MCP process starting
   - Tool execution for each query type
   - No errors in tool loop

5. Verify speech formatting:
   - Results are conversational, not JSON
   - IDs are included (for later update operations)
   - No markdown formatting

If tests fail:
- Check database IDs are correct
- Check property names match the user's Life OS schema
- Check MCP process is spawning correctly
- Look for JSON-RPC errors in logs

NOTE: If a database isn't configured, expect "No [items] found" - that's acceptable if MCP communication works.
  </action>
  <verify>
Server starts without errors, ALL 5 read tools produce responses:
```bash
npm run dev
# Test each query type via browser or curl
```
  </verify>
  <done>ALL Life OS read operations work end-to-end (Tasks, Bills, Projects, Goals, Habits)</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all modified files
2. Server starts without errors
3. Tools array has 10 items (5 read + 5 write)
4. All 5 read queries trigger Notion queries (visible in logs):
   - "What tasks do I have?" → query_tasks
   - "What bills are due?" → query_bills
   - "What projects am I working on?" → query_projects
   - "What are my goals?" → query_goals
   - "How are my habits going?" → query_habits
5. Results formatted as natural speech (no JSON, no markdown)
6. Write tools return "coming soon" placeholder
</verification>

<success_criteria>
- User can ask about tasks and get real Notion data (NOT-02)
- User can ask about bills and get real Notion data (FIN-01)
- User can ask about projects and get real Notion data (NOT-02)
- User can ask about goals and get real Notion data (NOT-03)
- User can ask about habits and get real Notion data (NOT-03)
- Tool loop handles multiple iterations correctly
- Errors are reported gracefully to user
- Phase 5 briefing dependencies are satisfied (goals, habits data available)
- Ready for Plan 04-03 to add write operations
</success_criteria>

<output>
After completion, create `jarvis/.planning/phases/04-data-integration/04-02-SUMMARY.md`
</output>
