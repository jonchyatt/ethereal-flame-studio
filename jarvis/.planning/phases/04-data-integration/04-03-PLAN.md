---
phase: 04-data-integration
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - src/lib/jarvis/notion/toolExecutor.ts
  - src/lib/jarvis/notion/schemas.ts
  - src/lib/jarvis/notion/recentResults.ts
  - src/lib/jarvis/intelligence/tools.ts
autonomous: true

must_haves:
  truths:
    - "User says 'Remind me to call mom' and task appears in Notion inbox"
    - "User can specify timing ('Call mom tomorrow') and task captures due date"
    - "User says 'Mark call mom as complete' and Jarvis finds the task and updates it"
    - "User says 'Mark electric bill as paid' and bill status updates"
    - "User says 'Table the website project' and task gets paused/deferred"
  artifacts:
    - path: "src/lib/jarvis/notion/toolExecutor.ts"
      provides: "Write operations for create, update, mark paid"
      contains: "create-a-page"
    - path: "src/lib/jarvis/notion/recentResults.ts"
      provides: "Cache of recent query results for task identification"
      exports: ["cacheResults", "findTaskByTitle", "findBillByTitle"]
    - path: "src/lib/jarvis/intelligence/tools.ts"
      provides: "Updated tools with pause_task"
      contains: "pause_task"
  key_links:
    - from: "toolExecutor.ts"
      to: "NotionClient.ts"
      via: "create-a-page, update-a-page MCP tools"
      pattern: "create-a-page|update-a-page"
    - from: "toolExecutor.ts"
      to: "recentResults.ts"
      via: "task title lookup"
      pattern: "findTaskByTitle"
---

<objective>
Implement write operations (create, update, complete) and voice-friendly task identification.

Purpose: Enable Jarvis to actually modify Notion data via voice commands. The key UX challenge is identifying tasks by natural voice description ("the call mom task") rather than requiring page IDs.

Output: Full CRUD capability for tasks and bills via voice.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@jarvis/.planning/PROJECT.md
@jarvis/.planning/ROADMAP.md
@jarvis/.planning/phases/04-data-integration/04-RESEARCH.md
@jarvis/.planning/phases/04-data-integration/04-01-SUMMARY.md
@jarvis/.planning/phases/04-data-integration/04-02-SUMMARY.md

# Existing architecture
@src/lib/jarvis/notion/toolExecutor.ts
@src/lib/jarvis/notion/schemas.ts
@src/lib/jarvis/intelligence/tools.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create recent results cache for task identification</name>
  <files>
    - src/lib/jarvis/notion/recentResults.ts
  </files>
  <action>
Create `src/lib/jarvis/notion/recentResults.ts` to solve the voice task identification problem:

When user says "Mark the call mom task as complete", we need to find the task ID. Solution: cache recent query results and match by title.

1. Create in-memory cache with TTL (5 minutes):
   ```typescript
   interface CachedItem {
     id: string;
     title: string;
     type: 'task' | 'bill';
     cachedAt: number;
   }

   const recentResults: CachedItem[] = [];
   const CACHE_TTL = 5 * 60 * 1000; // 5 minutes
   ```

2. `cacheResults(items: CachedItem[])`: Add items to cache, dedupe by ID

3. `findTaskByTitle(searchTerm: string): string | null`:
   - Clean expired items
   - Fuzzy match on title (case-insensitive, partial match)
   - Return ID of best match or null
   - Match priority: exact match > starts with > contains

4. `findBillByTitle(searchTerm: string): string | null`: Same for bills

5. `clearCache()`: For testing/reset

The cache is populated automatically when query_tasks or query_bills returns results. This creates a natural flow:
- User: "What tasks do I have?" -> results cached
- User: "Mark the first one complete" -> lookup by title

IMPORTANT: The cache is in-memory and per-request in serverless. For Vercel, this means the cache only works within a single invocation chain (tool loop). This is acceptable because:
1. Claude often queries then updates in same request
2. User can always re-query if cache is stale
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit src/lib/jarvis/notion/recentResults.ts
```
  </verify>
  <done>Recent results cache enables task/bill identification by title</done>
</task>

<task type="auto">
  <name>Task 2: Implement write operations in tool executor</name>
  <files>
    - src/lib/jarvis/notion/toolExecutor.ts
    - src/lib/jarvis/notion/schemas.ts
  </files>
  <action>
Update `toolExecutor.ts` to implement write operations:

1. Import cacheResults, findTaskByTitle, findBillByTitle from recentResults
2. Update query handlers to cache results after successful queries
3. Implement create_task handler:
   ```typescript
   case 'create_task':
     const properties = buildTaskProperties({
       title: input.title as string,
       due_date: input.due_date as string | undefined,
       priority: input.priority as string | undefined,
     });
     await callMCPTool('create-a-page', {
       parent: { type: 'data_source_id', data_source_id: TASKS_DS_ID },
       properties,
     });
     return `Created task: ${input.title}`;
   ```

4. Implement update_task_status handler:
   ```typescript
   case 'update_task_status':
     // If task_id looks like a title (not UUID), try to find it
     let taskId = input.task_id as string;
     if (!isValidUUID(taskId)) {
       const foundId = findTaskByTitle(taskId);
       if (!foundId) {
         return `I couldn't find a task matching "${taskId}". Try asking "What tasks do I have?" first.`;
       }
       taskId = foundId;
     }
     await callMCPTool('update-a-page', {
       page_id: taskId,
       properties: {
         Status: { status: { name: mapStatus(input.new_status) } },
       },
     });
     return `Marked task as ${input.new_status}`;
   ```

5. Implement mark_bill_paid handler (similar pattern)

6. Add helper functions to schemas.ts:
   - `buildTaskProperties(input)`: Build Notion properties object for task creation
   - `mapStatus(status)`: Convert pending/in_progress/completed to Notion values
   - `isValidUUID(str)`: Check if string is a valid UUID

Property mapping for tasks:
- title -> Task (title type)
- due_date -> Due Date (date type)
- priority -> Priority (select type)
- status -> Status (status type)

Property mapping for bills:
- Paid -> checkbox: true

NOTE: If user's Life OS uses different property names, they'll need to update schemas.ts after running discovery.
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit src/lib/jarvis/notion/toolExecutor.ts
```
  </verify>
  <done>Write operations create tasks, update status, and mark bills paid</done>
</task>

<task type="auto">
  <name>Task 3: Add pause_task tool and complete all handlers</name>
  <files>
    - src/lib/jarvis/intelligence/tools.ts
    - src/lib/jarvis/notion/toolExecutor.ts
  </files>
  <action>
Add the pause_task tool for NOT-07 (pause/table a task):

1. Add to tools.ts:
   ```typescript
   {
     name: 'pause_task',
     description: 'Pause or table a task for later. Use when user wants to defer a task or put it on hold.',
     input_schema: {
       type: 'object',
       properties: {
         task_id: {
           type: 'string',
           description: 'The task ID or title to pause'
         },
         defer_until: {
           type: 'string',
           description: 'Optional date to resurface the task (YYYY-MM-DD format)'
         },
         reason: {
           type: 'string',
           description: 'Optional reason for pausing'
         }
       },
       required: ['task_id']
     }
   }
   ```

2. Implement in toolExecutor.ts:
   ```typescript
   case 'pause_task':
     // Find task by title if needed
     // Update status to a "paused" or "on hold" state
     // If Life OS has a Deferred Date property, set it
     // Add reason to notes/comments if property exists
   ```

3. Remove the handleToolNotImplemented function and its import from tools.ts (no longer needed)

4. Verify all tool handlers are implemented:
   - query_tasks (04-02)
   - query_bills (04-02)
   - create_task (this task)
   - update_task_status (this task)
   - mark_bill_paid (this task)
   - pause_task (this task)

NOTE: The pause_task implementation depends on the user's Life OS schema. Common patterns:
- Status property with "On Hold" or "Paused" option
- Separate "Deferred Until" date property
- If neither exists, fall back to adding [PAUSED] to title
  </action>
  <verify>
TypeScript compiles and all 6 tools are defined:
```bash
npx tsc --noEmit src/lib/jarvis/intelligence/tools.ts src/lib/jarvis/notion/toolExecutor.ts
grep -c "case '" src/lib/jarvis/notion/toolExecutor.ts  # Should show 6
```
  </verify>
  <done>All 6 Notion tools are fully implemented</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all modified files
2. All 6 tool handlers implemented in toolExecutor.ts
3. Tools array in tools.ts has 6 items
4. handleToolNotImplemented no longer exists

Manual testing (via Jarvis UI):
1. "Remind me to call mom" -> Task appears in Notion
2. "What tasks do I have?" -> See the task
3. "Mark call mom as complete" -> Task status updates
4. "What bills are due?" -> See bills
5. "Mark the electric bill as paid" -> Bill marked paid
6. "Table the website project for next week" -> Task paused
</verification>

<success_criteria>
- User can create tasks via voice
- User can update task status by title reference
- User can mark bills as paid
- User can pause/defer tasks
- Task identification works via fuzzy title matching
- All Phase 4 requirements (NOT-01 through NOT-09, FIN-01, FIN-02) are satisfied
</success_criteria>

<output>
After completion, create `jarvis/.planning/phases/04-data-integration/04-03-SUMMARY.md`
</output>
