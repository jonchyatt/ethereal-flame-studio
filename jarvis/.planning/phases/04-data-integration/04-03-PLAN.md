---
phase: 04-data-integration
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - src/lib/jarvis/notion/toolExecutor.ts
  - src/lib/jarvis/notion/schemas.ts
  - src/lib/jarvis/notion/recentResults.ts
  - src/lib/jarvis/intelligence/tools.ts
autonomous: true

must_haves:
  truths:
    - "User says 'Remind me to call mom' and task appears in Notion inbox"
    - "User can specify timing ('Call mom tomorrow') and task captures due date"
    - "User says 'Mark call mom as complete' and Jarvis finds the task and updates it"
    - "User says 'Mark electric bill as paid' and bill status updates"
    - "User says 'Table the website project' and task gets paused/deferred"
    - "User says 'Add API integration to the website project' and item appears in project needs (NOT-08)"
  artifacts:
    - path: "src/lib/jarvis/notion/toolExecutor.ts"
      provides: "Write operations for create, update, mark paid, add project item"
      contains: "create-a-page"
    - path: "src/lib/jarvis/notion/recentResults.ts"
      provides: "Cache of recent query results for task/bill/project identification"
      exports: ["cacheResults", "findTaskByTitle", "findBillByTitle", "findProjectByTitle"]
    - path: "src/lib/jarvis/intelligence/tools.ts"
      provides: "Updated tools with pause_task and add_project_item"
      contains: "pause_task|add_project_item"
  key_links:
    - from: "toolExecutor.ts"
      to: "NotionClient.ts"
      via: "create-a-page, update-a-page MCP tools"
      pattern: "create-a-page|update-a-page"
    - from: "toolExecutor.ts"
      to: "recentResults.ts"
      via: "task/project title lookup"
      pattern: "findTaskByTitle|findProjectByTitle"
---

<objective>
Implement write operations (create, update, complete, add project items) and voice-friendly item identification.

Purpose: Enable Jarvis to actually modify Notion data via voice commands. The key UX challenge is identifying tasks/projects by natural voice description ("the call mom task", "the website project") rather than requiring page IDs. Covers NOT-04 through NOT-09, FIN-02.

Output: Full CRUD capability for tasks, bills, and project items via voice.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@jarvis/.planning/PROJECT.md
@jarvis/.planning/ROADMAP.md
@jarvis/.planning/phases/04-data-integration/04-RESEARCH.md
@jarvis/.planning/phases/04-data-integration/04-01-SUMMARY.md
@jarvis/.planning/phases/04-data-integration/04-02-SUMMARY.md

# Existing architecture
@src/lib/jarvis/notion/toolExecutor.ts
@src/lib/jarvis/notion/schemas.ts
@src/lib/jarvis/intelligence/tools.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create recent results cache for item identification</name>
  <files>
    - src/lib/jarvis/notion/recentResults.ts
  </files>
  <action>
Create `src/lib/jarvis/notion/recentResults.ts` to solve the voice item identification problem:

When user says "Mark the call mom task as complete" or "Add something to the website project", we need to find the item ID. Solution: cache recent query results and match by title.

1. Create in-memory cache with TTL (5 minutes):
   ```typescript
   interface CachedItem {
     id: string;
     title: string;
     type: 'task' | 'bill' | 'project' | 'goal' | 'habit';
     cachedAt: number;
   }

   const recentResults: CachedItem[] = [];
   const CACHE_TTL = 5 * 60 * 1000; // 5 minutes
   ```

2. `cacheResults(items: CachedItem[])`: Add items to cache, dedupe by ID

3. `findTaskByTitle(searchTerm: string): string | null`:
   - Clean expired items
   - Fuzzy match on title (case-insensitive, partial match)
   - Return ID of best match or null
   - Match priority: exact match > starts with > contains

4. `findBillByTitle(searchTerm: string): string | null`: Same for bills

5. `findProjectByTitle(searchTerm: string): string | null`: Same for projects (for add_project_item)

6. `clearCache()`: For testing/reset

The cache is populated automatically when query_* returns results. This creates a natural flow:
- User: "What projects am I working on?" -> results cached
- User: "Add API integration to the website project" -> lookup by title

IMPORTANT: The cache is in-memory and per-request in serverless. For Vercel, this means the cache only works within a single invocation chain (tool loop). This is acceptable because:
1. Claude often queries then updates in same request
2. User can always re-query if cache is stale
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit src/lib/jarvis/notion/recentResults.ts
```
  </verify>
  <done>Recent results cache enables task/bill/project identification by title</done>
</task>

<task type="auto">
  <name>Task 2: Implement write operations in tool executor</name>
  <files>
    - src/lib/jarvis/notion/toolExecutor.ts
    - src/lib/jarvis/notion/schemas.ts
  </files>
  <action>
Update `toolExecutor.ts` to implement write operations:

1. Import cacheResults, findTaskByTitle, findBillByTitle from recentResults
2. Update query handlers to cache results after successful queries
3. Implement create_task handler:
   ```typescript
   case 'create_task':
     const properties = buildTaskProperties({
       title: input.title as string,
       due_date: input.due_date as string | undefined,
       priority: input.priority as string | undefined,
     });
     await callMCPTool('create-a-page', {
       parent: { type: 'data_source_id', data_source_id: TASKS_DS_ID },
       properties,
     });
     return `Created task: ${input.title}`;
   ```

4. Implement update_task_status handler:
   ```typescript
   case 'update_task_status':
     // If task_id looks like a title (not UUID), try to find it
     let taskId = input.task_id as string;
     if (!isValidUUID(taskId)) {
       const foundId = findTaskByTitle(taskId);
       if (!foundId) {
         return `I couldn't find a task matching "${taskId}". Try asking "What tasks do I have?" first.`;
       }
       taskId = foundId;
     }
     await callMCPTool('update-a-page', {
       page_id: taskId,
       properties: {
         Status: { status: { name: mapStatus(input.new_status) } },
       },
     });
     return `Marked task as ${input.new_status}`;
   ```

5. Implement mark_bill_paid handler (similar pattern)

6. Add helper functions to schemas.ts:
   - `buildTaskProperties(input)`: Build Notion properties object for task creation
   - `mapStatus(status)`: Convert pending/in_progress/completed to Notion values
   - `isValidUUID(str)`: Check if string is a valid UUID

Property mapping for tasks:
- title -> Task (title type)
- due_date -> Due Date (date type)
- priority -> Priority (select type)
- status -> Status (status type)

Property mapping for bills:
- Paid -> checkbox: true

NOTE: If user's Life OS uses different property names, they'll need to update schemas.ts after running discovery.
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit src/lib/jarvis/notion/toolExecutor.ts
```
  </verify>
  <done>Write operations create tasks, update status, and mark bills paid</done>
</task>

<task type="auto">
  <name>Task 3: Add pause_task and add_project_item handlers</name>
  <files>
    - src/lib/jarvis/intelligence/tools.ts
    - src/lib/jarvis/notion/toolExecutor.ts
  </files>
  <action>
Add pause_task (NOT-07) and add_project_item (NOT-08) handlers:

**1. pause_task already defined in tools.ts (from 04-02). Implement handler:**
   ```typescript
   case 'pause_task':
     // Find task by title if needed
     // Update status to a "paused" or "on hold" state
     // If Life OS has a Deferred Date property, set it
     // Add reason to notes/comments if property exists
   ```

**2. add_project_item already defined in tools.ts (from 04-02). Implement handler:**
   ```typescript
   case 'add_project_item':
     // Find project by title if needed using findProjectByTitle
     let projectId = input.project_id as string;
     if (!isValidUUID(projectId)) {
       const foundId = findProjectByTitle(projectId);
       if (!foundId) {
         return `I couldn't find a project matching "${projectId}". Try asking "What projects am I working on?" first.`;
       }
       projectId = foundId;
     }

     // Create a new task/item linked to the project
     // OR add to project's "Needs" relation if it exists
     // Implementation depends on Life OS schema:
     // Option A: Create task with Project relation set
     // Option B: Add to project's sub-items/needs property

     await callMCPTool('create-a-page', {
       parent: { type: 'data_source_id', data_source_id: LIFE_OS_DATABASES.tasks },
       properties: {
         Task: { title: [{ text: { content: input.item } }] },
         Project: { relation: [{ id: projectId }] },  // Link to project
         // Type could map to tags or status
       },
     });
     return `Added "${input.item}" to the project`;
   ```

**3. Remove the handleToolNotImplemented function** (no longer needed)

**4. Verify all 10 tool handlers are implemented:**
   Read operations (from 04-02):
   - query_tasks, query_bills, query_projects, query_goals, query_habits

   Write operations (this plan):
   - create_task, update_task_status, mark_bill_paid, pause_task, add_project_item

NOTE: The implementations depend on user's Life OS schema:
- pause_task: Status "On Hold" or Deferred Date property
- add_project_item: Tasks with Project relation or separate sub-items database
  </action>
  <verify>
TypeScript compiles and all 10 tools are implemented:
```bash
npx tsc --noEmit src/lib/jarvis/intelligence/tools.ts src/lib/jarvis/notion/toolExecutor.ts
grep -c "case '" src/lib/jarvis/notion/toolExecutor.ts  # Should show 10
```
  </verify>
  <done>All 10 Notion tools are fully implemented (5 read + 5 write)</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all modified files
2. All 10 tool handlers implemented in toolExecutor.ts (5 read + 5 write)
3. Tools array in tools.ts has 10 items
4. handleToolNotImplemented no longer exists

Manual testing (via Jarvis UI):
1. "Remind me to call mom" -> Task appears in Notion (NOT-04)
2. "Call mom tomorrow morning" -> Task with due date (NOT-05)
3. "What tasks do I have?" -> See tasks including new one
4. "Mark call mom as complete" -> Task status updates (NOT-06)
5. "What bills are due?" -> See bills
6. "Mark the electric bill as paid" -> Bill marked paid (FIN-02)
7. "Table the website project for next week" -> Task paused (NOT-07)
8. "What projects am I working on?" -> See projects
9. "Add API integration to the website project" -> Item added (NOT-08)
</verification>

<success_criteria>
- User can create tasks via voice (NOT-04)
- User can create tasks with timing/context (NOT-05)
- User can update task status by title reference (NOT-06)
- User can pause/defer tasks (NOT-07)
- User can add items to project needs (NOT-08)
- User can mark bills as paid (FIN-02)
- Task/project identification works via fuzzy title matching
- All Phase 4 requirements satisfied:
  - NOT-01 through NOT-09 ✓
  - FIN-01, FIN-02 ✓
  - INF-03 (using integration token, OAuth deferred to v2)
  - INF-04 ✓
</success_criteria>

<output>
After completion, create `jarvis/.planning/phases/04-data-integration/04-03-SUMMARY.md`
</output>
