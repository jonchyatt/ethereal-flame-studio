---
phase: 09-memory-writing
plan: 04
type: execute
wave: 3
depends_on: ["09-02", "09-03"]
files_modified:
  - src/lib/jarvis/memory/schema.ts
  - src/lib/jarvis/memory/queries/observations.ts
  - src/lib/jarvis/memory/preferenceInference.ts
  - src/lib/jarvis/memory/index.ts
  - src/lib/jarvis/intelligence/memoryTools.ts
  - src/lib/jarvis/memory/toolExecutor.ts
  - src/lib/jarvis/intelligence/systemPrompt.ts
  - src/app/api/jarvis/chat/route.ts
autonomous: true

must_haves:
  truths:
    - "Jarvis learns user communication preferences over time"
    - "Inferred preferences require 3 consistent observations before storing"
    - "Inferred preferences are tagged as 'Learned' vs 'You told me'"
    - "Jarvis adapts response style based on observed preferences"
  artifacts:
    - path: "src/lib/jarvis/memory/schema.ts"
      provides: "observations table for tracking patterns"
      contains: "observations"
    - path: "src/lib/jarvis/memory/preferenceInference.ts"
      provides: "Observation tracking and inference logic"
      exports: ["recordObservation", "checkForInference", "OBSERVATION_THRESHOLD"]
    - path: "src/lib/jarvis/intelligence/systemPrompt.ts"
      provides: "Preference-aware system prompt building"
      contains: "inferredPreferences"
  key_links:
    - from: "chat/route.ts"
      to: "recordObservation"
      via: "records observations during conversation"
      pattern: "recordObservation"
    - from: "preferenceInference.ts"
      to: "storeMemoryEntry"
      via: "stores inferred preference when threshold met"
      pattern: "jarvis_inferred"
    - from: "chat/route.ts"
      to: "systemPrompt.ts"
      via: "passes inferred preferences to buildSystemPrompt"
      pattern: "inferredPreferences"
---

<objective>
Implement automatic preference learning from observed user behavior.

Purpose: Enable MEM-09 (Jarvis learns communication preferences) by tracking observation patterns and inferring preferences after 3 consistent signals. Wire inferred preferences into the system prompt so Claude adapts behavior.

Output: Observation tracking table, inference logic, tool for Claude to record observations, and system prompt integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@jarvis/.planning/PROJECT.md
@jarvis/.planning/ROADMAP.md
@jarvis/.planning/phases/09-memory-writing/09-CONTEXT.md
@jarvis/.planning/phases/09-memory-writing/09-RESEARCH.md

# Schema patterns
@src/lib/jarvis/memory/schema.ts

# Memory service patterns
@src/lib/jarvis/memory/index.ts
@src/lib/jarvis/memory/queries/memoryEntries.ts

# System prompt (to be modified)
@src/lib/jarvis/intelligence/systemPrompt.ts
@src/app/api/jarvis/chat/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add observations table to schema</name>
  <files>src/lib/jarvis/memory/schema.ts</files>
  <action>
Add a new table for tracking behavior observations that may become inferred preferences.

```typescript
/**
 * Observations - Behavioral patterns tracked before becoming preferences
 *
 * When Jarvis notices consistent behavior (e.g., user always asks for brief responses),
 * record an observation. After threshold observations of same pattern, infer preference.
 *
 * Pattern types: communication_style, scheduling, topic_interest, workflow
 */
export const observations = sqliteTable('observations', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  pattern: text('pattern').notNull(),        // Normalized pattern identifier (e.g., "prefers_brief_responses")
  patternType: text('pattern_type').notNull(), // 'communication_style' | 'scheduling' | 'topic_interest' | 'workflow'
  evidence: text('evidence'),                 // What triggered this observation
  sessionId: integer('session_id').references(() => sessions.id),
  createdAt: text('created_at').notNull().$defaultFn(() => new Date().toISOString()),
});

// Type exports
export type Observation = typeof observations.$inferSelect;
export type NewObservation = typeof observations.$inferInsert;
```

Position after dailyLogs table.
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit -p . 2>&1 | head -20
```

Check table exists:
```bash
grep -n "observations" src/lib/jarvis/memory/schema.ts
```
  </verify>
  <done>observations table exists in schema with pattern, patternType, evidence, sessionId, createdAt</done>
</task>

<task type="auto">
  <name>Task 2: Run database migration for observations table</name>
  <files>N/A (database operation)</files>
  <action>
Push the schema changes to the database using Drizzle.

```bash
npx drizzle-kit push
```

Verify the table exists in the database:
```bash
# For SQLite/Turso, verify table exists
sqlite3 [db-path] ".tables" 2>/dev/null | grep observations || \
  echo "Use Turso CLI or Drizzle Studio to verify schema"
```

If using Turso remote database, the push command will apply changes automatically.
  </action>
  <verify>
Run drizzle-kit push and check output confirms schema is in sync:
```bash
npx drizzle-kit push 2>&1 | tail -20
```

Or verify via Drizzle Studio if available:
```bash
npx drizzle-kit studio --port 4983 &
# Then check http://localhost:4983 shows observations table
```
  </verify>
  <done>Database has observations table</done>
</task>

<task type="auto">
  <name>Task 3: Create observation query functions</name>
  <files>src/lib/jarvis/memory/queries/observations.ts</files>
  <action>
Create `src/lib/jarvis/memory/queries/observations.ts` with CRUD functions.

```typescript
/**
 * Observation Query Functions
 *
 * Track behavioral patterns for preference inference.
 * After threshold observations of same pattern, infer preference.
 */

import { eq, and, gte, desc, sql } from 'drizzle-orm';
import { db } from '../db';
import { observations, type Observation, type NewObservation } from '../schema';

export type PatternType = 'communication_style' | 'scheduling' | 'topic_interest' | 'workflow';

/**
 * Record a new observation of a behavioral pattern.
 */
export async function recordObservation(
  pattern: string,
  patternType: PatternType,
  evidence: string,
  sessionId?: number
): Promise<Observation> {
  const inserted = await db
    .insert(observations)
    .values({
      pattern,
      patternType,
      evidence,
      sessionId: sessionId ?? null,
    })
    .returning();

  return inserted[0];
}

/**
 * Count observations of a specific pattern within time window.
 *
 * @param pattern - The pattern identifier
 * @param withinDays - Only count observations from last N days (default: 7)
 */
export async function countObservations(
  pattern: string,
  withinDays = 7
): Promise<number> {
  const cutoff = new Date();
  cutoff.setDate(cutoff.getDate() - withinDays);
  const cutoffStr = cutoff.toISOString();

  const result = await db
    .select({ count: sql<number>`count(*)` })
    .from(observations)
    .where(
      and(
        eq(observations.pattern, pattern),
        gte(observations.createdAt, cutoffStr)
      )
    );

  return result[0]?.count ?? 0;
}

/**
 * Get recent observations for a pattern (for debugging/display).
 */
export async function getObservationsForPattern(
  pattern: string,
  limit = 10
): Promise<Observation[]> {
  return db
    .select()
    .from(observations)
    .where(eq(observations.pattern, pattern))
    .orderBy(desc(observations.createdAt))
    .limit(limit);
}

/**
 * Clear observations for a pattern (after inference or rejection).
 */
export async function clearObservations(pattern: string): Promise<void> {
  await db.delete(observations).where(eq(observations.pattern, pattern));
}

/**
 * Get all unique patterns with observation counts.
 */
export async function getPatternCounts(): Promise<{ pattern: string; count: number }[]> {
  const result = await db
    .select({
      pattern: observations.pattern,
      count: sql<number>`count(*)`,
    })
    .from(observations)
    .groupBy(observations.pattern);

  return result;
}
```
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit -p . 2>&1 | head -20
```
  </verify>
  <done>observations.ts exports recordObservation, countObservations, getObservationsForPattern, clearObservations, getPatternCounts</done>
</task>

<task type="auto">
  <name>Task 4: Create preference inference module</name>
  <files>src/lib/jarvis/memory/preferenceInference.ts, src/lib/jarvis/memory/index.ts</files>
  <action>
Create `src/lib/jarvis/memory/preferenceInference.ts` with inference logic.

```typescript
/**
 * Preference Inference Module
 *
 * Tracks behavioral observations and infers preferences when
 * consistent patterns are observed (threshold = 3 within 7 days).
 */

import {
  recordObservation as dbRecordObservation,
  countObservations,
  clearObservations,
  type PatternType,
} from './queries/observations';
import { storeMemoryEntry } from './queries/memoryEntries';
import type { MemoryEntry } from './schema';

// Inference threshold: require 3 consistent observations within 7 days
export const OBSERVATION_THRESHOLD = 3;
export const OBSERVATION_WINDOW_DAYS = 7;

/**
 * Map pattern identifiers to human-readable preferences.
 */
const PATTERN_TO_PREFERENCE: Record<string, string> = {
  prefers_brief_responses: 'Prefers brief, concise responses',
  prefers_detailed_responses: 'Prefers detailed explanations',
  prefers_bullet_points: 'Prefers bullet point formatting',
  prefers_morning_tasks: 'Prefers tackling tasks in the morning',
  prefers_end_of_day_planning: 'Prefers planning at end of day',
  interested_in_productivity: 'Interested in productivity and workflow',
  interested_in_health: 'Interested in health and wellness topics',
  uses_informal_language: 'Prefers informal conversational tone',
  uses_formal_language: 'Prefers formal professional tone',
};

/**
 * Map pattern types to memory categories.
 */
const PATTERN_TYPE_TO_CATEGORY: Record<PatternType, string> = {
  communication_style: 'preference',
  scheduling: 'schedule',
  topic_interest: 'preference',
  workflow: 'preference',
};

/**
 * Record an observation and check if threshold is met for inference.
 *
 * @returns The inferred preference if threshold met, null otherwise
 */
export async function observeAndInfer(
  pattern: string,
  patternType: PatternType,
  evidence: string,
  sessionId?: number
): Promise<MemoryEntry | null> {
  // Record the observation
  await dbRecordObservation(pattern, patternType, evidence, sessionId);

  // Check count within window
  const count = await countObservations(pattern, OBSERVATION_WINDOW_DAYS);

  console.log(`[Inference] Pattern "${pattern}" observed ${count} times`);

  if (count >= OBSERVATION_THRESHOLD) {
    // Threshold met - infer preference
    const preferenceContent = PATTERN_TO_PREFERENCE[pattern] || pattern;
    const category = PATTERN_TYPE_TO_CATEGORY[patternType] || 'preference';

    console.log(`[Inference] Threshold met for "${pattern}", storing preference: "${preferenceContent}"`);

    // Store as inferred preference
    const entry = await storeMemoryEntry(
      preferenceContent,
      category as 'preference' | 'fact' | 'pattern',
      'jarvis_inferred'
    );

    // Clear observations now that preference is stored
    await clearObservations(pattern);

    return entry;
  }

  return null;
}

/**
 * Check if a pattern would trigger inference without recording.
 * Useful for testing or dry-run scenarios.
 */
export async function wouldInfer(pattern: string): Promise<boolean> {
  const count = await countObservations(pattern, OBSERVATION_WINDOW_DAYS);
  return count >= OBSERVATION_THRESHOLD - 1; // One more would trigger
}

/**
 * Get all pending patterns that are close to inference threshold.
 */
export async function getPendingInferences(): Promise<{ pattern: string; count: number; needed: number }[]> {
  const { getPatternCounts } = await import('./queries/observations');
  const counts = await getPatternCounts();

  return counts
    .filter(c => c.count > 0 && c.count < OBSERVATION_THRESHOLD)
    .map(c => ({
      pattern: c.pattern,
      count: c.count,
      needed: OBSERVATION_THRESHOLD - c.count,
    }));
}
```

Update index.ts to export:
```typescript
// Re-export observation and inference functions
export * from './queries/observations';
export * from './preferenceInference';
```
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit -p . 2>&1 | head -20
```

Check exports:
```bash
grep -E "^export" src/lib/jarvis/memory/preferenceInference.ts
```
  </verify>
  <done>preferenceInference.ts exports observeAndInfer, wouldInfer, getPendingInferences, OBSERVATION_THRESHOLD</done>
</task>

<task type="auto">
  <name>Task 5: Add observe_pattern tool for Claude</name>
  <files>src/lib/jarvis/intelligence/memoryTools.ts, src/lib/jarvis/memory/toolExecutor.ts</files>
  <action>
Add a tool for Claude to record behavioral observations.

1. Add to memoryTools.ts:
```typescript
{
  name: 'observe_pattern',
  description: 'Record a behavioral observation when you notice consistent user behavior. Use when user shows a pattern (e.g., always asking for brief responses, preferring bullet points). After 3 observations of the same pattern within 7 days, this becomes an inferred preference.',
  input_schema: {
    type: 'object',
    properties: {
      pattern: {
        type: 'string',
        description: 'Pattern identifier (e.g., "prefers_brief_responses", "prefers_bullet_points")',
        enum: [
          'prefers_brief_responses',
          'prefers_detailed_responses',
          'prefers_bullet_points',
          'prefers_morning_tasks',
          'prefers_end_of_day_planning',
          'interested_in_productivity',
          'interested_in_health',
          'uses_informal_language',
          'uses_formal_language'
        ]
      },
      pattern_type: {
        type: 'string',
        description: 'Category of the pattern',
        enum: ['communication_style', 'scheduling', 'topic_interest', 'workflow']
      },
      evidence: {
        type: 'string',
        description: 'What the user said or did that triggered this observation'
      }
    },
    required: ['pattern', 'pattern_type', 'evidence']
  }
}
```

2. Add handler to toolExecutor.ts:
```typescript
import { observeAndInfer } from './preferenceInference';
import type { PatternType } from './queries/observations';

// Add to switch statement:
case 'observe_pattern':
  return handleObservePattern(input);

// Add handler function:
async function handleObservePattern(input: Record<string, unknown>): Promise<string> {
  const pattern = input.pattern as string;
  const patternType = input.pattern_type as PatternType;
  const evidence = input.evidence as string;

  const inferred = await observeAndInfer(pattern, patternType, evidence);

  if (inferred) {
    return JSON.stringify({
      success: true,
      inferred: true,
      preference: inferred.content,
      message: `Observation recorded. Threshold reached - stored inferred preference: "${inferred.content}"`
    });
  }

  return JSON.stringify({
    success: true,
    inferred: false,
    message: `Observation recorded for pattern "${pattern}". Not yet at threshold.`
  });
}
```

3. Update the memoryToolNames array in chat/route.ts to include 'observe_pattern'.
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit -p . 2>&1 | head -20
```

Check tool exists:
```bash
grep -n "observe_pattern" src/lib/jarvis/intelligence/memoryTools.ts
grep -n "observe_pattern" src/lib/jarvis/memory/toolExecutor.ts
```
  </verify>
  <done>observe_pattern tool defined and implemented; chat route routes it correctly</done>
</task>

<task type="auto">
  <name>Task 6: Wire inferred preferences into system prompt</name>
  <files>src/lib/jarvis/intelligence/systemPrompt.ts, src/app/api/jarvis/chat/route.ts</files>
  <action>
Make Claude's behavior adapt based on stored inferred preferences.

1. Update SystemPromptContext interface in systemPrompt.ts:
```typescript
export interface SystemPromptContext {
  /** Current time for temporal awareness */
  currentTime: Date;
  /** User's name if known */
  userName?: string;
  /** Key facts from cross-session memory */
  keyFacts?: string[];
  /** Pre-formatted memory context from database (Phase 8) */
  memoryContext?: string;
  /** Proactive surfacing guidance (Phase 8) */
  proactiveSurfacing?: string;
  /** Inferred preferences (Phase 9) - patterns like prefers_brief_responses */
  inferredPreferences?: string[];
}
```

2. Add section to buildSystemPrompt that uses inferredPreferences:
```typescript
// Add after the MEMORY MANAGEMENT section
if (context.inferredPreferences && context.inferredPreferences.length > 0) {
  const preferenceGuidance: string[] = [];

  for (const pref of context.inferredPreferences) {
    // Map preference strings to actionable guidance
    if (pref.includes('brief') || pref.includes('concise')) {
      preferenceGuidance.push('- Keep responses SHORT. User prefers brevity.');
    }
    if (pref.includes('detailed')) {
      preferenceGuidance.push('- User prefers detailed explanations. Expand on your answers.');
    }
    if (pref.includes('bullet')) {
      preferenceGuidance.push('- Use bullet points for lists and structured info.');
    }
    if (pref.includes('informal')) {
      preferenceGuidance.push('- Keep tone casual and conversational.');
    }
    if (pref.includes('formal')) {
      preferenceGuidance.push('- Maintain professional, formal tone.');
    }
    if (pref.includes('morning')) {
      preferenceGuidance.push('- User is most productive in mornings.');
    }
  }

  if (preferenceGuidance.length > 0) {
    sections.push(`LEARNED PREFERENCES (from observed behavior):
${preferenceGuidance.join('\n')}

These are patterns I've noticed over time. Act on them naturally without mentioning that you "learned" them.`);
  }
}
```

3. In chat/route.ts, load inferred preferences and pass to buildSystemPrompt:
```typescript
// After loading memoryContext, also query for inferred preferences
let inferredPreferences: string[] | undefined;

if (config.enableMemoryLoading) {
  try {
    // ... existing memory loading code ...

    // Load inferred preferences (source='jarvis_inferred', category='preference')
    const { getEntriesByCategory } = await import('@/lib/jarvis/memory');
    const prefEntries = await getEntriesByCategory('preference');
    const inferred = prefEntries.filter(e => e.source === 'jarvis_inferred');
    if (inferred.length > 0) {
      inferredPreferences = inferred.map(e => e.content);
      console.log(`[Chat] Loaded ${inferredPreferences.length} inferred preferences`);
    }
  } catch (error) {
    console.error('[Chat] Memory loading failed, continuing without:', error);
  }
}

// Pass to buildSystemPrompt:
const serverSystemPrompt = buildSystemPrompt({
  currentTime: new Date(),
  memoryContext,
  proactiveSurfacing,
  inferredPreferences,  // <-- ADD THIS
});
```
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit -p . 2>&1 | head -20
```

Check system prompt uses inferredPreferences:
```bash
grep -n "inferredPreferences" src/lib/jarvis/intelligence/systemPrompt.ts
grep -n "inferredPreferences" src/app/api/jarvis/chat/route.ts
```

Check LEARNED PREFERENCES section exists:
```bash
grep -n "LEARNED PREFERENCES" src/lib/jarvis/intelligence/systemPrompt.ts
```
  </verify>
  <done>System prompt includes LEARNED PREFERENCES section; chat route loads and passes inferred preferences</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Schema has observations table:
```bash
grep -A 5 "export const observations" src/lib/jarvis/memory/schema.ts
```

2. Migration applied:
```bash
npx drizzle-kit push 2>&1 | grep -E "(No changes|Applied|success)"
```

3. Observation queries exist:
```bash
grep -E "^export (async )?function" src/lib/jarvis/memory/queries/observations.ts
```

4. Inference module exists:
```bash
grep -E "^export" src/lib/jarvis/memory/preferenceInference.ts
```

5. observe_pattern tool exists:
```bash
grep "observe_pattern" src/lib/jarvis/intelligence/memoryTools.ts
```

6. System prompt wires preferences:
```bash
grep "inferredPreferences" src/lib/jarvis/intelligence/systemPrompt.ts
grep "LEARNED PREFERENCES" src/lib/jarvis/intelligence/systemPrompt.ts
```

7. Chat route passes preferences:
```bash
grep "inferredPreferences" src/app/api/jarvis/chat/route.ts
```

8. TypeScript compiles:
```bash
npx tsc --noEmit -p .
```
</verification>

<success_criteria>
1. observations table in schema with pattern, patternType, evidence, sessionId
2. Database migration applied (observations table exists in DB)
3. Query functions: recordObservation, countObservations, clearObservations
4. observeAndInfer returns inferred preference when threshold (3) met
5. Inferred preferences tagged as 'jarvis_inferred' source
6. observe_pattern tool lets Claude record behavioral observations
7. After 3 observations within 7 days, preference is automatically stored
8. Inferred preferences loaded in chat/route.ts and passed to buildSystemPrompt
9. System prompt includes LEARNED PREFERENCES section with actionable guidance
10. Jarvis adapts response style based on observed preferences
11. All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-memory-writing/09-04-SUMMARY.md`
</output>
