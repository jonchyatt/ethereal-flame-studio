---
phase: 09-memory-writing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/jarvis/memory/schema.ts
  - src/lib/jarvis/memory/queries/memoryEntries.ts
  - src/lib/jarvis/memory/index.ts
autonomous: true

must_haves:
  truths:
    - "Deleted memories are excluded from normal queries"
    - "User can restore a soft-deleted memory within 30 days"
    - "Fuzzy matching finds memories by natural language description"
  artifacts:
    - path: "src/lib/jarvis/memory/schema.ts"
      provides: "deleted_at column for soft delete"
      contains: "deletedAt"
    - path: "src/lib/jarvis/memory/queries/memoryEntries.ts"
      provides: "softDelete, restore, findMatching functions"
      exports: ["softDeleteMemoryEntry", "restoreMemoryEntry", "findMemoriesMatching", "getDeletedMemories"]
  key_links:
    - from: "queries/memoryEntries.ts"
      to: "schema.ts"
      via: "uses deletedAt column in queries"
      pattern: "deletedAt"
---

<objective>
Add soft delete infrastructure and fuzzy matching to the memory system.

Purpose: Enable the forget/restore flow (MEM-03) by adding deleted_at column and search functions that match user natural language to stored memories.

Output: Schema migration and query functions for soft delete, restore, and fuzzy matching.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@jarvis/.planning/PROJECT.md
@jarvis/.planning/ROADMAP.md
@jarvis/.planning/STATE.md
@jarvis/.planning/phases/09-memory-writing/09-CONTEXT.md
@jarvis/.planning/phases/09-memory-writing/09-RESEARCH.md

# Prior phase summaries
@jarvis/.planning/phases/08-memory-loading-integration/08-01-SUMMARY.md

# Current implementation
@src/lib/jarvis/memory/schema.ts
@src/lib/jarvis/memory/queries/memoryEntries.ts
@src/lib/jarvis/memory/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add deleted_at column to schema</name>
  <files>src/lib/jarvis/memory/schema.ts</files>
  <action>
Add `deletedAt` column to the memoryEntries table:

```typescript
deletedAt: text('deleted_at'),  // null = active, ISO string = soft deleted
```

Position it after `lastAccessed` for consistency.

Update the type exports to include deletedAt in the inferred types (this happens automatically with Drizzle).

NOTE: Since we're using Turso with migrations handled externally, this schema change requires running migrations. The schema file is the source of truth - migrations will be handled by the standard Drizzle migrate workflow.
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit -p . 2>&1 | head -20
```
  </verify>
  <done>memoryEntries table has deletedAt column, types include it</done>
</task>

<task type="auto">
  <name>Task 2: Add soft delete and restore query functions</name>
  <files>src/lib/jarvis/memory/queries/memoryEntries.ts</files>
  <action>
Add these functions to memoryEntries.ts:

1. `softDeleteMemoryEntry(id: number)`:
   - Sets deletedAt to current ISO timestamp
   - Returns the updated entry

2. `restoreMemoryEntry(id: number)`:
   - Sets deletedAt to null
   - Returns the restored entry

3. `getDeletedMemories(limit = 50)`:
   - Returns entries where deletedAt is NOT null
   - Ordered by deletedAt desc (most recently deleted first)
   - Only returns entries deleted within last 30 days

4. Modify `getMemoryEntries(limit, includeDeleted = false)`:
   - Add optional second parameter `includeDeleted`
   - When false (default): filter where deletedAt IS NULL
   - When true: return all entries

5. Modify `getEntriesByCategory` similarly to exclude deleted by default.

Import `isNull` from drizzle-orm for the null checks.

Example soft delete filter:
```typescript
import { isNull, isNotNull, gte } from 'drizzle-orm';

// In getMemoryEntries:
if (!includeDeleted) {
  return query.where(isNull(memoryEntries.deletedAt));
}
```
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit -p . 2>&1 | head -20
```
  </verify>
  <done>softDeleteMemoryEntry, restoreMemoryEntry, getDeletedMemories functions exist; getMemoryEntries/getEntriesByCategory exclude deleted by default</done>
</task>

<task type="auto">
  <name>Task 3: Add fuzzy matching function for forget requests</name>
  <files>src/lib/jarvis/memory/queries/memoryEntries.ts, src/lib/jarvis/memory/index.ts</files>
  <action>
Add `findMemoriesMatching(query: string, limit = 5)` to memoryEntries.ts:

1. Normalize the query using existing `normalizeContent` function
2. Split into words (filter words < 3 chars)
3. Get all active memories (not deleted)
4. Score each entry by word overlap:
   - +1 for each query word found in normalized content
   - +queryWords.length bonus for exact substring match
5. Return top N matches sorted by score (exclude score = 0)

```typescript
export async function findMemoriesMatching(
  query: string,
  limit = 5
): Promise<MemoryEntry[]> {
  const normalizedQuery = normalizeContent(query);
  const queryWords = normalizedQuery.split(' ').filter(w => w.length > 2);

  // Get all active entries
  const allEntries = await getMemoryEntries(500);

  // Score each entry by word overlap
  const scored = allEntries.map(entry => {
    const normalizedContent = normalizeContent(entry.content);
    let score = 0;

    for (const word of queryWords) {
      if (normalizedContent.includes(word)) {
        score += 1;
      }
    }

    // Boost exact substring match
    if (normalizedContent.includes(normalizedQuery)) {
      score += queryWords.length;
    }

    return { entry, score };
  });

  return scored
    .filter(s => s.score > 0)
    .sort((a, b) => b.score - a.score)
    .slice(0, limit)
    .map(s => s.entry);
}
```

Then update index.ts to re-export the new functions:
- softDeleteMemoryEntry
- restoreMemoryEntry
- getDeletedMemories
- findMemoriesMatching

Also add MemoryService static methods:
```typescript
static async forget(id: number): Promise<MemoryEntry | null> {
  const entry = await getMemoryEntryById(id);
  if (!entry || entry.deletedAt) return null;
  return softDeleteMemoryEntry(id);
}

static async restore(id: number): Promise<MemoryEntry | null> {
  const { getMemoryEntryById } = await import('./queries/memoryEntries');
  const entry = await getMemoryEntryById(id);
  if (!entry || !entry.deletedAt) return null;
  return restoreMemoryEntry(id);
}

static async findForForget(query: string): Promise<MemoryEntry[]> {
  return findMemoriesMatching(query);
}
```
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit -p . 2>&1 | head -20
```

And run existing tests to ensure no regressions:
```bash
npm test -- --testPathPattern="memory" --passWithNoTests 2>&1 | tail -20
```
  </verify>
  <done>findMemoriesMatching function exists and is exported; MemoryService has forget(), restore(), findForForget() methods</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Schema has deletedAt column:
```bash
grep -n "deletedAt" src/lib/jarvis/memory/schema.ts
```

2. Query functions exist:
```bash
grep -E "^export (async )?function (softDelete|restore|getDeleted|findMemories)" src/lib/jarvis/memory/queries/memoryEntries.ts
```

3. MemoryService has new methods:
```bash
grep -E "static async (forget|restore|findForForget)" src/lib/jarvis/memory/index.ts
```

4. TypeScript compiles:
```bash
npx tsc --noEmit -p .
```
</verification>

<success_criteria>
1. memoryEntries schema includes deletedAt column
2. softDeleteMemoryEntry sets deletedAt timestamp
3. restoreMemoryEntry clears deletedAt
4. getDeletedMemories returns recently deleted entries
5. getMemoryEntries excludes deleted by default
6. findMemoriesMatching returns scored matches
7. MemoryService.forget(), .restore(), .findForForget() work
8. All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-memory-writing/09-01-SUMMARY.md`
</output>
