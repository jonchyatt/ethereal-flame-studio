---
phase: 09-memory-writing
plan: 03
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/lib/jarvis/intelligence/systemPrompt.ts
  - src/lib/jarvis/memory/decay.ts
  - src/lib/jarvis/memory/index.ts
  - src/lib/jarvis/config.ts
autonomous: true

must_haves:
  truths:
    - "Claude knows when to use remember/forget tools from natural conversation"
    - "Old unaccessed memories have reduced retrieval priority"
    - "Memory decay is configurable via environment variables"
  artifacts:
    - path: "src/lib/jarvis/intelligence/systemPrompt.ts"
      provides: "Memory management guidance section"
      contains: "MEMORY MANAGEMENT"
    - path: "src/lib/jarvis/memory/decay.ts"
      provides: "Decay calculation and cleanup functions"
      exports: ["calculateDecay", "applyDecayToScore", "cleanupDecayedMemories"]
  key_links:
    - from: "systemPrompt.ts"
      to: "memoryTools"
      via: "tells Claude when to use each memory tool"
      pattern: "remember_fact|forget_fact|list_memories"
    - from: "retrieval.ts"
      to: "decay.ts"
      via: "applies decay to memory scores"
      pattern: "applyDecayToScore"
---

<objective>
Add system prompt guidance for memory tools and implement memory decay algorithm.

Purpose: Enable Claude to correctly identify user intent for memory operations (via prompt guidance) and implement MEM-10 (intelligent forgetting) via decay algorithm.

Output: System prompt additions and decay module.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@jarvis/.planning/PROJECT.md
@jarvis/.planning/ROADMAP.md
@jarvis/.planning/phases/09-memory-writing/09-CONTEXT.md
@jarvis/.planning/phases/09-memory-writing/09-RESEARCH.md

# System prompt patterns
@jarvis/.planning/phases/08-memory-loading-integration/08-02-SUMMARY.md
@src/lib/jarvis/intelligence/systemPrompt.ts

# Memory retrieval (has scoring)
@src/lib/jarvis/memory/retrieval.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add memory management guidance to system prompt</name>
  <files>src/lib/jarvis/intelligence/systemPrompt.ts</files>
  <action>
Add a new section to buildSystemPrompt that teaches Claude when to use memory tools.

Add this after the MEMORY CONTEXT section (when memoryContext is provided):

```typescript
// Add after the memory context guidance section
if (context.memoryContext) {
  sections.push(`MEMORY MANAGEMENT:
When users want you to remember something:
- Explicit triggers: "remember", "don't forget", "keep in mind"
- Soft hints: "I always...", "Every Thursday I...", "I prefer..."
- Extract the core fact, normalize it for searchability
- Use remember_fact tool with appropriate category
- ALWAYS confirm: "Got it, I'll remember that."

When users want you to forget something:
- Triggers: "forget", "don't remember", "remove", "delete"
- Use forget_fact tool with their description as query
- ALWAYS show matches and ask for confirmation before deleting
- If multiple matches: "I found 3 items about therapy. Which should I forget?"
- If one match: "I'll forget that you have therapy on Thursdays. Sound right?"

When users ask what you remember:
- Triggers: "what do you know", "what do you remember", "show memories"
- Use list_memories tool
- Speak brief highlights (3-5 key items)
- For many memories: "You've told me about your schedule, work projects, and a few preferences."
- Mention they can ask for specifics: "Want me to focus on any area?"

For full memory wipe:
- Triggers: "delete all memories", "forget everything", "clear all"
- Use delete_all_memories tool ONLY after explicit confirmation
- Double-check: "This will permanently delete everything I know about you. Are you sure?"

Categories for facts:
- schedule: recurring events, appointments, deadlines
- preference: communication style, workflow habits, likes/dislikes
- person: facts about people you know (family, colleagues, friends)
- work: projects, work patterns, professional context
- health: medical, wellness, fitness info
- other: anything that doesn't fit above`);
}
```

This section is only added when memory is enabled, keeping v1 behavior unchanged.
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit -p . 2>&1 | head -20
```

Check section exists:
```bash
grep -n "MEMORY MANAGEMENT" src/lib/jarvis/intelligence/systemPrompt.ts
```
  </verify>
  <done>System prompt includes MEMORY MANAGEMENT section with intent detection guidance</done>
</task>

<task type="auto">
  <name>Task 2: Create memory decay module</name>
  <files>src/lib/jarvis/memory/decay.ts, src/lib/jarvis/config.ts</files>
  <action>
Create `src/lib/jarvis/memory/decay.ts` with decay calculation and cleanup.

1. First, add decay config to `src/lib/jarvis/config.ts`:
```typescript
// Add to JarvisConfig interface:
decayHalfLifeDays: number;        // JARVIS_DECAY_HALF_LIFE (default: 30)
explicitDecayMultiplier: number;  // JARVIS_EXPLICIT_DECAY_MULT (default: 0.5)
decayThreshold: number;           // JARVIS_DECAY_THRESHOLD (default: 0.9)

// Add to getJarvisConfig():
decayHalfLifeDays: parseInt(process.env.JARVIS_DECAY_HALF_LIFE || '30', 10),
explicitDecayMultiplier: parseFloat(process.env.JARVIS_EXPLICIT_DECAY_MULT || '0.5'),
decayThreshold: parseFloat(process.env.JARVIS_DECAY_THRESHOLD || '0.9'),
```

2. Create decay.ts:
```typescript
import type { MemoryEntry } from './schema';
import { getMemoryEntries, softDeleteMemoryEntry } from './queries/memoryEntries';
import { getJarvisConfig } from '../config';

/**
 * Calculate decay factor for a memory entry.
 * Returns 0-1 where 0 = no decay (fresh) and 1 = fully decayed.
 *
 * Factors:
 * - Days since last access (exponential decay with half-life)
 * - Source: explicit memories decay slower (multiplier < 1)
 */
export function calculateDecay(entry: MemoryEntry, now: Date = new Date()): number {
  const config = getJarvisConfig();
  const lastAccessDate = new Date(entry.lastAccessed || entry.createdAt);
  const daysSinceAccess = Math.floor(
    (now.getTime() - lastAccessDate.getTime()) / (24 * 60 * 60 * 1000)
  );

  // Base decay: exponential with configurable half-life
  // At half-life days, decay = 0.5
  const baseDecay = 1 - Math.pow(0.5, daysSinceAccess / config.decayHalfLifeDays);

  // Source modifier: explicit memories decay slower
  const sourceModifier = entry.source === 'user_explicit'
    ? config.explicitDecayMultiplier
    : 1.0;

  return Math.min(1, baseDecay * sourceModifier);
}

/**
 * Apply decay penalty to a retrieval score.
 * Used in retrieval.ts to reduce scores of decayed memories.
 */
export function applyDecayToScore(baseScore: number, decay: number): number {
  // Decay reduces score: score * (1 - decay)
  // At decay=0, score unchanged; at decay=0.5, score halved
  return Math.round(baseScore * (1 - decay));
}

/**
 * Soft-delete memories that have decayed beyond threshold.
 * Run periodically (e.g., at session start) to clean up.
 *
 * @returns Number of memories archived
 */
export async function cleanupDecayedMemories(): Promise<number> {
  const config = getJarvisConfig();
  const entries = await getMemoryEntries(1000);
  const now = new Date();
  let archivedCount = 0;

  for (const entry of entries) {
    const decay = calculateDecay(entry, now);
    if (decay >= config.decayThreshold) {
      await softDeleteMemoryEntry(entry.id);
      archivedCount++;
      console.log(`[Decay] Archived memory ${entry.id}: "${entry.content.slice(0, 30)}..." (decay: ${decay.toFixed(2)})`);
    }
  }

  if (archivedCount > 0) {
    console.log(`[Decay] Archived ${archivedCount} decayed memories`);
  }

  return archivedCount;
}
```
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit -p . 2>&1 | head -20
```

Check exports:
```bash
grep -E "^export (function|async function)" src/lib/jarvis/memory/decay.ts
```
  </verify>
  <done>decay.ts exports calculateDecay, applyDecayToScore, cleanupDecayedMemories</done>
</task>

<task type="auto">
  <name>Task 3: Integrate decay into retrieval scoring</name>
  <files>src/lib/jarvis/memory/retrieval.ts, src/lib/jarvis/memory/index.ts</files>
  <action>
Update retrieval.ts to apply decay to memory scores.

1. Import decay function:
```typescript
import { calculateDecay, applyDecayToScore } from './decay';
```

2. Modify scoreMemory function to include decay:
```typescript
export function scoreMemory(entry: MemoryEntry, now: Date): number {
  const recency = calculateRecencyScore(entry, now);
  const category = calculateCategoryScore(entry.category);
  const source = calculateSourceScore(entry.source);

  const baseScore = recency + category + source;

  // Apply decay penalty
  const decay = calculateDecay(entry, now);
  return applyDecayToScore(baseScore, decay);
}
```

3. Update index.ts to export decay functions:
```typescript
// Re-export decay functions
export * from './decay';
```

The effect: Old, unaccessed memories will have lower scores and be less likely to be retrieved, satisfying MEM-10 (intelligent forgetting without hard delete).
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit -p . 2>&1 | head -20
```

Check decay is used in scoring:
```bash
grep -n "decay" src/lib/jarvis/memory/retrieval.ts
```
  </verify>
  <done>scoreMemory applies decay penalty; decay functions exported from index.ts</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. System prompt has memory management:
```bash
grep -A 5 "MEMORY MANAGEMENT" src/lib/jarvis/intelligence/systemPrompt.ts
```

2. Decay module exists:
```bash
ls -la src/lib/jarvis/memory/decay.ts
```

3. Config has decay settings:
```bash
grep -E "decay" src/lib/jarvis/config.ts
```

4. Retrieval uses decay:
```bash
grep "applyDecayToScore" src/lib/jarvis/memory/retrieval.ts
```

5. TypeScript compiles:
```bash
npx tsc --noEmit -p .
```
</verification>

<success_criteria>
1. System prompt includes MEMORY MANAGEMENT section with triggers and categories
2. decay.ts exports calculateDecay, applyDecayToScore, cleanupDecayedMemories
3. Config has decayHalfLifeDays, explicitDecayMultiplier, decayThreshold
4. scoreMemory applies decay penalty to base score
5. Old memories get lower scores (decay reduces priority)
6. cleanupDecayedMemories soft-deletes heavily decayed entries
7. All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-memory-writing/09-03-SUMMARY.md`
</output>
