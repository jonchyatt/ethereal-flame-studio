---
phase: 05-executive-function-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/jarvis/executive/types.ts
  - src/lib/jarvis/executive/Scheduler.ts
  - src/lib/jarvis/executive/BriefingBuilder.ts
  - src/lib/jarvis/executive/BriefingFlow.ts
  - src/lib/jarvis/stores/jarvisStore.ts
  - src/components/jarvis/JarvisOrb.tsx
autonomous: true

must_haves:
  truths:
    - "User hears morning briefing with tasks, bills, and habits"
    - "Briefing follows outline-first structure from CONTEXT.md"
    - "User can skip sections by voice or tap"
    - "Empty sections are mentioned briefly and skipped"
    - "Orb becomes tap target for voice activation"
  artifacts:
    - path: "src/lib/jarvis/executive/types.ts"
      provides: "Type definitions for scheduling and briefings"
      exports: ["ScheduledEvent", "BriefingData", "BriefingSection", "NudgeEvent"]
    - path: "src/lib/jarvis/executive/Scheduler.ts"
      provides: "Client-side scheduler for time-based events"
      exports: ["Scheduler"]
    - path: "src/lib/jarvis/executive/BriefingBuilder.ts"
      provides: "Aggregates Notion data for briefings"
      exports: ["buildMorningBriefing", "buildCheckInData"]
    - path: "src/lib/jarvis/executive/BriefingFlow.ts"
      provides: "State machine for briefing walkthrough"
      exports: ["BriefingFlow"]
  key_links:
    - from: "Scheduler.ts"
      to: "BriefingFlow.ts"
      via: "onTrigger callback"
      pattern: "onTrigger.*morning_briefing"
    - from: "BriefingBuilder.ts"
      to: "toolExecutor.ts"
      via: "Promise.all parallel queries"
      pattern: "executeNotionTool.*query_"
    - from: "JarvisOrb.tsx"
      to: "VoicePipeline"
      via: "tap handler"
      pattern: "onClick.*startListening"
---

<objective>
Build the morning briefing workflow with scheduler infrastructure and data aggregation.

Purpose: This is the foundation for all proactive executive function features. The scheduler triggers time-based events, the briefing builder aggregates Notion data, and the briefing flow delivers a section-by-section spoken summary.

Output: Working morning briefing that user can trigger or receive at scheduled time, following the outline-first structure from CONTEXT.md.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@jarvis/.planning/PROJECT.md
@jarvis/.planning/ROADMAP.md
@jarvis/.planning/STATE.md
@jarvis/.planning/phases/05-executive-function-core/05-CONTEXT.md
@jarvis/.planning/phases/05-executive-function-core/05-RESEARCH.md

# Existing architecture
@src/lib/jarvis/voice/VoicePipeline.ts
@src/lib/jarvis/notion/toolExecutor.ts
@src/lib/jarvis/stores/jarvisStore.ts
@src/components/jarvis/JarvisOrb.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create executive function types and Scheduler class</name>
  <files>
    - src/lib/jarvis/executive/types.ts
    - src/lib/jarvis/executive/Scheduler.ts
  </files>
  <action>
Install date-fns for date manipulation:
```bash
npm install date-fns
```

Create `src/lib/jarvis/executive/types.ts` with:

1. **ScheduledEvent interface:**
```typescript
interface ScheduledEvent {
  id: string;
  type: 'morning_briefing' | 'midday_checkin' | 'evening_checkin' | 'nudge';
  time: string; // HH:mm format
  enabled: boolean;
  lastTriggered?: number; // timestamp
}
```

2. **BriefingSection type:**
```typescript
type BriefingSection = 'outline' | 'tasks' | 'calendar' | 'bills' | 'habits' | 'complete';
```

3. **BriefingData interface:**
```typescript
interface BriefingData {
  tasks: { today: TaskSummary[]; overdue: TaskSummary[] };
  bills: { thisWeek: BillSummary[]; total: number };
  habits: { active: HabitSummary[]; streakSummary: string };
  goals: { active: GoalSummary[] };
  calendar: { today: CalendarEvent[] };
}
```

4. **Summary types** for each data type (TaskSummary, BillSummary, HabitSummary, GoalSummary, CalendarEvent) with just the fields needed for spoken briefings.

5. **NudgeEvent interface** for time-based nudges (used in Plan 02).

**NOTE on CalendarEvent:** Phase 4 did NOT create a `query_calendar` tool. Calendar events in BriefingData will be derived from Tasks that have due dates/times today (treating scheduled tasks as calendar items). The CalendarEvent type should include:
```typescript
interface CalendarEvent {
  id: string;
  title: string;
  time: string;      // formatted time like "9:00 AM"
  isUpcoming: boolean;
  sourceTaskId?: string;  // if derived from a task
}
```

Create `src/lib/jarvis/executive/Scheduler.ts` with:

1. **Scheduler class** following the pattern from 05-RESEARCH.md:
   - Constructor takes `onTrigger: (event: ScheduledEvent) => void` callback
   - `start()`: Begin 1-minute interval check
   - `stop()`: Clear interval
   - `check()`: Compare current HH:mm to scheduled events, trigger if match and not already triggered today
   - `loadSchedule()`: Load from localStorage or use defaults
   - `saveSchedule()`: Persist to localStorage
   - `updateSchedule(events)`: Allow user to customize times
   - `getSchedule()`: Return current schedule

2. **Default schedule:**
   - morning_briefing: 08:00
   - midday_checkin: 12:00
   - evening_checkin: 17:00

3. **Background tab handling:**
   - Use `document.addEventListener('visibilitychange', ...)` to catch up when tab regains focus
   - Check if any scheduled event was missed in last hour
   - If missed, ask user if they want it now (via callback)

4. **Export singleton factory:**
```typescript
let instance: Scheduler | null = null;
export function getScheduler(onTrigger: (event: ScheduledEvent) => void): Scheduler {
  if (!instance) {
    instance = new Scheduler(onTrigger);
  }
  return instance;
}
```
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit src/lib/jarvis/executive/types.ts src/lib/jarvis/executive/Scheduler.ts
```
  </verify>
  <done>Scheduler class exists with localStorage persistence and background tab handling</done>
</task>

<task type="auto">
  <name>Task 2: Create BriefingBuilder and BriefingFlow</name>
  <files>
    - src/lib/jarvis/executive/BriefingBuilder.ts
    - src/lib/jarvis/executive/BriefingFlow.ts
  </files>
  <action>
Create `src/lib/jarvis/executive/BriefingBuilder.ts`:

1. **buildMorningBriefing()** - Aggregates ALL data for morning briefing:
```typescript
export async function buildMorningBriefing(): Promise<BriefingData> {
  // Parallel queries via existing toolExecutor
  // Use Promise.all for concurrent fetches
}
```

2. **Call these existing Phase 4 tools in parallel** (all confirmed working per STATE.md):
   - `query_tasks` with filter: 'today', status: 'pending'
   - `query_tasks` with filter: 'overdue', status: 'pending'
   - `query_bills` with timeframe: 'this_week'
   - `query_habits` with frequency: 'all'
   - `query_goals` with status: 'active'

3. **Derive calendar events from tasks:**
   Since there is no `query_calendar` tool, calendar events are derived from tasks that have due dates/times:
   ```typescript
   function deriveCalendarEvents(tasks: TaskSummary[]): CalendarEvent[] {
     // Filter tasks with specific due times (not just due dates)
     // Sort by time
     // Format as CalendarEvent[]
     return tasks
       .filter(t => t.dueTime) // has specific time, not just date
       .map(t => ({
         id: `cal-${t.id}`,
         title: t.title,
         time: formatTime(t.dueTime),
         isUpcoming: isWithinNextHour(t.dueTime),
         sourceTaskId: t.id
       }))
       .sort((a, b) => compareTime(a.time, b.time));
   }
   ```

4. **Parse tool results** into BriefingData structure:
   - Tool responses are speech-friendly strings, need to parse back to structured data
   - OR: Create internal versions of tools that return raw data (recommended)
   - Add `queryNotionRaw(toolName, input)` function that returns parsed Notion results

5. **buildCheckInData(type: 'midday' | 'evening')** - for check-ins (used in Plan 02)

6. **buildStreakSummary(habits)** - Creates speech-friendly habit summary:
   - "You're 4/7 on meditation this week"
   - "3 habits on track, 1 needs attention"

Create `src/lib/jarvis/executive/BriefingFlow.ts`:

1. **BriefingFlow class** following 05-RESEARCH.md pattern:
   - Constructor takes VoicePipeline instance
   - State: currentSection, data, skippedSections

2. **start()** method:
   - Fetch data via buildMorningBriefing()
   - Present outline: "Good morning. Today we'll cover tasks, calendar, bills, and habits. Ready to begin?"
   - Wait for user confirmation (voice or tap)

3. **advanceToNext()** method:
   - Move to next non-skipped, non-empty section
   - Call presentSection()

4. **skipCurrentSection()** method:
   - Add to skippedSections
   - Advance to next

5. **presentSection(section)** method:
   - Generate speech for each section type
   - Tasks: "{N} tasks today. {titles}. Plus {M} overdue."
   - Bills: "{N} bills due this week, ${total} total." OR "No bills due this week."
   - Habits: "{streakSummary}"
   - Calendar: "{N} events today." OR "Clear calendar today."
   - After each: "Any questions, or shall we continue?"

6. **handleUserResponse(response)** method:
   - Parse "skip", "next", "continue", "questions about X"
   - Route to appropriate action

7. **Integration with VoicePipeline:**
   - BriefingFlow calls `voicePipeline.speak()` (need to expose this method)
   - Listen for user responses via existing pipeline

NOTE: Per CONTEXT.md - Task detail level: just the title (no context or goal links during briefing).
  </action>
  <verify>
TypeScript compiles:
```bash
npx tsc --noEmit src/lib/jarvis/executive/BriefingBuilder.ts src/lib/jarvis/executive/BriefingFlow.ts
```
  </verify>
  <done>BriefingBuilder aggregates Notion data (including derived calendar events), BriefingFlow delivers section-by-section walkthrough</done>
</task>

<task type="auto">
  <name>Task 3: Wire briefing to JarvisOrb and add speak method to VoicePipeline</name>
  <files>
    - src/lib/jarvis/voice/VoicePipeline.ts
    - src/lib/jarvis/stores/jarvisStore.ts
    - src/components/jarvis/JarvisOrb.tsx
    - src/app/jarvis/page.tsx
  </files>
  <action>
**Update VoicePipeline.ts:**

1. Add public `speak(text: string)` method:
```typescript
async speak(text: string): Promise<void> {
  this.setState('speaking');
  this.tts.speak(text);
  // TTS callbacks handle state transitions
}
```

2. Add `setOnSpeechComplete(callback)` for BriefingFlow to know when to prompt for response.

**Update jarvisStore.ts:**

1. Add briefing state:
```typescript
// Briefing state
isBriefingActive: false,
currentBriefingSection: null as BriefingSection | null,
briefingData: null as BriefingData | null,

// Actions
setIsBriefingActive: (active: boolean) => set({ isBriefingActive: active }),
setCurrentBriefingSection: (section: BriefingSection | null) => set({ currentBriefingSection: section }),
setBriefingData: (data: BriefingData | null) => set({ briefingData: data }),
```

**Update JarvisOrb.tsx:**

1. Make orb the tap target (per CONTEXT.md: "Tap the orb to activate audio"):
   - Add onClick handler to orb container
   - On tap: if idle, start listening (startListening from VoicePipeline)
   - On tap: if speaking, barge-in
   - Visual feedback: subtle pulse on tap

2. Remove dependency on separate PushToTalk button for basic activation (button can remain for desktop):
```typescript
<div
  onClick={handleOrbTap}
  className="cursor-pointer"
  role="button"
  aria-label="Tap to speak"
>
  {/* Orb canvas */}
</div>
```

**Update src/app/jarvis/page.tsx:**

1. Initialize Scheduler on mount:
```typescript
useEffect(() => {
  const scheduler = getScheduler(handleScheduledEvent);
  scheduler.start();
  return () => scheduler.stop();
}, []);
```

2. Handle scheduled events:
```typescript
function handleScheduledEvent(event: ScheduledEvent) {
  if (event.type === 'morning_briefing') {
    startMorningBriefing();
  }
  // midday/evening handled in Plan 02
}
```

3. Add manual briefing trigger (voice command "start my briefing" or button):
```typescript
async function startMorningBriefing() {
  const pipeline = voicePipelineRef.current;
  const flow = new BriefingFlow(pipeline);
  await flow.start();
}
```

4. Add simple "Start Briefing" button for testing (can be hidden later):
```typescript
<button onClick={startMorningBriefing}>Start Briefing</button>
```
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Start dev server: `npm run dev`
3. Navigate to /jarvis
4. Click "Start Briefing" button
5. Jarvis speaks outline: "Good morning. Today we'll cover..."
  </verify>
  <done>Morning briefing can be triggered manually or by scheduler, orb is tappable</done>
</task>

</tasks>

<verification>
1. `npm install date-fns` completes without errors
2. TypeScript compiles: `npx tsc --noEmit`
3. Dev server starts: `npm run dev`
4. Navigate to /jarvis, click "Start Briefing"
5. Jarvis speaks morning briefing outline
6. User can say "continue" or tap orb to advance
7. Each section presents relevant data from Notion
8. Empty sections mentioned briefly ("No bills due this week. Moving to habits...")
9. Briefing completes with "Ready to start the day?"
</verification>

<success_criteria>
- Scheduler persists schedule to localStorage
- BriefingBuilder fetches all data in parallel from Notion using confirmed Phase 4 tools
- Calendar events derived from tasks with due times (no separate calendar tool needed)
- BriefingFlow presents outline-first, section-by-section walkthrough
- User can skip sections or ask questions
- Orb responds to tap for voice activation
- Morning briefing includes tasks, bills, habits, and goals
</success_criteria>

<output>
After completion, create `jarvis/.planning/phases/05-executive-function-core/05-01-SUMMARY.md`
</output>
