---
phase: 01-audio-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/jarvis/page.tsx
  - src/app/jarvis/layout.tsx
  - src/lib/jarvis/types.ts
  - src/lib/jarvis/stores/jarvisStore.ts
autonomous: true

must_haves:
  truths:
    - "Jarvis route /jarvis loads in browser without errors"
    - "Mobile users see responsive layout that fits their screen"
    - "Orb state types are defined and usable by other modules"
  artifacts:
    - path: "src/app/jarvis/page.tsx"
      provides: "Jarvis main page component"
      min_lines: 30
    - path: "src/app/jarvis/layout.tsx"
      provides: "Jarvis layout with mobile-first viewport"
      min_lines: 10
    - path: "src/lib/jarvis/types.ts"
      provides: "JarvisState, OrbState type definitions"
      exports: ["JarvisState", "OrbState"]
    - path: "src/lib/jarvis/stores/jarvisStore.ts"
      provides: "Zustand store for Jarvis state management"
      exports: ["useJarvisStore"]
  key_links:
    - from: "src/app/jarvis/page.tsx"
      to: "src/lib/jarvis/stores/jarvisStore.ts"
      via: "useJarvisStore import"
      pattern: "useJarvisStore"
---

<objective>
Set up Jarvis application infrastructure within Ethereal Flame Studio.

Purpose: Create the foundation for Jarvis voice assistant - routing, types, state management, and responsive layout. This establishes the project structure that all subsequent plans build upon.

Output: Working /jarvis route with mobile-responsive layout and Zustand store for state management.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns to follow
@src/lib/stores/visualStore.ts
@src/app/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Jarvis type definitions</name>
  <files>src/lib/jarvis/types.ts</files>
  <action>
Create TypeScript types for Jarvis state management:

```typescript
// Orb visual states - determines animation and color
export type OrbState = 'idle' | 'listening' | 'thinking' | 'speaking';

// Default state colors (cool -> warm progression)
// User can customize these in future settings phase
export const DEFAULT_STATE_COLORS: Record<OrbState, [number, number, number]> = {
  idle: [0.2, 0.4, 1.0],      // Blue
  listening: [0.2, 0.8, 0.9], // Cyan
  thinking: [1.0, 0.7, 0.2],  // Amber
  speaking: [1.0, 0.5, 0.2],  // Warm orange
};

// State transition timing (ms) - can vary with emotional intensity
export interface TransitionConfig {
  duration: number;        // Base transition duration
  minDuration: number;     // Fastest (urgent)
  maxDuration: number;     // Slowest (calm)
}

export const DEFAULT_TRANSITIONS: TransitionConfig = {
  duration: 350,
  minDuration: 200,
  maxDuration: 500,
};

// Main Jarvis state interface
export interface JarvisState {
  // Current orb state
  orbState: OrbState;

  // Audio capture state
  isAudioPermissionGranted: boolean;
  isCapturing: boolean;
  audioLevel: number; // 0-1 normalized amplitude

  // Importance/intensity (affects both visual intensity and transition speed)
  // 0 = calm/routine, 1 = urgent/important
  importance: number;

  // State colors (user-customizable later)
  stateColors: Record<OrbState, [number, number, number]>;
}

// Store actions
export interface JarvisActions {
  setOrbState: (state: OrbState) => void;
  setAudioPermissionGranted: (granted: boolean) => void;
  setIsCapturing: (capturing: boolean) => void;
  setAudioLevel: (level: number) => void;
  setImportance: (importance: number) => void;
  setStateColor: (state: OrbState, color: [number, number, number]) => void;
}
```

Export all types. These form the contract for Jarvis state management.
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit src/lib/jarvis/types.ts`</verify>
  <done>OrbState, JarvisState, JarvisActions types defined with default colors and transitions</done>
</task>

<task type="auto">
  <name>Task 2: Create Jarvis Zustand store</name>
  <files>src/lib/jarvis/stores/jarvisStore.ts</files>
  <action>
Create Zustand store following the pattern from visualStore.ts:

```typescript
import { create } from 'zustand';
import {
  JarvisState,
  JarvisActions,
  OrbState,
  DEFAULT_STATE_COLORS
} from '../types';

type JarvisStore = JarvisState & JarvisActions;

export const useJarvisStore = create<JarvisStore>((set) => ({
  // Initial state
  orbState: 'idle',
  isAudioPermissionGranted: false,
  isCapturing: false,
  audioLevel: 0,
  importance: 0,
  stateColors: DEFAULT_STATE_COLORS,

  // Actions
  setOrbState: (orbState) => set({ orbState }),
  setAudioPermissionGranted: (granted) => set({ isAudioPermissionGranted: granted }),
  setIsCapturing: (capturing) => set({ isCapturing: capturing }),
  setAudioLevel: (level) => set({ audioLevel: Math.max(0, Math.min(1, level)) }),
  setImportance: (importance) => set({ importance: Math.max(0, Math.min(1, importance)) }),
  setStateColor: (state, color) => set((s) => ({
    stateColors: { ...s.stateColors, [state]: color }
  })),
}));
```

Keep it simple - no persistence needed yet. Audio level is clamped 0-1.
  </action>
  <verify>Import and call useJarvisStore() in a test file without errors</verify>
  <done>useJarvisStore exported with all state and actions, follows existing zustand patterns</done>
</task>

<task type="auto">
  <name>Task 3: Create Jarvis page and layout</name>
  <files>src/app/jarvis/page.tsx, src/app/jarvis/layout.tsx</files>
  <action>
Create layout.tsx with mobile-first responsive design:

```typescript
// src/app/jarvis/layout.tsx
import type { Metadata, Viewport } from 'next';

export const metadata: Metadata = {
  title: 'Jarvis',
  description: 'Your omnipresent guide voice',
};

export const viewport: Viewport = {
  width: 'device-width',
  initialScale: 1,
  maximumScale: 1,
  userScalable: false,
};

export default function JarvisLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="h-dvh w-full overflow-hidden bg-black">
      {children}
    </div>
  );
}
```

Create page.tsx as placeholder shell:

```typescript
// src/app/jarvis/page.tsx
'use client';

import { useJarvisStore } from '@/lib/jarvis/stores/jarvisStore';

export default function JarvisPage() {
  const orbState = useJarvisStore((s) => s.orbState);

  return (
    <main className="flex flex-col items-center justify-center h-full w-full">
      {/* Orb container - will be replaced with actual orb in Plan 02 */}
      <div className="flex-1 flex items-center justify-center w-full">
        <div className="w-32 h-32 rounded-full bg-blue-500/30 animate-pulse" />
      </div>

      {/* Controls area - will be replaced with push-to-talk in Plan 03 */}
      <div className="pb-8 text-center">
        <p className="text-white/50 text-sm">
          State: {orbState}
        </p>
      </div>
    </main>
  );
}
```

Use `h-dvh` for dynamic viewport height (handles mobile browser chrome).
Placeholder elements show structure for subsequent plans.
  </action>
  <verify>Navigate to http://localhost:3000/jarvis - page loads with placeholder orb and state text</verify>
  <done>Jarvis route accessible, mobile-responsive layout, store wired up</done>
</task>

</tasks>

<verification>
1. `npm run dev` starts without errors
2. Navigate to http://localhost:3000/jarvis
3. Page shows placeholder orb circle and "State: idle" text
4. Resize to mobile viewport - layout remains centered and full-height
5. No TypeScript errors in src/lib/jarvis/
</verification>

<success_criteria>
- /jarvis route loads in browser
- Zustand store manages orb state
- Types defined for all Jarvis state
- Layout is mobile-responsive (h-dvh, overflow-hidden)
- Placeholder UI shows structure for subsequent plans
</success_criteria>

<output>
After completion, create `.planning/phases/01-audio-foundation/01-01-SUMMARY.md`
</output>
