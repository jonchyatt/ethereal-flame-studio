---
phase: 01-audio-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/components/jarvis/JarvisOrb.tsx
  - src/components/jarvis/OrbStateManager.tsx
  - src/app/jarvis/page.tsx
  - src/lib/jarvis/types.ts
autonomous: true

must_haves:
  truths:
    - "Orb displays on screen with distinct visual appearance per state"
    - "Orb color transitions smoothly between states (not instant jump)"
    - "Idle state shows slow drift motion, not frozen"
    - "Listening state draws particles inward while maintaining visible motion"
    - "Thinking state shows gentle pulse and swirl"
    - "Speaking state animates reactively (will connect to audio in Plan 03)"
  artifacts:
    - path: "src/components/jarvis/JarvisOrb.tsx"
      provides: "State-aware orb visualization component"
      min_lines: 100
    - path: "src/components/jarvis/OrbStateManager.tsx"
      provides: "State transition and animation controller"
      min_lines: 50
  key_links:
    - from: "src/components/jarvis/JarvisOrb.tsx"
      to: "src/lib/jarvis/stores/jarvisStore.ts"
      via: "useJarvisStore for orbState and stateColors"
      pattern: "useJarvisStore"
    - from: "src/app/jarvis/page.tsx"
      to: "src/components/jarvis/JarvisOrb.tsx"
      via: "JarvisOrb component import"
      pattern: "<JarvisOrb"
---

<objective>
Integrate Ethereal Flame orb as Jarvis's visual avatar with state-driven animations.

Purpose: Create a responsive, state-aware orb that provides visual feedback for Jarvis's current mode (idle, listening, thinking, speaking). The orb serves as Jarvis's "face" - the primary way users understand what Jarvis is doing.

Output: JarvisOrb component that smoothly transitions between visual states with appropriate animations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing orb implementation to adapt
@src/components/canvas/ParticleSystem.tsx
@src/components/canvas/ParticleLayer.tsx
@src/lib/stores/visualStore.ts

# Jarvis types and store from Plan 01
@src/lib/jarvis/types.ts
@src/lib/jarvis/stores/jarvisStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OrbStateManager for animation control</name>
  <files>src/components/jarvis/OrbStateManager.tsx</files>
  <action>
Create a component that manages state transitions and computes animation parameters:

```typescript
'use client';

import { useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import { useJarvisStore } from '@/lib/jarvis/stores/jarvisStore';
import { OrbState, DEFAULT_TRANSITIONS } from '@/lib/jarvis/types';

// Animation parameters per state
interface StateAnimation {
  // Particle behavior
  particleSpread: number;      // 0 = tight core, 1 = dispersed cloud
  driftSpeed: number;          // Movement speed multiplier
  pulseAmplitude: number;      // 0 = no pulse, 1 = strong pulse
  swirlSpeed: number;          // Rotation/swirl rate

  // Visual intensity
  baseIntensity: number;       // 1.7 = Ethereal Flame default
  audioReactivity: number;     // How much audio affects visuals
}

const STATE_ANIMATIONS: Record<OrbState, StateAnimation> = {
  idle: {
    particleSpread: 0.7,       // Particles dispersed as cloud
    driftSpeed: 0.3,           // Slow drift
    pulseAmplitude: 0,
    swirlSpeed: 0.1,
    baseIntensity: 1.7,
    audioReactivity: 0,
  },
  listening: {
    particleSpread: 0.3,       // Particles draw inward
    driftSpeed: 0.5,           // Keep motion visible (NOT frozen)
    pulseAmplitude: 0.1,
    swirlSpeed: 0.2,
    baseIntensity: 1.8,
    audioReactivity: 0.5,      // Subtle audio response
  },
  thinking: {
    particleSpread: 0.5,
    driftSpeed: 0.4,
    pulseAmplitude: 0.3,       // Gentle pulse
    swirlSpeed: 0.5,           // Swirl motion
    baseIntensity: 1.9,
    audioReactivity: 0,
  },
  speaking: {
    particleSpread: 0.8,       // Particles expand outward
    driftSpeed: 0.6,
    pulseAmplitude: 0.2,
    swirlSpeed: 0.3,
    baseIntensity: 2.0,
    audioReactivity: 1.0,      // Full audio reactivity
  },
};

export interface OrbAnimationState {
  color: [number, number, number];
  particleSpread: number;
  driftSpeed: number;
  pulseAmplitude: number;
  swirlSpeed: number;
  baseIntensity: number;
  audioReactivity: number;
  transitionProgress: number;
}

interface Props {
  onAnimationUpdate: (state: OrbAnimationState) => void;
}

export function OrbStateManager({ onAnimationUpdate }: Props) {
  const orbState = useJarvisStore((s) => s.orbState);
  const stateColors = useJarvisStore((s) => s.stateColors);
  const importance = useJarvisStore((s) => s.importance);
  const audioLevel = useJarvisStore((s) => s.audioLevel);

  // Animation state refs (no re-renders)
  const currentState = useRef<OrbAnimationState>({
    color: stateColors.idle,
    ...STATE_ANIMATIONS.idle,
    transitionProgress: 1,
  });
  const targetState = useRef<OrbState>('idle');
  const transitionStartTime = useRef(0);

  useFrame(({ clock }) => {
    const time = clock.getElapsedTime();
    const current = currentState.current;

    // Check for state change
    if (orbState !== targetState.current) {
      targetState.current = orbState;
      transitionStartTime.current = time;
    }

    // Calculate transition duration based on importance
    // Higher importance = faster transitions (more urgent)
    const { minDuration, maxDuration } = DEFAULT_TRANSITIONS;
    const transitionDuration = (maxDuration - (maxDuration - minDuration) * importance) / 1000;

    // Calculate transition progress
    const elapsed = time - transitionStartTime.current;
    const progress = Math.min(1, elapsed / transitionDuration);

    // Smooth easing (ease-in-out)
    const eased = progress < 0.5
      ? 2 * progress * progress
      : 1 - Math.pow(-2 * progress + 2, 2) / 2;

    // Get target animation params
    const targetAnim = STATE_ANIMATIONS[orbState];
    const targetColor = stateColors[orbState];

    // Lerp all animation values
    current.color = [
      current.color[0] + (targetColor[0] - current.color[0]) * eased,
      current.color[1] + (targetColor[1] - current.color[1]) * eased,
      current.color[2] + (targetColor[2] - current.color[2]) * eased,
    ];
    current.particleSpread += (targetAnim.particleSpread - current.particleSpread) * eased;
    current.driftSpeed += (targetAnim.driftSpeed - current.driftSpeed) * eased;
    current.pulseAmplitude += (targetAnim.pulseAmplitude - current.pulseAmplitude) * eased;
    current.swirlSpeed += (targetAnim.swirlSpeed - current.swirlSpeed) * eased;
    current.baseIntensity += (targetAnim.baseIntensity - current.baseIntensity) * eased;
    current.audioReactivity += (targetAnim.audioReactivity - current.audioReactivity) * eased;
    current.transitionProgress = progress;

    // Apply importance multiplier to intensity
    // Higher importance = more intense visuals
    const intensityBoost = 1 + importance * 0.3;
    const finalIntensity = current.baseIntensity * intensityBoost;

    // Apply audio reactivity boost based on importance
    const reactivityBoost = 1 + importance * 0.5;
    const finalReactivity = current.audioReactivity * reactivityBoost;

    onAnimationUpdate({
      ...current,
      baseIntensity: finalIntensity,
      audioReactivity: finalReactivity,
    });
  });

  return null; // Pure logic component
}
```

Key behaviors:
- Transition speed varies with importance (200-500ms)
- Importance boosts both intensity AND audio reactivity
- Smooth easing on all transitions
- No frozen states - all states have visible motion
  </action>
  <verify>Component compiles without TypeScript errors</verify>
  <done>OrbStateManager handles state transitions with importance-aware timing and intensity</done>
</task>

<task type="auto">
  <name>Task 2: Create JarvisOrb visualization component</name>
  <files>src/components/jarvis/JarvisOrb.tsx</files>
  <action>
Create the main orb component that renders state-aware particles:

```typescript
'use client';

import { useRef, useState, useCallback } from 'react';
import { Canvas, useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { OrbStateManager, OrbAnimationState } from './OrbStateManager';
import { useJarvisStore } from '@/lib/jarvis/stores/jarvisStore';

// Simplified particle layer for Jarvis orb
function JarvisParticles({ animState }: { animState: OrbAnimationState }) {
  const pointsRef = useRef<THREE.Points>(null);
  const particleCount = 200; // Smaller count for mobile performance

  // Initialize particles
  const { positions, velocities, birthTimes } = useRef({
    positions: new Float32Array(particleCount * 3),
    velocities: new Float32Array(particleCount * 3),
    birthTimes: new Float32Array(particleCount),
  }).current;

  // Initialize on mount
  useRef(() => {
    for (let i = 0; i < particleCount; i++) {
      // Random spherical position
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const r = 0.3 + Math.random() * 0.2;

      positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
      positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
      positions[i * 3 + 2] = r * Math.cos(phi);

      // Random velocity
      velocities[i * 3] = (Math.random() - 0.5) * 0.02;
      velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.02;
      velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.02;

      birthTimes[i] = Math.random() * 5; // Stagger
    }
  }).current;

  const audioLevel = useJarvisStore((s) => s.audioLevel);

  useFrame(({ clock }) => {
    if (!pointsRef.current) return;
    const geometry = pointsRef.current.geometry;
    const posAttr = geometry.attributes.position as THREE.BufferAttribute;
    const time = clock.getElapsedTime();

    const { particleSpread, driftSpeed, pulseAmplitude, swirlSpeed, audioReactivity } = animState;

    for (let i = 0; i < particleCount; i++) {
      let x = positions[i * 3];
      let y = positions[i * 3 + 1];
      let z = positions[i * 3 + 2];

      // Apply drift motion
      x += velocities[i * 3] * driftSpeed;
      y += velocities[i * 3 + 1] * driftSpeed;
      z += velocities[i * 3 + 2] * driftSpeed;

      // Apply swirl
      const angle = swirlSpeed * 0.01;
      const newX = x * Math.cos(angle) - z * Math.sin(angle);
      const newZ = x * Math.sin(angle) + z * Math.cos(angle);
      x = newX;
      z = newZ;

      // Apply pulse
      const pulse = 1 + pulseAmplitude * Math.sin(time * 3 + i * 0.1);

      // Apply spread (contract/expand based on state)
      const dist = Math.sqrt(x * x + y * y + z * z);
      const targetDist = particleSpread * 0.5;
      const spreadFactor = dist > 0 ? (targetDist / dist) * 0.02 + 0.98 : 1;

      // Apply audio reactivity
      const audioScale = 1 + audioLevel * audioReactivity * 0.3;

      x *= spreadFactor * pulse * audioScale;
      y *= spreadFactor * pulse * audioScale;
      z *= spreadFactor * pulse * audioScale;

      // Boundary check - respawn if too far
      if (dist > 1.5) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = 0.1 + Math.random() * 0.1;
        x = r * Math.sin(phi) * Math.cos(theta);
        y = r * Math.sin(phi) * Math.sin(theta);
        z = r * Math.cos(phi);
      }

      positions[i * 3] = x;
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = z;

      posAttr.setXYZ(i, x, y, z);
    }

    posAttr.needsUpdate = true;
  });

  // Create color from animState
  const color = new THREE.Color(animState.color[0], animState.color[1], animState.color[2]);

  return (
    <points ref={pointsRef}>
      <bufferGeometry>
        <bufferAttribute
          attach="attributes-position"
          count={particleCount}
          array={positions}
          itemSize={3}
        />
      </bufferGeometry>
      <pointsMaterial
        size={0.08}
        color={color}
        transparent
        opacity={0.8}
        blending={THREE.AdditiveBlending}
        depthWrite={false}
      />
    </points>
  );
}

// Inner glow sphere
function GlowCore({ animState }: { animState: OrbAnimationState }) {
  const meshRef = useRef<THREE.Mesh>(null);
  const audioLevel = useJarvisStore((s) => s.audioLevel);

  useFrame(({ clock }) => {
    if (!meshRef.current) return;
    const time = clock.getElapsedTime();

    // Pulse scale
    const { pulseAmplitude, audioReactivity } = animState;
    const pulse = 1 + pulseAmplitude * Math.sin(time * 2) * 0.1;
    const audioScale = 1 + audioLevel * audioReactivity * 0.2;
    const scale = pulse * audioScale;

    meshRef.current.scale.setScalar(scale);
  });

  const color = new THREE.Color(animState.color[0], animState.color[1], animState.color[2]);

  return (
    <mesh ref={meshRef}>
      <sphereGeometry args={[0.15, 32, 32]} />
      <meshBasicMaterial
        color={color}
        transparent
        opacity={0.3}
      />
    </mesh>
  );
}

// Main scene with particles and glow
function JarvisOrbScene() {
  const [animState, setAnimState] = useState<OrbAnimationState>({
    color: [0.2, 0.4, 1.0],
    particleSpread: 0.7,
    driftSpeed: 0.3,
    pulseAmplitude: 0,
    swirlSpeed: 0.1,
    baseIntensity: 1.7,
    audioReactivity: 0,
    transitionProgress: 1,
  });

  const handleAnimationUpdate = useCallback((state: OrbAnimationState) => {
    setAnimState(state);
  }, []);

  return (
    <>
      <OrbStateManager onAnimationUpdate={handleAnimationUpdate} />
      <ambientLight intensity={0.2} />
      <GlowCore animState={animState} />
      <JarvisParticles animState={animState} />
    </>
  );
}

// Exported component with Canvas wrapper
export function JarvisOrb() {
  return (
    <Canvas
      camera={{ position: [0, 0, 2], fov: 50 }}
      dpr={[1, 2]}
      gl={{ antialias: true, alpha: true }}
      style={{ background: 'transparent' }}
    >
      <JarvisOrbScene />
    </Canvas>
  );
}
```

Key features:
- Simplified particle system (200 particles for mobile)
- State-driven color, spread, pulse, swirl
- Audio-reactive scaling when audioReactivity > 0
- Additive blending for ethereal glow effect
- Transparent background (composites over page)
  </action>
  <verify>JarvisOrb renders without WebGL errors in browser</verify>
  <done>JarvisOrb component renders state-aware particle orb with smooth transitions</done>
</task>

<task type="auto">
  <name>Task 3: Integrate orb into Jarvis page with state testing</name>
  <files>src/app/jarvis/page.tsx</files>
  <action>
Update Jarvis page to use the real orb and add state testing buttons:

```typescript
'use client';

import { JarvisOrb } from '@/components/jarvis/JarvisOrb';
import { useJarvisStore } from '@/lib/jarvis/stores/jarvisStore';
import { OrbState } from '@/lib/jarvis/types';

export default function JarvisPage() {
  const orbState = useJarvisStore((s) => s.orbState);
  const setOrbState = useJarvisStore((s) => s.setOrbState);
  const importance = useJarvisStore((s) => s.importance);
  const setImportance = useJarvisStore((s) => s.setImportance);

  const states: OrbState[] = ['idle', 'listening', 'thinking', 'speaking'];

  return (
    <main className="flex flex-col h-full w-full">
      {/* Orb container - takes majority of screen */}
      <div className="flex-1 relative">
        <JarvisOrb />
      </div>

      {/* Debug controls - will be replaced by push-to-talk in Plan 03 */}
      <div className="pb-8 px-4 space-y-4">
        {/* State indicator */}
        <p className="text-white/70 text-center text-sm">
          State: <span className="font-medium text-white">{orbState}</span>
        </p>

        {/* State toggle buttons */}
        <div className="flex justify-center gap-2">
          {states.map((state) => (
            <button
              key={state}
              onClick={() => setOrbState(state)}
              className={`
                px-3 py-2 rounded-lg text-sm font-medium
                transition-colors
                ${orbState === state
                  ? 'bg-white text-black'
                  : 'bg-white/10 text-white/70 hover:bg-white/20'
                }
              `}
            >
              {state}
            </button>
          ))}
        </div>

        {/* Importance slider */}
        <div className="flex items-center justify-center gap-4">
          <span className="text-white/50 text-sm">Calm</span>
          <input
            type="range"
            min="0"
            max="1"
            step="0.1"
            value={importance}
            onChange={(e) => setImportance(parseFloat(e.target.value))}
            className="w-32"
          />
          <span className="text-white/50 text-sm">Urgent</span>
        </div>
      </div>
    </main>
  );
}
```

This provides:
- Full-screen orb visualization
- State toggle buttons to test each state
- Importance slider to test transition speed/intensity
- All debug controls will be replaced by push-to-talk in Plan 03
  </action>
  <verify>
1. Navigate to /jarvis
2. Click each state button - orb color and animation changes
3. Adjust importance slider - transitions become faster, orb more intense
4. No console errors
  </verify>
  <done>Jarvis page shows orb with state testing controls, all four states visually distinct</done>
</task>

</tasks>

<verification>
1. `npm run dev` starts without errors
2. Navigate to http://localhost:3000/jarvis
3. Orb displays with blue color (idle state)
4. Click "listening" - orb turns cyan, particles contract inward
5. Click "thinking" - orb turns amber, shows pulse/swirl
6. Click "speaking" - orb turns orange, particles expand
7. Adjust importance slider - higher values = faster transitions, more intense glow
8. Orb never freezes - all states show continuous motion
9. Test on mobile viewport - orb remains centered and responsive
</verification>

<success_criteria>
- Orb displays with state-specific colors (blue/cyan/amber/orange)
- State transitions are smooth (not instant color jumps)
- Each state has distinct animation behavior
- Importance affects transition speed and visual intensity
- No frozen/static states - continuous motion in all modes
- Works on mobile viewports
</success_criteria>

<output>
After completion, create `.planning/phases/01-audio-foundation/01-02-SUMMARY.md`
</output>
