---
phase: 07-database-foundation
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/lib/jarvis/memory/schema.ts
  - src/lib/jarvis/memory/db.ts
  - drizzle/0001_initial.sql
autonomous: true

must_haves:
  truths:
    - "Database schema defines three tables: memory_entries, sessions, daily_logs"
    - "Schema supports deduplication via content_hash"
    - "Database client is singleton pattern for serverless"
    - "Schema can be pushed to local database"
  artifacts:
    - path: "src/lib/jarvis/memory/schema.ts"
      provides: "Table definitions for memory system"
      exports: ["memoryEntries", "sessions", "dailyLogs"]
    - path: "src/lib/jarvis/memory/db.ts"
      provides: "Database client singleton"
      exports: ["db"]
    - path: "drizzle/0001_initial.sql"
      provides: "Generated migration"
      contains: "CREATE TABLE"
  key_links:
    - from: "src/lib/jarvis/memory/db.ts"
      to: "src/lib/jarvis/memory/schema.ts"
      via: "import * as schema"
      pattern: "import.*schema"
    - from: "src/lib/jarvis/memory/db.ts"
      to: "@libsql/client"
      via: "createClient"
      pattern: "createClient"
---

<objective>
Create the Drizzle schema for memory_entries, sessions, and daily_logs tables, plus the singleton database client.

Purpose: Define the persistent storage layer that Phase 8+ will use for memory operations.
Output: Type-safe schema definitions, working database client, initial migration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@jarvis/.planning/PROJECT.md
@jarvis/.planning/ROADMAP.md
@jarvis/.planning/phases/07-database-foundation/07-CONTEXT.md
@jarvis/.planning/phases/07-database-foundation/07-RESEARCH.md
@jarvis/.planning/phases/07-database-foundation/07-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Drizzle schema with three tables</name>
  <files>src/lib/jarvis/memory/schema.ts</files>
  <action>
    Create directory: src/lib/jarvis/memory/

    Create schema.ts following the CONTEXT.md locked decisions:

    ```typescript
    /**
     * Jarvis Memory System - Database Schema
     *
     * Three tables:
     * - memory_entries: Contextual facts for briefings/nudges/check-ins
     * - sessions: Conversation session tracking
     * - daily_logs: Significant events within sessions
     */

    import { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';

    /**
     * Memory entries - Facts that help Jarvis do its job
     *
     * Categories: preference, fact, pattern
     * Sources: user_explicit (user said "remember X"), jarvis_inferred
     *
     * Deduplication: content_hash enables silent updates when same fact restated
     */
    export const memoryEntries = sqliteTable('memory_entries', {
      id: integer('id').primaryKey({ autoIncrement: true }),
      content: text('content').notNull(),
      contentHash: text('content_hash').unique(), // SHA-256 of normalized content
      category: text('category').notNull(), // 'preference' | 'fact' | 'pattern'
      source: text('source').notNull(), // 'user_explicit' | 'jarvis_inferred'
      createdAt: text('created_at').notNull().$defaultFn(() => new Date().toISOString()),
      lastAccessed: text('last_accessed'),
    });

    /**
     * Sessions - Conversation session boundaries
     *
     * Session ends when: 30+ min inactivity, explicit close, browser close
     * New session: User returns after gap, morning briefing, explicit greeting after closure
     */
    export const sessions = sqliteTable('sessions', {
      id: integer('id').primaryKey({ autoIncrement: true }),
      startedAt: text('started_at').notNull().$defaultFn(() => new Date().toISOString()),
      endedAt: text('ended_at'),
      endTrigger: text('end_trigger'), // 'timeout' | 'explicit' | 'browser_close'
      summary: text('summary'), // Optional, for weekly review
    });

    /**
     * Daily logs - Significant events within sessions (not verbatim transcripts)
     *
     * Event types per CONTEXT.md:
     * - session_start: timestamp, source
     * - session_end: timestamp, duration, trigger
     * - tool_invocation: tool name, success/failure
     * - topic_change: new topic label
     * - user_state: sentiment expressions
     */
    export const dailyLogs = sqliteTable('daily_logs', {
      id: integer('id').primaryKey({ autoIncrement: true }),
      sessionId: integer('session_id').references(() => sessions.id),
      eventType: text('event_type').notNull(),
      eventData: text('event_data'), // JSON string
      timestamp: text('timestamp').notNull().$defaultFn(() => new Date().toISOString()),
    });

    // Type exports for use in queries
    export type MemoryEntry = typeof memoryEntries.$inferSelect;
    export type NewMemoryEntry = typeof memoryEntries.$inferInsert;
    export type Session = typeof sessions.$inferSelect;
    export type NewSession = typeof sessions.$inferInsert;
    export type DailyLog = typeof dailyLogs.$inferSelect;
    export type NewDailyLog = typeof dailyLogs.$inferInsert;
    ```

    Key decisions from CONTEXT.md:
    - content_hash for deduplication (silent timestamp update on duplicate)
    - TEXT columns for timestamps (ISO 8601 strings, not Date objects)
    - eventData as JSON string (SQLite has no native JSON type)
    - sessionId foreign key on daily_logs
  </action>
  <verify>
    Run: `cat src/lib/jarvis/memory/schema.ts | grep "sqliteTable"`
    Should show three table definitions.

    Run: `npx tsc --noEmit src/lib/jarvis/memory/schema.ts 2>&1 || echo "Check for errors"`
    Should compile without TypeScript errors.
  </verify>
  <done>schema.ts exports memoryEntries, sessions, dailyLogs with correct column definitions</done>
</task>

<task type="auto">
  <name>Task 2: Create database client singleton</name>
  <files>src/lib/jarvis/memory/db.ts</files>
  <action>
    Create db.ts with singleton pattern (critical for serverless):

    ```typescript
    /**
     * Jarvis Memory System - Database Client
     *
     * Singleton pattern prevents connection exhaustion in serverless.
     * Uses @libsql/client for both local (turso dev) and production (Turso cloud).
     *
     * Environment:
     * - Development: DATABASE_URL=http://127.0.0.1:8080 (turso dev)
     * - Production: DATABASE_URL=libsql://jarvis-xxx.turso.io + DATABASE_AUTH_TOKEN
     */

    import { createClient } from '@libsql/client';
    import { drizzle } from 'drizzle-orm/libsql';
    import * as schema from './schema';

    // Validate environment
    if (!process.env.DATABASE_URL) {
      throw new Error(
        'DATABASE_URL not set. For local dev: http://127.0.0.1:8080 (run turso dev). ' +
        'For production: libsql://jarvis-xxx.turso.io'
      );
    }

    // Create libsql client (singleton)
    const client = createClient({
      url: process.env.DATABASE_URL,
      authToken: process.env.DATABASE_AUTH_TOKEN, // undefined OK for local dev
    });

    // Export typed Drizzle instance
    export const db = drizzle(client, { schema });

    // Re-export schema types for convenience
    export * from './schema';
    ```

    IMPORTANT anti-patterns from RESEARCH.md:
    - Do NOT use file: URLs (won't work with Next.js Turbopack)
    - Do NOT create new client per request (connection exhaustion)
    - Do NOT import from 'drizzle-orm/libsql' directly (Turbopack issues)
  </action>
  <verify>
    Run: `cat src/lib/jarvis/memory/db.ts | grep "createClient"`
    Should show import from @libsql/client.

    Run: `npx tsc --noEmit src/lib/jarvis/memory/db.ts 2>&1 || echo "Check for errors"`
    Should compile (may warn about env var, that's OK).
  </verify>
  <done>db.ts exports singleton db instance with schema types</done>
</task>

<task type="auto">
  <name>Task 3: Generate and push initial migration</name>
  <files>drizzle/0001_initial.sql</files>
  <action>
    This task requires turso dev running OR will document what user needs to do.

    1. Check if turso dev is running on port 8080
    2. If not, try to start it: `turso dev --db-file ./jarvis.db &`
    3. Generate migration: `npm run db:generate`
    4. Push schema to local database: `npm run db:push`
    5. Verify tables exist

    If turso CLI not available:
    - Generate migration anyway (doesn't require running server)
    - Document that user needs turso CLI to complete setup

    Expected migration file (drizzle/0001_*.sql) should contain:
    - CREATE TABLE memory_entries
    - CREATE TABLE sessions
    - CREATE TABLE daily_logs
    - CREATE UNIQUE INDEX on content_hash
  </action>
  <verify>
    Run: `ls drizzle/*.sql`
    Should show at least one SQL migration file.

    Run: `cat drizzle/*.sql | grep "CREATE TABLE"`
    Should show CREATE TABLE for all three tables.

    If turso dev available:
    Run: `npm run db:push` should succeed without errors.
  </verify>
  <done>Migration generated; schema pushed to local database (or documented for user)</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `src/lib/jarvis/memory/schema.ts` exports three tables
2. `src/lib/jarvis/memory/db.ts` exports `db` singleton
3. `drizzle/` contains generated migration SQL
4. TypeScript compiles without errors
</verification>

<success_criteria>
- Schema defines memory_entries, sessions, daily_logs with correct columns
- content_hash column enables deduplication
- Timestamps stored as ISO 8601 TEXT (not Date)
- Database client is singleton pattern
- Migration generated and (ideally) pushed to local DB
</success_criteria>

<output>
After completion, create `jarvis/.planning/phases/07-database-foundation/07-02-SUMMARY.md`
</output>
