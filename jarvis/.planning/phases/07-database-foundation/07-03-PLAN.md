---
phase: 07-database-foundation
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - src/lib/jarvis/memory/queries/memoryEntries.ts
  - src/lib/jarvis/memory/queries/sessions.ts
  - src/lib/jarvis/memory/queries/dailyLogs.ts
  - src/lib/jarvis/memory/index.ts
  - src/app/api/jarvis/session/route.ts
autonomous: true

must_haves:
  truths:
    - "Memory entries can be stored with hash-based deduplication"
    - "Sessions can be started and ended with proper triggers"
    - "Daily logs can be written to track significant events"
    - "API route enables session management from client"
    - "Persistence survives browser refresh"
  artifacts:
    - path: "src/lib/jarvis/memory/queries/memoryEntries.ts"
      provides: "CRUD for memory entries with dedup"
      exports: ["storeMemoryEntry", "getMemoryEntries", "updateLastAccessed"]
    - path: "src/lib/jarvis/memory/queries/sessions.ts"
      provides: "Session lifecycle management"
      exports: ["startSession", "endSession", "getActiveSession"]
    - path: "src/lib/jarvis/memory/queries/dailyLogs.ts"
      provides: "Event logging within sessions"
      exports: ["logEvent", "getSessionEvents"]
    - path: "src/lib/jarvis/memory/index.ts"
      provides: "MemoryService facade"
      exports: ["MemoryService"]
    - path: "src/app/api/jarvis/session/route.ts"
      provides: "Session API endpoints"
      exports: ["GET", "POST", "PATCH"]
  key_links:
    - from: "src/lib/jarvis/memory/index.ts"
      to: "src/lib/jarvis/memory/queries/*.ts"
      via: "imports"
      pattern: "from.*queries"
    - from: "src/app/api/jarvis/session/route.ts"
      to: "src/lib/jarvis/memory/index.ts"
      via: "MemoryService"
      pattern: "MemoryService"
    - from: "src/lib/jarvis/memory/queries/memoryEntries.ts"
      to: "crypto"
      via: "createHash for dedup"
      pattern: "createHash.*sha256"
---

<objective>
Create query functions for memory_entries, sessions, and daily_logs, plus API route for session management. Verify persistence across browser sessions.

Purpose: Complete the database foundation so MEM-01 (facts persist) and MEM-08 (log daily events) are satisfied at infrastructure level.
Output: Working query layer, API route, verified persistence.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@jarvis/.planning/PROJECT.md
@jarvis/.planning/ROADMAP.md
@jarvis/.planning/phases/07-database-foundation/07-CONTEXT.md
@jarvis/.planning/phases/07-database-foundation/07-RESEARCH.md
@jarvis/.planning/phases/07-database-foundation/07-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create query functions for all three tables</name>
  <files>
    src/lib/jarvis/memory/queries/memoryEntries.ts
    src/lib/jarvis/memory/queries/sessions.ts
    src/lib/jarvis/memory/queries/dailyLogs.ts
  </files>
  <action>
    Create queries directory: src/lib/jarvis/memory/queries/

    Create memoryEntries.ts with hash-based deduplication (per CONTEXT.md):
    ```typescript
    /**
     * Memory Entries Query Functions
     *
     * Hash-based deduplication: If identical fact exists, update last_accessed silently.
     * Never prompt user about duplicates per CONTEXT.md decision.
     */

    import { createHash } from 'crypto';
    import { eq, desc } from 'drizzle-orm';
    import { db, memoryEntries, type MemoryEntry, type NewMemoryEntry } from '../db';

    /**
     * Normalize content for consistent hashing
     */
    function normalizeContent(content: string): string {
      return content.trim().toLowerCase().replace(/\s+/g, ' ');
    }

    /**
     * Generate SHA-256 hash of normalized content
     */
    function hashContent(content: string): string {
      return createHash('sha256').update(normalizeContent(content)).digest('hex');
    }

    /**
     * Store a memory entry with deduplication
     * If identical content exists: updates last_accessed, returns existing
     * If new: inserts and returns new entry
     */
    export async function storeMemoryEntry(
      content: string,
      category: 'preference' | 'fact' | 'pattern',
      source: 'user_explicit' | 'jarvis_inferred'
    ): Promise<MemoryEntry> {
      const contentHash = hashContent(content);
      const now = new Date().toISOString();

      // Check for existing entry
      const existing = await db.select()
        .from(memoryEntries)
        .where(eq(memoryEntries.contentHash, contentHash))
        .get();

      if (existing) {
        // Silent dedup: update timestamp, return existing
        await db.update(memoryEntries)
          .set({ lastAccessed: now })
          .where(eq(memoryEntries.id, existing.id));
        return { ...existing, lastAccessed: now };
      }

      // Insert new entry
      const result = await db.insert(memoryEntries).values({
        content,
        contentHash,
        category,
        source,
        lastAccessed: now,
      }).returning().get();

      return result;
    }

    /**
     * Get all memory entries, most recently accessed first
     */
    export async function getMemoryEntries(limit = 50): Promise<MemoryEntry[]> {
      return db.select()
        .from(memoryEntries)
        .orderBy(desc(memoryEntries.lastAccessed))
        .limit(limit)
        .all();
    }

    /**
     * Update last_accessed timestamp for an entry
     */
    export async function updateLastAccessed(id: number): Promise<void> {
      await db.update(memoryEntries)
        .set({ lastAccessed: new Date().toISOString() })
        .where(eq(memoryEntries.id, id));
    }

    /**
     * Get entries by category
     */
    export async function getEntriesByCategory(
      category: 'preference' | 'fact' | 'pattern'
    ): Promise<MemoryEntry[]> {
      return db.select()
        .from(memoryEntries)
        .where(eq(memoryEntries.category, category))
        .orderBy(desc(memoryEntries.lastAccessed))
        .all();
    }
    ```

    Create sessions.ts for session lifecycle:
    ```typescript
    /**
     * Session Query Functions
     *
     * Session boundaries per CONTEXT.md:
     * - Ends: 30+ min inactivity, explicit close, browser close
     * - Starts: User returns after gap, morning briefing, explicit greeting
     */

    import { eq, isNull, desc, and } from 'drizzle-orm';
    import { db, sessions, type Session } from '../db';

    /**
     * Start a new session
     * @returns session ID
     */
    export async function startSession(): Promise<number> {
      const result = await db.insert(sessions).values({
        startedAt: new Date().toISOString(),
      }).returning({ id: sessions.id }).get();

      return result.id;
    }

    /**
     * End an active session
     */
    export async function endSession(
      sessionId: number,
      trigger: 'timeout' | 'explicit' | 'browser_close',
      summary?: string
    ): Promise<void> {
      await db.update(sessions)
        .set({
          endedAt: new Date().toISOString(),
          endTrigger: trigger,
          summary,
        })
        .where(eq(sessions.id, sessionId));
    }

    /**
     * Get the current active session (no endedAt)
     * Returns null if no active session
     */
    export async function getActiveSession(): Promise<Session | null> {
      const result = await db.select()
        .from(sessions)
        .where(isNull(sessions.endedAt))
        .orderBy(desc(sessions.startedAt))
        .get();

      return result ?? null;
    }

    /**
     * Get recent sessions
     */
    export async function getRecentSessions(limit = 10): Promise<Session[]> {
      return db.select()
        .from(sessions)
        .orderBy(desc(sessions.startedAt))
        .limit(limit)
        .all();
    }

    /**
     * Get or create active session
     * If active session exists, return it. Otherwise start new one.
     */
    export async function getOrCreateSession(): Promise<{ sessionId: number; isNew: boolean }> {
      const active = await getActiveSession();
      if (active) {
        return { sessionId: active.id, isNew: false };
      }
      const sessionId = await startSession();
      return { sessionId, isNew: true };
    }
    ```

    Create dailyLogs.ts for event logging:
    ```typescript
    /**
     * Daily Logs Query Functions
     *
     * Event types per CONTEXT.md:
     * - session_start: { source: 'morning_briefing' | 'user_initiated' | ... }
     * - session_end: { duration_minutes: number, trigger: string }
     * - tool_invocation: { tool: string, success: boolean, context?: string }
     * - topic_change: { topic: string }
     * - user_state: { sentiment: string }
     */

    import { eq, desc, and, gte } from 'drizzle-orm';
    import { db, dailyLogs, type DailyLog } from '../db';

    export type EventType =
      | 'session_start'
      | 'session_end'
      | 'tool_invocation'
      | 'topic_change'
      | 'user_state';

    /**
     * Log an event within a session
     */
    export async function logEvent(
      sessionId: number,
      eventType: EventType,
      eventData?: Record<string, unknown>
    ): Promise<DailyLog> {
      const result = await db.insert(dailyLogs).values({
        sessionId,
        eventType,
        eventData: eventData ? JSON.stringify(eventData) : null,
      }).returning().get();

      return result;
    }

    /**
     * Get all events for a session
     */
    export async function getSessionEvents(sessionId: number): Promise<DailyLog[]> {
      return db.select()
        .from(dailyLogs)
        .where(eq(dailyLogs.sessionId, sessionId))
        .orderBy(desc(dailyLogs.timestamp))
        .all();
    }

    /**
     * Get events from today
     */
    export async function getTodayEvents(): Promise<DailyLog[]> {
      const todayStart = new Date();
      todayStart.setHours(0, 0, 0, 0);

      return db.select()
        .from(dailyLogs)
        .where(gte(dailyLogs.timestamp, todayStart.toISOString()))
        .orderBy(desc(dailyLogs.timestamp))
        .all();
    }

    /**
     * Parse event data from JSON string
     */
    export function parseEventData<T = Record<string, unknown>>(
      log: DailyLog
    ): T | null {
      if (!log.eventData) return null;
      try {
        return JSON.parse(log.eventData) as T;
      } catch {
        return null;
      }
    }
    ```
  </action>
  <verify>
    Run: `ls src/lib/jarvis/memory/queries/`
    Should show memoryEntries.ts, sessions.ts, dailyLogs.ts

    Run: `npx tsc --noEmit src/lib/jarvis/memory/queries/*.ts 2>&1 || echo "Check errors"`
    Should compile without errors.
  </verify>
  <done>Three query files export CRUD functions for their respective tables</done>
</task>

<task type="auto">
  <name>Task 2: Create MemoryService facade and API route</name>
  <files>
    src/lib/jarvis/memory/index.ts
    src/app/api/jarvis/session/route.ts
  </files>
  <action>
    Create index.ts as the public facade:
    ```typescript
    /**
     * Jarvis Memory Service
     *
     * Facade over database queries for use throughout the application.
     * All memory operations go through this interface.
     */

    export { db } from './db';
    export * from './schema';

    // Query functions
    export {
      storeMemoryEntry,
      getMemoryEntries,
      updateLastAccessed,
      getEntriesByCategory,
    } from './queries/memoryEntries';

    export {
      startSession,
      endSession,
      getActiveSession,
      getRecentSessions,
      getOrCreateSession,
    } from './queries/sessions';

    export {
      logEvent,
      getSessionEvents,
      getTodayEvents,
      parseEventData,
      type EventType,
    } from './queries/dailyLogs';

    /**
     * MemoryService - Convenience class for common operations
     */
    export class MemoryService {
      /**
       * Initialize or resume a session
       * Logs session_start event if new session
       */
      static async initSession(source: string = 'user_initiated'): Promise<number> {
        const { sessionId, isNew } = await (await import('./queries/sessions')).getOrCreateSession();

        if (isNew) {
          const { logEvent } = await import('./queries/dailyLogs');
          await logEvent(sessionId, 'session_start', { source });
        }

        return sessionId;
      }

      /**
       * End current session with logging
       */
      static async closeSession(
        sessionId: number,
        trigger: 'timeout' | 'explicit' | 'browser_close',
        summary?: string
      ): Promise<void> {
        const { logEvent } = await import('./queries/dailyLogs');
        const { endSession, getActiveSession } = await import('./queries/sessions');
        const { getSessionEvents } = await import('./queries/dailyLogs');

        // Calculate duration
        const events = await getSessionEvents(sessionId);
        const startEvent = events.find(e => e.eventType === 'session_start');
        const durationMinutes = startEvent
          ? Math.round((Date.now() - new Date(startEvent.timestamp).getTime()) / 60000)
          : 0;

        // Log end event
        await logEvent(sessionId, 'session_end', {
          trigger,
          duration_minutes: durationMinutes,
        });

        // Close session
        await endSession(sessionId, trigger, summary);
      }

      /**
       * Remember a fact (with deduplication)
       */
      static async remember(
        content: string,
        category: 'preference' | 'fact' | 'pattern' = 'fact',
        source: 'user_explicit' | 'jarvis_inferred' = 'user_explicit'
      ) {
        const { storeMemoryEntry } = await import('./queries/memoryEntries');
        return storeMemoryEntry(content, category, source);
      }

      /**
       * Log a significant event in current session
       */
      static async logSessionEvent(
        sessionId: number,
        eventType: 'tool_invocation' | 'topic_change' | 'user_state',
        data: Record<string, unknown>
      ) {
        const { logEvent } = await import('./queries/dailyLogs');
        return logEvent(sessionId, eventType, data);
      }
    }
    ```

    Create API route at src/app/api/jarvis/session/route.ts:
    ```typescript
    /**
     * Session API Route
     *
     * GET /api/jarvis/session - Get or create active session
     * POST /api/jarvis/session - Force new session
     * PATCH /api/jarvis/session - End current session
     */

    import { NextRequest, NextResponse } from 'next/server';
    import {
      MemoryService,
      getActiveSession,
      getRecentSessions,
    } from '@/lib/jarvis/memory';

    /**
     * GET - Get active session or create one
     */
    export async function GET() {
      try {
        const sessionId = await MemoryService.initSession();
        const active = await getActiveSession();

        return NextResponse.json({
          sessionId,
          session: active,
        });
      } catch (error) {
        console.error('[Session API] GET error:', error);
        return NextResponse.json(
          { error: 'Failed to get session' },
          { status: 500 }
        );
      }
    }

    /**
     * POST - Force start a new session
     */
    export async function POST(request: NextRequest) {
      try {
        const body = await request.json().catch(() => ({}));
        const source = body.source || 'user_initiated';

        // End any active session first
        const active = await getActiveSession();
        if (active) {
          await MemoryService.closeSession(active.id, 'explicit');
        }

        // Start new session
        const sessionId = await MemoryService.initSession(source);

        return NextResponse.json({
          sessionId,
          message: 'New session started',
        });
      } catch (error) {
        console.error('[Session API] POST error:', error);
        return NextResponse.json(
          { error: 'Failed to start session' },
          { status: 500 }
        );
      }
    }

    /**
     * PATCH - End current session
     */
    export async function PATCH(request: NextRequest) {
      try {
        const body = await request.json();
        const { sessionId, trigger, summary } = body;

        if (!sessionId || !trigger) {
          return NextResponse.json(
            { error: 'sessionId and trigger required' },
            { status: 400 }
          );
        }

        await MemoryService.closeSession(sessionId, trigger, summary);

        return NextResponse.json({
          message: 'Session ended',
          sessionId,
        });
      } catch (error) {
        console.error('[Session API] PATCH error:', error);
        return NextResponse.json(
          { error: 'Failed to end session' },
          { status: 500 }
        );
      }
    }
    ```

    Note: This route is server-side only. The client will call it to manage sessions.
  </action>
  <verify>
    Run: `cat src/lib/jarvis/memory/index.ts | grep "export"`
    Should show exports for all query functions and MemoryService.

    Run: `cat src/app/api/jarvis/session/route.ts | grep "export async function"`
    Should show GET, POST, PATCH exports.
  </verify>
  <done>MemoryService facade and session API route created</done>
</task>

<task type="auto">
  <name>Task 3: Verify persistence across browser sessions</name>
  <files>None (verification only)</files>
  <action>
    This task verifies MEM-01 (facts persist) and MEM-08 (log events) work correctly.

    1. Ensure turso dev is running (or start it)
    2. Ensure schema is pushed (npm run db:push)
    3. Start Next.js dev server
    4. Test persistence via API:

    ```bash
    # Start session
    curl -X GET http://localhost:3000/api/jarvis/session

    # Should return { sessionId: 1, session: { id: 1, startedAt: "...", ... } }

    # Store a memory entry (using a test script or curl to a test endpoint)
    # Note: We'll add a test memory endpoint or verify via drizzle studio

    # End session
    curl -X PATCH http://localhost:3000/api/jarvis/session \
      -H "Content-Type: application/json" \
      -d '{"sessionId": 1, "trigger": "explicit"}'

    # Get session again - should create new one
    curl -X GET http://localhost:3000/api/jarvis/session
    # Should return { sessionId: 2, ... }
    ```

    5. Verify data persists: `npm run db:studio` to inspect tables

    If tests pass, document in summary. If issues found, fix them.
  </action>
  <verify>
    1. curl GET /api/jarvis/session returns sessionId
    2. curl PATCH to end session succeeds
    3. curl GET again returns new sessionId (incrementing)
    4. Tables in drizzle studio show records (or direct SQL query)
  </verify>
  <done>Session lifecycle works via API; data persists in SQLite; MEM-01 and MEM-08 infrastructure complete</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Query functions exist for all three tables
2. MemoryService facade provides convenient API
3. /api/jarvis/session route manages session lifecycle
4. Session creation/ending works via HTTP
5. Data persists across server restarts
</verification>

<success_criteria>
- storeMemoryEntry() handles deduplication correctly (same content = silent update)
- startSession/endSession manage lifecycle with triggers
- logEvent records significant events with JSON data
- API route enables client session management
- Manual testing confirms persistence across browser refresh
</success_criteria>

<output>
After completion, create `jarvis/.planning/phases/07-database-foundation/07-03-SUMMARY.md`
</output>
