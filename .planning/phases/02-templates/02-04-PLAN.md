---
phase: 02-templates
plan: 04
type: execute
wave: 3
depends_on: ["02-01", "02-03"]
files_modified:
  - src/components/ui/SaveTemplateDialog.tsx
  - src/components/ui/ScreenshotCapture.tsx
  - src/components/ui/ControlPanel.tsx
  - src/app/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can save current visual state with a custom name"
    - "Saved template captures thumbnail from current canvas"
    - "Save dialog validates name (non-empty)"
    - "Saved template appears immediately in gallery"
  artifacts:
    - path: "src/components/ui/SaveTemplateDialog.tsx"
      provides: "Modal dialog for template naming and saving"
      exports: ["SaveTemplateDialog"]
    - path: "src/components/ui/ScreenshotCapture.tsx"
      provides: "R3F component for canvas screenshot capture"
      exports: ["ScreenshotCapture", "ScreenshotCaptureRef"]
  key_links:
    - from: "src/components/ui/SaveTemplateDialog.tsx"
      to: "src/lib/stores/templateStore.ts"
      via: "saveTemplate action"
      pattern: "saveTemplate"
    - from: "src/components/ui/ScreenshotCapture.tsx"
      to: "Canvas gl.domElement"
      via: "toDataURL"
      pattern: "toDataURL"
    - from: "src/app/page.tsx"
      to: "Canvas"
      via: "preserveDrawingBuffer: true"
      pattern: "preserveDrawingBuffer"
---

<objective>
Implement template saving with screenshot capture and save dialog.

Purpose: Allow users to save their current visual configuration as a named template with an auto-captured thumbnail. Completes TPL-01 (save) functionality and enables user-created presets.

Output: SaveTemplateDialog component, ScreenshotCapture component, Canvas configured for screenshots, complete save workflow.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/02-templates/02-RESEARCH.md
@src/app/page.tsx
@src/components/ui/ControlPanel.tsx
@src/lib/stores/templateStore.ts
@src/lib/stores/visualStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Canvas for screenshots</name>
  <files>src/app/page.tsx</files>
  <action>
Update the Canvas component in `src/app/page.tsx` to enable screenshot capture:

1. Add `preserveDrawingBuffer: true` to the gl prop:

```tsx
<Canvas
  camera={{ position: [0, 2, 10], fov: 50 }}
  dpr={[1, 2]}
  gl={{
    antialias: true,
    powerPreference: 'high-performance',
    preserveDrawingBuffer: true,  // ADD THIS - required for screenshots
  }}
  style={{ background: '#000000', position: 'absolute', zIndex: 1 }}
>
```

**Why:** Without `preserveDrawingBuffer`, WebGL clears the drawing buffer after compositing, making `toDataURL()` return a black image.

Note: This has a minor performance impact but is necessary for screenshot functionality.
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Dev server runs without errors
  </verify>
  <done>Canvas configured with preserveDrawingBuffer: true for screenshot capture</done>
</task>

<task type="auto">
  <name>Task 2: Create ScreenshotCapture component</name>
  <files>src/components/ui/ScreenshotCapture.tsx</files>
  <action>
Create `src/components/ui/ScreenshotCapture.tsx`:

```tsx
'use client';

import { useThree } from '@react-three/fiber';
import { useImperativeHandle, forwardRef } from 'react';

export interface ScreenshotCaptureRef {
  capture: () => Promise<string>;
}

/**
 * Invisible component that provides screenshot capture functionality
 * Must be placed inside Canvas tree to access gl context
 */
export const ScreenshotCapture = forwardRef<ScreenshotCaptureRef>((_, ref) => {
  const { gl, scene, camera } = useThree();

  useImperativeHandle(ref, () => ({
    capture: async (): Promise<string> => {
      // Force render to ensure current state is drawn
      gl.render(scene, camera);

      // Capture full canvas as JPEG
      const fullDataUrl = gl.domElement.toDataURL('image/jpeg', 0.8);

      // Resize to thumbnail (150x150, center-cropped square)
      return resizeToThumbnail(fullDataUrl, 150, 150);
    },
  }));

  return null; // Invisible component
});

ScreenshotCapture.displayName = 'ScreenshotCapture';

/**
 * Resize image to square thumbnail using offscreen canvas
 */
function resizeToThumbnail(
  dataUrl: string,
  width: number,
  height: number
): Promise<string> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');

      if (!ctx) {
        reject(new Error('Could not get 2D context'));
        return;
      }

      // Center crop to square
      const size = Math.min(img.width, img.height);
      const sx = (img.width - size) / 2;
      const sy = (img.height - size) / 2;

      ctx.drawImage(img, sx, sy, size, size, 0, 0, width, height);
      resolve(canvas.toDataURL('image/jpeg', 0.7));
    };
    img.onerror = () => reject(new Error('Failed to load image'));
    img.src = dataUrl;
  });
}
```

This component:
- Must be inside Canvas (uses useThree)
- Exposes capture() via ref
- Returns Base64 JPEG data URL (~10-20KB)
- Center-crops to square thumbnail
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>ScreenshotCapture component exports capture() method via ref</done>
</task>

<task type="auto">
  <name>Task 3: Create SaveTemplateDialog component</name>
  <files>src/components/ui/SaveTemplateDialog.tsx</files>
  <action>
Create `src/components/ui/SaveTemplateDialog.tsx`:

```tsx
'use client';

import { useState, useEffect, useRef } from 'react';
import { useTemplateStore } from '@/lib/stores/templateStore';
import { useVisualStore, selectSerializableState } from '@/lib/stores/visualStore';
import { ScreenshotCaptureRef } from './ScreenshotCapture';

interface SaveTemplateDialogProps {
  isOpen: boolean;
  onClose: () => void;
  screenshotRef: React.RefObject<ScreenshotCaptureRef>;
}

export function SaveTemplateDialog({
  isOpen,
  onClose,
  screenshotRef,
}: SaveTemplateDialogProps) {
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  const saveTemplate = useTemplateStore((state) => state.saveTemplate);

  // Focus input when dialog opens
  useEffect(() => {
    if (isOpen) {
      setName('');
      setDescription('');
      setError(null);
      setTimeout(() => inputRef.current?.focus(), 100);
    }
  }, [isOpen]);

  const handleSave = async () => {
    // Validate
    const trimmedName = name.trim();
    if (!trimmedName) {
      setError('Please enter a template name');
      inputRef.current?.focus();
      return;
    }

    setIsSaving(true);
    setError(null);

    try {
      // Capture thumbnail
      let thumbnail: string | undefined;
      try {
        thumbnail = await screenshotRef.current?.capture();
      } catch (err) {
        console.warn('Failed to capture thumbnail:', err);
        // Continue without thumbnail
      }

      // Get current visual state
      const settings = selectSerializableState(useVisualStore.getState());

      // Save template
      saveTemplate(trimmedName, settings, {
        description: description.trim() || undefined,
        thumbnail,
      });

      onClose();
    } catch (err) {
      setError('Failed to save template');
      console.error(err);
    } finally {
      setIsSaving(false);
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSave();
    } else if (e.key === 'Escape') {
      onClose();
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-[100] flex items-center justify-center p-4">
      {/* Backdrop */}
      <div
        className="absolute inset-0 bg-black/70 backdrop-blur-sm"
        onClick={onClose}
      />

      {/* Dialog */}
      <div
        className="
          relative z-10
          bg-slate-900 border border-white/20 rounded-xl
          p-6 w-full max-w-md
          shadow-2xl
        "
        onKeyDown={handleKeyDown}
      >
        <h2 className="text-white text-lg font-semibold mb-4">
          Save as Template
        </h2>

        {/* Name Input */}
        <div className="mb-4">
          <label className="block text-white/70 text-sm mb-1">
            Template Name <span className="text-red-400">*</span>
          </label>
          <input
            ref={inputRef}
            type="text"
            value={name}
            onChange={(e) => setName(e.target.value)}
            placeholder="My Custom Look"
            className="
              w-full px-3 py-2 rounded-lg
              bg-white/10 border border-white/20
              text-white placeholder-white/40
              focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500
            "
            maxLength={50}
          />
        </div>

        {/* Description Input */}
        <div className="mb-4">
          <label className="block text-white/70 text-sm mb-1">
            Description (optional)
          </label>
          <textarea
            value={description}
            onChange={(e) => setDescription(e.target.value)}
            placeholder="Describe this visual style..."
            rows={2}
            className="
              w-full px-3 py-2 rounded-lg
              bg-white/10 border border-white/20
              text-white placeholder-white/40
              focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500
              resize-none
            "
            maxLength={200}
          />
        </div>

        {/* Error Message */}
        {error && (
          <p className="text-red-400 text-sm mb-4">{error}</p>
        )}

        {/* Buttons */}
        <div className="flex gap-3 justify-end">
          <button
            onClick={onClose}
            disabled={isSaving}
            className="
              px-4 py-2 rounded-lg
              bg-white/10 hover:bg-white/20
              text-white/80 hover:text-white
              transition-all
              disabled:opacity-50
            "
          >
            Cancel
          </button>
          <button
            onClick={handleSave}
            disabled={isSaving}
            className="
              px-4 py-2 rounded-lg
              bg-blue-600 hover:bg-blue-500
              text-white font-medium
              transition-all
              disabled:opacity-50 disabled:cursor-wait
            "
          >
            {isSaving ? 'Saving...' : 'Save Template'}
          </button>
        </div>
      </div>
    </div>
  );
}
```

Features:
- Modal overlay with backdrop blur
- Name field (required, max 50 chars)
- Description field (optional, max 200 chars)
- Auto-focus on open
- Enter to save, Escape to close
- Captures thumbnail automatically
- Loading state during save
- Error handling
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>SaveTemplateDialog component with name/description inputs, validation, and auto-thumbnail capture</done>
</task>

<task type="auto">
  <name>Task 4: Wire ScreenshotCapture and SaveTemplateDialog into app</name>
  <files>src/app/page.tsx, src/components/ui/ControlPanel.tsx</files>
  <action>
**Update src/app/page.tsx:**

1. Add import and ref:
```tsx
import { useRef } from 'react';
import { ScreenshotCapture, ScreenshotCaptureRef } from '@/components/ui/ScreenshotCapture';
```

2. Create ref in component:
```tsx
const screenshotRef = useRef<ScreenshotCaptureRef>(null);
```

3. Add ScreenshotCapture inside Canvas (after StarNestSkybox, before OrbitControls):
```tsx
<ScreenshotCapture ref={screenshotRef} />
```

4. Pass ref to ControlPanel:
```tsx
<ControlPanel screenshotRef={screenshotRef} />
```

**Update src/components/ui/ControlPanel.tsx:**

1. Add imports:
```tsx
import { ScreenshotCaptureRef } from './ScreenshotCapture';
import { SaveTemplateDialog } from './SaveTemplateDialog';
```

2. Update props interface:
```tsx
interface ControlPanelProps {
  screenshotRef?: React.RefObject<ScreenshotCaptureRef>;
}

export function ControlPanel({ screenshotRef }: ControlPanelProps) {
```

3. Add state for save dialog (if not already added in plan 02-03):
```tsx
const [showSaveDialog, setShowSaveDialog] = useState(false);
```

4. Add SaveTemplateDialog at end of component (before final closing div):
```tsx
{screenshotRef && (
  <SaveTemplateDialog
    isOpen={showSaveDialog}
    onClose={() => setShowSaveDialog(false)}
    screenshotRef={screenshotRef}
  />
)}
```

5. Make sure TemplateGallery's onSaveNew prop opens the dialog:
```tsx
<TemplateGallery onSaveNew={() => setShowSaveDialog(true)} />
```
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Start dev server: `npm run dev`
3. Open http://localhost:3000
4. Open Templates section
5. Click "Save Current"
6. Dialog appears with name/description inputs
7. Enter name, click Save
8. New template appears in "Your Templates" section with thumbnail
9. Refresh page - saved template persists
  </verify>
  <done>Complete save workflow: ScreenshotCapture in Canvas, SaveTemplateDialog wired to ControlPanel, clicking Save Current opens dialog, saving captures thumbnail and persists template</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes
2. Dev server runs without errors
3. Complete save workflow:
   - Expand Templates section
   - Click "Save Current"
   - Enter name "Test Template"
   - Click Save
   - New template appears with thumbnail
   - Refresh page - template persists
4. Thumbnail shows current visual state (not black)
</verification>

<success_criteria>
- Canvas configured with preserveDrawingBuffer: true
- ScreenshotCapture component captures canvas as JPEG thumbnail
- SaveTemplateDialog validates name, captures thumbnail, saves template
- Saved templates persist across browser sessions (TPL-05)
- Complete TPL-01: Save visual settings as named template
</success_criteria>

<output>
After completion, create `.planning/phases/02-templates/02-04-SUMMARY.md`
</output>
