---
phase: 02-templates
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/index.ts
  - src/lib/stores/templateStore.ts
  - src/lib/templates/types.ts
autonomous: true

must_haves:
  truths:
    - "Template store persists across browser sessions"
    - "Visual state can be serialized to JSON without functions"
    - "Templates have unique IDs and timestamps"
  artifacts:
    - path: "src/lib/templates/types.ts"
      provides: "VisualTemplate and TemplateSettings types"
      exports: ["VisualTemplate", "TemplateSettings"]
    - path: "src/lib/stores/templateStore.ts"
      provides: "Zustand store with persist middleware"
      exports: ["useTemplateStore"]
  key_links:
    - from: "src/lib/stores/templateStore.ts"
      to: "localStorage"
      via: "zustand persist middleware"
      pattern: "persist.*localStorage"
---

<objective>
Create template type definitions and Zustand store with localStorage persistence.

Purpose: Establish the data foundation for the template system - defines what a template contains and how templates are stored/retrieved across browser sessions.

Output: Type definitions for templates, Zustand store with CRUD operations and automatic localStorage persistence (TPL-05).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/02-templates/02-RESEARCH.md
@src/types/index.ts
@src/lib/stores/visualStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create template type definitions</name>
  <files>src/lib/templates/types.ts, src/types/index.ts</files>
  <action>
Create `src/lib/templates/types.ts` with:

```typescript
import { ParticleLayerConfig, StarNestPreset, VisualMode } from '@/types';

// Serializable subset of visual state (no functions)
export interface TemplateSettings {
  intensity: number;
  layers: ParticleLayerConfig[];
  skyboxPreset: StarNestPreset;
  skyboxRotationSpeed: number;
  currentMode: VisualMode;
  waterEnabled: boolean;
  waterColor: string;
  waterReflectivity: number;
}

export interface VisualTemplate {
  id: string;                    // UUID via crypto.randomUUID()
  name: string;                  // User-defined name
  description?: string;          // Optional description
  createdAt: number;             // Unix timestamp (Date.now())
  updatedAt: number;             // Unix timestamp
  thumbnail?: string;            // Base64 data URL (JPEG, ~10-30KB)
  isBuiltIn: boolean;            // true for curated presets, false for user-created
  settings: TemplateSettings;
}
```

Also re-export these types from `src/types/index.ts` by adding:
```typescript
export type { VisualTemplate, TemplateSettings } from '@/lib/templates/types';
```
  </action>
  <verify>
TypeScript compiles without errors:
```bash
npx tsc --noEmit
```
  </verify>
  <done>VisualTemplate and TemplateSettings types exist and are exported from @/types</done>
</task>

<task type="auto">
  <name>Task 2: Create templateStore with persistence</name>
  <files>src/lib/stores/templateStore.ts</files>
  <action>
Create Zustand store with persist middleware for template CRUD:

```typescript
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import { VisualTemplate, TemplateSettings } from '@/lib/templates/types';

interface TemplateState {
  templates: VisualTemplate[];
  activeTemplateId: string | null;

  // CRUD actions
  saveTemplate: (name: string, settings: TemplateSettings, options?: {
    description?: string;
    thumbnail?: string;
  }) => string; // Returns new template ID
  loadTemplate: (id: string) => TemplateSettings | null;
  deleteTemplate: (id: string) => void;
  updateTemplate: (id: string, updates: Partial<Omit<VisualTemplate, 'id' | 'createdAt' | 'isBuiltIn'>>) => void;
  setActiveTemplate: (id: string | null) => void;

  // Query helpers
  getUserTemplates: () => VisualTemplate[];
  getBuiltInTemplates: () => VisualTemplate[];
}

export const useTemplateStore = create<TemplateState>()(
  persist(
    (set, get) => ({
      templates: [],
      activeTemplateId: null,

      saveTemplate: (name, settings, options = {}) => {
        const id = crypto.randomUUID();
        const newTemplate: VisualTemplate = {
          id,
          name,
          description: options.description,
          createdAt: Date.now(),
          updatedAt: Date.now(),
          thumbnail: options.thumbnail,
          isBuiltIn: false,
          settings,
        };
        set((state) => ({
          templates: [...state.templates, newTemplate],
          activeTemplateId: id,
        }));
        return id;
      },

      loadTemplate: (id) => {
        const template = get().templates.find(t => t.id === id);
        if (template) {
          set({ activeTemplateId: id });
          return template.settings;
        }
        return null;
      },

      deleteTemplate: (id) => {
        const template = get().templates.find(t => t.id === id);
        if (template?.isBuiltIn) return; // Cannot delete built-in

        set((state) => ({
          templates: state.templates.filter(t => t.id !== id),
          activeTemplateId: state.activeTemplateId === id ? null : state.activeTemplateId,
        }));
      },

      updateTemplate: (id, updates) => {
        const template = get().templates.find(t => t.id === id);
        if (template?.isBuiltIn) return; // Cannot modify built-in

        set((state) => ({
          templates: state.templates.map(t =>
            t.id === id ? { ...t, ...updates, updatedAt: Date.now() } : t
          ),
        }));
      },

      setActiveTemplate: (id) => set({ activeTemplateId: id }),

      getUserTemplates: () => get().templates.filter(t => !t.isBuiltIn),
      getBuiltInTemplates: () => get().templates.filter(t => t.isBuiltIn),
    }),
    {
      name: 'ethereal-flame-templates',
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({
        // Persist templates and active ID
        templates: state.templates.filter(t => !t.isBuiltIn), // Only user templates
        activeTemplateId: state.activeTemplateId,
      }),
    }
  )
);
```

Key design decisions:
- Use `crypto.randomUUID()` for IDs (browser native, no dependencies)
- `partialize` excludes built-in templates (they're loaded from code, not localStorage)
- `isBuiltIn` flag prevents deletion/modification of curated presets
- `saveTemplate` returns the new ID for immediate use
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Store can be imported without errors
  </verify>
  <done>templateStore exports useTemplateStore with CRUD operations and localStorage persistence</done>
</task>

<task type="auto">
  <name>Task 3: Add helper to extract serializable state from visualStore</name>
  <files>src/lib/stores/visualStore.ts</files>
  <action>
Add a selector function to extract serializable state from visualStore:

```typescript
import { TemplateSettings } from '@/lib/templates/types';

// Add after the store creation:

/**
 * Selector to extract serializable visual state for template saving
 * Excludes functions and non-serializable data
 */
export const selectSerializableState = (state: VisualState): TemplateSettings => ({
  intensity: state.intensity,
  layers: state.layers,
  skyboxPreset: state.skyboxPreset,
  skyboxRotationSpeed: state.skyboxRotationSpeed,
  currentMode: state.currentMode,
  waterEnabled: state.waterEnabled,
  waterColor: state.waterColor,
  waterReflectivity: state.waterReflectivity,
});

/**
 * Action to apply template settings to visual state
 */
// Add to the store interface:
applyTemplateSettings: (settings: TemplateSettings) => void;

// Add to the store implementation:
applyTemplateSettings: (settings) => set({
  intensity: settings.intensity,
  layers: settings.layers,
  skyboxPreset: settings.skyboxPreset,
  skyboxRotationSpeed: settings.skyboxRotationSpeed,
  currentMode: settings.currentMode,
  waterEnabled: settings.waterEnabled,
  waterColor: settings.waterColor,
  waterReflectivity: settings.waterReflectivity,
}),
```

This creates the bridge between templateStore and visualStore:
- `selectSerializableState` extracts current visual state for saving
- `applyTemplateSettings` applies a loaded template to visual state
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Can import selectSerializableState from visualStore
  </verify>
  <done>visualStore exports selectSerializableState selector and applyTemplateSettings action</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes
2. Open browser devtools, check localStorage has 'ethereal-flame-templates' key after saving a template
3. Refresh page, verify templates persist
</verification>

<success_criteria>
- VisualTemplate and TemplateSettings types defined and exported
- templateStore has saveTemplate, loadTemplate, deleteTemplate, updateTemplate actions
- Templates persist in localStorage across page refreshes
- visualStore has selectSerializableState and applyTemplateSettings
</success_criteria>

<output>
After completion, create `.planning/phases/02-templates/02-01-SUMMARY.md`
</output>
