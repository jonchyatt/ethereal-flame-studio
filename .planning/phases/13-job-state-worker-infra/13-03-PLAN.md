---
phase: 13-job-state-worker-infra
plan: 03
type: execute
wave: 2
depends_on: [13-01]
files_modified:
  - worker/index.ts
  - worker/process-job.ts
  - worker/reaper.ts
  - worker/package.json
  - worker/tsconfig.json
  - worker/Dockerfile
autonomous: true
requirements: [JOB-02, JOB-05, WORK-01]

must_haves:
  truths:
    - "The Render.com worker process starts, connects to Turso, and polls for pending jobs every 3-5 seconds"
    - "A job stuck in processing for longer than the configured timeout is automatically marked as failed"
    - "Worker handles SIGTERM/SIGINT gracefully — finishes current poll cycle, kills child processes, exits cleanly"
    - "Worker claims jobs atomically so multiple workers cannot double-pick the same job"
  artifacts:
    - path: "worker/index.ts"
      provides: "Main worker entry point with poll loop, heartbeat, graceful shutdown"
      contains: "setInterval"
    - path: "worker/process-job.ts"
      provides: "Job processing dispatcher with SIGTERM child process handling and cancellation detection"
      exports: ["processJob"]
    - path: "worker/reaper.ts"
      provides: "Stale job reaper that marks timed-out processing jobs as failed"
      exports: ["runReaper"]
    - path: "worker/package.json"
      provides: "Standalone package.json for Render.com deployment"
      contains: "start"
    - path: "worker/Dockerfile"
      provides: "Docker image for Render.com background worker with ffmpeg and yt-dlp"
      contains: "ffmpeg"
  key_links:
    - from: "worker/index.ts"
      to: "src/lib/jobs/TursoJobStore.ts"
      via: "Direct import of TursoJobStore for production worker"
      pattern: "TursoJobStore"
    - from: "worker/index.ts"
      to: "worker/process-job.ts"
      via: "Calls processJob() for each claimed job"
      pattern: "processJob"
    - from: "worker/index.ts"
      to: "worker/reaper.ts"
      via: "Runs reaper on each poll cycle"
      pattern: "runReaper"
---

<objective>
Build the standalone Render.com background worker that polls Turso for pending jobs, processes them, handles cancellation via SIGTERM, and reaps stale jobs.

Purpose: The worker is the CPU execution engine for all audio processing. It must run independently of the web server, connect to the same Turso database, and reliably pick up and process jobs without double-pickup or orphaned processes. This phase delivers the worker infrastructure — actual processing logic (ingest/edit/save pipelines) is wired in Phase 14.

Output: `worker/` directory with entry point, job dispatcher, reaper, Dockerfile, and package.json — deployable to Render.com as a background worker.
</objective>

<execution_context>
@C:/Users/jonch/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jonch/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-job-state-worker-infra/13-CONTEXT.md
@.planning/phases/13-job-state-worker-infra/13-01-SUMMARY.md
@src/lib/jobs/types.ts
@src/lib/jobs/TursoJobStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Worker entry point with poll loop, heartbeat, and graceful shutdown</name>
  <files>worker/index.ts, worker/package.json, worker/tsconfig.json, worker/Dockerfile</files>
  <action>
**1. Create `worker/package.json`:**
```json
{
  "name": "ethereal-flame-worker",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "start": "node dist/index.js",
    "build": "tsc",
    "dev": "tsx watch index.ts"
  },
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "dotenv": "^16.4.5"
  },
  "devDependencies": {
    "tsx": "^4.7.0",
    "typescript": "^5.3.0"
  }
}
```

Note: The worker imports from `../src/lib/jobs/` directly. In production Dockerfile, the entire repo is copied and built. This keeps one source of truth for job types and store logic. The worker does NOT duplicate the JobStore code.

**2. Create `worker/tsconfig.json`:**
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "moduleResolution": "node",
    "outDir": "dist",
    "rootDir": "..",
    "strict": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "paths": {
      "@/*": ["../src/*"]
    }
  },
  "include": ["./**/*.ts", "../src/lib/jobs/**/*.ts", "../src/lib/db/job-schema.ts"]
}
```

**3. Create `worker/index.ts`** — Main entry point:

```typescript
import 'dotenv/config';
import { TursoJobStore } from '../src/lib/jobs/TursoJobStore';
import { processJob } from './process-job';
import { runReaper } from './reaper';
import type { JobStore } from '../src/lib/jobs/types';
```

Configuration constants:
- `POLL_INTERVAL_MS` = `Number(process.env.WORKER_POLL_INTERVAL_MS) || 3000` (3-5 sec per user decision)
- `REAPER_INTERVAL_MS` = `Number(process.env.WORKER_REAPER_INTERVAL_MS) || 30000` (run reaper every 30s)
- `JOB_TIMEOUT_MS` = per job type config (see below)

Job timeout configuration (per user decision: configurable timeout per job type):
```typescript
const JOB_TIMEOUTS: Record<string, number> = {
  ingest: Number(process.env.WORKER_INGEST_TIMEOUT_MS) || 10 * 60 * 1000,   // 10 min
  preview: Number(process.env.WORKER_PREVIEW_TIMEOUT_MS) || 5 * 60 * 1000,  // 5 min
  save: Number(process.env.WORKER_SAVE_TIMEOUT_MS) || 15 * 60 * 1000,       // 15 min
  default: Number(process.env.WORKER_DEFAULT_TIMEOUT_MS) || 10 * 60 * 1000, // 10 min
};
```

Worker lifecycle:
1. Create `TursoJobStore` with `TURSO_DATABASE_URL` and `TURSO_AUTH_TOKEN` env vars
2. Log startup: `[Worker] Started, polling every ${POLL_INTERVAL_MS}ms`
3. Set up poll loop via `setInterval`:
   - Call `store.claimNextPending()` — atomic claim
   - If a job is claimed:
     - Log: `[Worker] Claimed job ${job.jobId} (${job.type})`
     - Call `processJob(store, job)` — awaited (one job at a time, per user decision)
     - Log: `[Worker] Finished job ${job.jobId}`
   - If no job, do nothing (quiet poll)
4. Set up reaper loop via separate `setInterval`:
   - Call `runReaper(store, JOB_TIMEOUTS)` every REAPER_INTERVAL_MS
5. Heartbeat: The worker updates job `updatedAt` during processing (inside `processJob`). The reaper uses this to detect stuck jobs.

Graceful shutdown:
- Listen for `SIGTERM` and `SIGINT`
- On signal:
  1. Log: `[Worker] Shutdown signal received, finishing current job...`
  2. Set `shuttingDown = true` flag
  3. Clear both intervals
  4. Wait for current `processJob` to finish (if running) via a promise
  5. Close the store connection
  6. `process.exit(0)`
- The poll loop checks `shuttingDown` before claiming next job

**4. Create `worker/Dockerfile`:**
```dockerfile
FROM node:20-slim

# Install ffmpeg and yt-dlp
RUN apt-get update && apt-get install -y --no-install-recommends \
    ffmpeg \
    python3 \
    curl \
  && curl -L https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp -o /usr/local/bin/yt-dlp \
  && chmod a+rx /usr/local/bin/yt-dlp \
  && apt-get clean && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Copy package files and install deps
COPY package.json package-lock.json ./
COPY worker/package.json worker/
RUN npm ci --workspace=worker

# Copy source
COPY . .

# Build worker
RUN cd worker && npm run build

CMD ["node", "worker/dist/index.js"]
```

This Dockerfile is for Render.com background worker deployment ($7/mo tier). It includes ffmpeg and yt-dlp per WORK-01 requirement.
  </action>
  <verify>
- `npx tsc --noEmit worker/index.ts` (or manual check) compiles without errors
- worker/package.json has start script
- worker/Dockerfile installs ffmpeg and yt-dlp
- Poll interval is configurable via env var, defaults to 3000ms
- Graceful shutdown handles SIGTERM/SIGINT
  </verify>
  <done>
Worker entry point polls Turso every 3 seconds, claims one job at a time atomically, runs reaper periodically, and shuts down gracefully on SIGTERM. Dockerfile includes ffmpeg + yt-dlp. Deployable to Render.com as background worker.
  </done>
</task>

<task type="auto">
  <name>Task 2: Job processor with cancellation detection and stale job reaper</name>
  <files>worker/process-job.ts, worker/reaper.ts</files>
  <action>
**1. Create `worker/process-job.ts`** — Job processing dispatcher:

```typescript
import type { JobStore, AudioPrepJob } from '../src/lib/jobs/types';
import { ChildProcess } from 'child_process';
```

Export `processJob(store: JobStore, job: AudioPrepJob): Promise<void>`:

1. Set up cancellation detection:
   - Create a polling interval (every 2 seconds) that checks `store.get(job.jobId)` — if status is `'cancelled'`, trigger cancellation
   - Keep reference to any spawned `ChildProcess` so it can be killed

2. Set up heartbeat:
   - Create interval (every 5 seconds) that calls `store.update(job.jobId, {})` — this updates `updatedAt` without changing any field, keeping the reaper from marking this job as stale (per user decision: "Worker heartbeats: updates updatedAt every poll cycle")

3. Dispatch based on `job.type`:
   - For now (Phase 13 = infrastructure only), all job types log a placeholder:
     ```
     [Worker] Processing ${job.type} job ${job.jobId} — pipeline not yet wired (Phase 14)
     ```
   - Update stage to `'initializing'` and progress to 0
   - Simulate work with a 1-second delay (or immediately complete)
   - Call `store.complete(job.jobId, { placeholder: true, message: 'Pipeline not yet wired' })`
   - Actual ingest/edit/save pipelines are wired in Phase 14

4. Cancellation handling (per user decision: "Cancellation sends SIGTERM to child process, confirmed dead before releasing the job — no orphaned ffmpeg"):
   - When cancellation detected:
     a. If a `ChildProcess` exists: send `SIGTERM`, wait up to 5 seconds, then `SIGKILL` if still alive
     b. Verify process is dead (check `.killed` or `.exitCode !== null`)
     c. Call `store.update(job.jobId, { status: 'cancelled', stage: null, progress: 0 })`
     d. Log: `[Worker] Job ${job.jobId} cancelled, child process terminated`
   - Clean up: clear heartbeat interval, clear cancellation check interval

5. Error handling with auto-retry (per user decision: "Auto-retry once on transient failures; fail immediately on permanent errors"):
   - Define transient errors: `ECONNRESET`, `ETIMEDOUT`, `ECONNREFUSED`, `EAI_AGAIN`, `EPIPE` + HTTP 5xx
   - Define permanent errors: everything else (bad input, unsupported format, ENOENT, etc.)
   - On error:
     a. If transient AND `job.retryCount < 1`: increment retryCount, set status back to 'pending' for re-pickup
     b. Otherwise: call `store.fail(job.jobId, error.message)` with clear reason
   - Always clean up heartbeat and cancellation intervals in finally block

6. Helper: `killChildProcess(child: ChildProcess): Promise<void>`:
   - Send SIGTERM
   - Set 5-second timeout
   - If not dead after timeout, send SIGKILL
   - Wait for exit event
   - Return when confirmed dead

**2. Create `worker/reaper.ts`** — Stale job cleanup:

```typescript
import type { JobStore } from '../src/lib/jobs/types';
```

Export `runReaper(store: JobStore, timeouts: Record<string, number>): Promise<void>`:

1. Per user decision: "Reaper query marks jobs failed if updatedAt hasn't changed beyond timeout threshold"
2. Use the default timeout for simplicity in this phase (the `markStaleJobsFailed` method on JobStore takes a single timeout value)
3. Call `store.markStaleJobsFailed(timeouts.default || 600000)` — default 10 minutes
4. If any jobs were marked failed, log: `[Reaper] Marked ${count} stale job(s) as failed`
5. Otherwise, silent (don't log every 30 seconds when nothing is stale)

Note: Per-job-type timeouts would require a more sophisticated reaper that queries by type. For Phase 13, use a single max timeout. Phase 14 can enhance if needed — the interface supports it.
  </action>
  <verify>
- `npx tsc --noEmit worker/process-job.ts` compiles
- `npx tsc --noEmit worker/reaper.ts` compiles
- processJob updates heartbeat during processing
- processJob detects cancellation and kills child process
- processJob auto-retries once on transient errors, fails immediately on permanent
- runReaper calls markStaleJobsFailed and logs when jobs are reaped
  </verify>
  <done>
Job processor dispatches by type (placeholder pipelines for Phase 13), maintains heartbeat, detects cancellation via poll, kills child processes with SIGTERM->SIGKILL escalation, and auto-retries once on transient failures. Reaper runs periodically and marks timed-out processing jobs as failed.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` across worker directory — no type errors
2. Worker starts with `node worker/dist/index.js` (after build) and logs poll activity
3. Worker claims pending jobs atomically from Turso
4. Worker updates `updatedAt` heartbeat during processing
5. Worker detects cancelled status and kills child processes
6. Reaper marks stale processing jobs as failed
7. SIGTERM causes graceful shutdown (finishes current job, cleans up, exits 0)
8. Dockerfile builds and includes ffmpeg + yt-dlp
</verification>

<success_criteria>
- Worker entry point polls Turso at configurable interval (default 3s)
- One job at a time, FIFO by createdAt, atomic claim
- Heartbeat keeps updatedAt fresh during processing
- Cancellation detected within one poll cycle, child process killed with SIGTERM->SIGKILL
- Stale jobs (processing beyond timeout) automatically marked as failed by reaper
- Graceful shutdown on SIGTERM/SIGINT
- Dockerfile with ffmpeg + yt-dlp ready for Render.com deployment
</success_criteria>

<output>
After completion, create `.planning/phases/13-job-state-worker-infra/13-03-SUMMARY.md`
</output>
