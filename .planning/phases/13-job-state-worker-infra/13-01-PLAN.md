---
phase: 13-job-state-worker-infra
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/job-schema.ts
  - src/lib/jobs/types.ts
  - src/lib/jobs/LocalJobStore.ts
  - src/lib/jobs/TursoJobStore.ts
  - src/lib/jobs/index.ts
  - src/lib/jobs/__tests__/JobStore.test.ts
autonomous: true
requirements: [JOB-01]

must_haves:
  truths:
    - "Job metadata is persisted in Turso cloud database in production and local SQLite in development via the same interface"
    - "JobStore adapter can be swapped via environment variable without code changes"
    - "All existing JobManager operations (create, get, update, complete, fail, cancel, list) work identically through both adapters"
  artifacts:
    - path: "src/lib/db/job-schema.ts"
      provides: "Drizzle ORM schema for audio_prep_jobs table with stage column"
      contains: "sqliteTable"
    - path: "src/lib/jobs/types.ts"
      provides: "JobStore interface and AudioPrepJob type definition"
      exports: ["JobStore", "AudioPrepJob"]
    - path: "src/lib/jobs/LocalJobStore.ts"
      provides: "better-sqlite3 backed JobStore for local development"
      exports: ["LocalJobStore"]
    - path: "src/lib/jobs/TursoJobStore.ts"
      provides: "libsql/Turso backed JobStore for production"
      exports: ["TursoJobStore"]
    - path: "src/lib/jobs/index.ts"
      provides: "Singleton factory with getJobStore() and resetJobStore()"
      exports: ["getJobStore", "resetJobStore"]
    - path: "src/lib/jobs/__tests__/JobStore.test.ts"
      provides: "Tests verifying both adapters satisfy the JobStore contract"
  key_links:
    - from: "src/lib/jobs/index.ts"
      to: "src/lib/jobs/LocalJobStore.ts"
      via: "dynamic require based on JOB_STORE_BACKEND env var"
      pattern: "JOB_STORE_BACKEND"
    - from: "src/lib/jobs/index.ts"
      to: "src/lib/jobs/TursoJobStore.ts"
      via: "dynamic require when JOB_STORE_BACKEND=turso"
      pattern: "require.*TursoJobStore"
    - from: "src/lib/jobs/LocalJobStore.ts"
      to: "src/lib/db/job-schema.ts"
      via: "Drizzle schema import for type-safe queries"
      pattern: "import.*job-schema"
---

<objective>
Create the Drizzle ORM schema for jobs, the JobStore adapter interface, and both Local and Turso implementations — mirroring the StorageAdapter pattern from Phase 12.

Purpose: Replace the hard-coded better-sqlite3 JobManager with an adapter pattern so job state can live in Turso (production) or local SQLite (development) via the same code paths. This is the foundation that all API routes and the worker will consume.

Output: `src/lib/jobs/` module with interface, two adapters, singleton factory, and tests.
</objective>

<execution_context>
@C:/Users/jonch/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jonch/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-job-state-worker-infra/13-CONTEXT.md
@src/lib/audio-prep/JobManager.ts
@src/lib/storage/types.ts
@src/lib/storage/index.ts
@src/lib/jarvis/memory/schema.ts
@src/lib/jarvis/memory/db.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Drizzle schema and JobStore interface with types</name>
  <files>src/lib/db/job-schema.ts, src/lib/jobs/types.ts</files>
  <action>
**1. Create `src/lib/db/job-schema.ts`** — Drizzle ORM schema for the audio_prep_jobs table:

```typescript
import { sqliteTable, text, real, index } from 'drizzle-orm/sqlite-core';
```

Define `audioPrepJobs` table with columns:
- `jobId` TEXT PRIMARY KEY (UUID, generated at insert time)
- `type` TEXT NOT NULL — `'ingest' | 'preview' | 'save'`
- `status` TEXT NOT NULL DEFAULT `'pending'` — `'pending' | 'processing' | 'complete' | 'failed' | 'cancelled'`
- `progress` REAL NOT NULL DEFAULT 0 — percentage within current stage (0-100)
- `stage` TEXT — nullable, descriptive string like `"downloading"`, `"analyzing"`, `"normalizing"`, `"encoding"` (per user decision: add stage column alongside progress)
- `metadata` TEXT NOT NULL DEFAULT `'{}'` — JSON-stringified job-specific input data
- `result` TEXT — nullable, JSON-stringified output data
- `error` TEXT — nullable, human-readable failure reason
- `retryCount` INTEGER NOT NULL DEFAULT 0 — tracks auto-retry attempts (per user decision: auto-retry once on transient)
- `createdAt` TEXT NOT NULL — ISO 8601 timestamp
- `updatedAt` TEXT NOT NULL — ISO 8601 timestamp, used for heartbeat/reaper

Add indexes:
- `idx_jobs_status` on `status` — for worker claim query
- `idx_jobs_created` on `createdAt` — for FIFO ordering
- `idx_jobs_updated` on `updatedAt` — for reaper timeout check

**2. Create `src/lib/jobs/types.ts`** — Interface and types:

Define `AudioPrepJob` type (extending existing shape from `JobManager.ts`):
```typescript
export interface AudioPrepJob {
  jobId: string;
  type: 'ingest' | 'preview' | 'save';
  status: 'pending' | 'processing' | 'complete' | 'failed' | 'cancelled';
  progress: number;
  stage: string | null;          // NEW: descriptive stage name
  metadata: Record<string, unknown>;
  result?: Record<string, unknown>;
  error?: string;
  retryCount: number;            // NEW: for auto-retry tracking
  createdAt: string;
  updatedAt: string;
}
```

Define `JobStore` interface (matching existing AudioPrepJobManager's API):
```typescript
export interface JobStore {
  create(type: AudioPrepJob['type'], metadata: Record<string, unknown>): Promise<AudioPrepJob>;
  get(jobId: string): Promise<AudioPrepJob | undefined>;
  update(jobId: string, updates: JobUpdate): Promise<void>;
  complete(jobId: string, result: Record<string, unknown>): Promise<void>;
  fail(jobId: string, error: string): Promise<void>;
  cancel(jobId: string): Promise<void>;
  list(options?: ListOptions): Promise<AudioPrepJob[]>;

  // Worker-specific methods
  claimNextPending(): Promise<AudioPrepJob | undefined>;  // Atomic claim for worker polling
  markStaleJobsFailed(timeoutMs: number): Promise<number>;  // Reaper: mark stuck jobs failed
  getQueuePosition(jobId: string): Promise<number>;  // Position in pending queue (for poll endpoint)
}
```

All methods are async (Promise-based) even for LocalJobStore — this ensures interface compatibility with Turso which is inherently async.

Define `JobUpdate` type:
```typescript
export type JobUpdate = Partial<Pick<AudioPrepJob, 'status' | 'progress' | 'stage' | 'result' | 'error' | 'retryCount'>>;
```

Define `ListOptions`:
```typescript
export interface ListOptions {
  status?: AudioPrepJob['status'];
  type?: AudioPrepJob['type'];
  limit?: number;
}
```

Note: AbortController management stays runtime-only (not in the interface) per existing pattern and user decision. It will be handled at the consumer layer (worker/API routes), not inside the store.
  </action>
  <verify>
- `npx tsc --noEmit src/lib/db/job-schema.ts` compiles without errors
- `npx tsc --noEmit src/lib/jobs/types.ts` compiles without errors
- Schema includes `stage` column (per user decision) and `retryCount` column
- `JobStore` interface has `claimNextPending()` and `markStaleJobsFailed()` methods
  </verify>
  <done>
Drizzle schema defines audio_prep_jobs table with stage, retryCount, and proper indexes. JobStore interface exposes all CRUD operations plus worker-specific claim/reaper methods. Types are fully defined and compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: LocalJobStore, TursoJobStore, singleton factory, and tests</name>
  <files>src/lib/jobs/LocalJobStore.ts, src/lib/jobs/TursoJobStore.ts, src/lib/jobs/index.ts, src/lib/jobs/__tests__/JobStore.test.ts</files>
  <action>
**1. Create `src/lib/jobs/LocalJobStore.ts`** — better-sqlite3 backed implementation:

- Import `Database` from `better-sqlite3` and the Drizzle schema from `../db/job-schema`
- Constructor takes optional `dbPath` (default `'./audio-prep-jobs.db'`)
- On construction: open database, set WAL mode, create table using raw SQL matching the Drizzle schema (use `CREATE TABLE IF NOT EXISTS` with all columns)
- Implement all `JobStore` methods:
  - `create()`: Generate UUID via `crypto.randomUUID()`, INSERT row, return job object
  - `get()`: SELECT by jobId, parse JSON fields (metadata, result), return undefined if not found
  - `update()`: Dynamic SET clause with updatedAt, throw if no row matched
  - `complete()`: Call update with status='complete', progress=100
  - `fail()`: Call update with status='failed'
  - `cancel()`: Check if already terminal (complete/failed/cancelled), skip if so; otherwise update status='cancelled'
  - `list()`: SELECT with optional WHERE filters (status, type), ORDER BY createdAt DESC, LIMIT
  - `claimNextPending()`: Atomic claim using `UPDATE audio_prep_jobs SET status = 'processing', updatedAt = ? WHERE jobId = (SELECT jobId FROM audio_prep_jobs WHERE status = 'pending' ORDER BY createdAt ASC LIMIT 1) RETURNING *` — prevents double-pickup (per user decision)
  - `markStaleJobsFailed()`: `UPDATE audio_prep_jobs SET status = 'failed', error = 'Timeout: job exceeded processing time limit' WHERE status = 'processing' AND updatedAt < ? RETURNING jobId` — returns count of affected rows
  - `getQueuePosition()`: Count pending jobs with createdAt earlier than this job's createdAt
- All methods are async (wrap sync better-sqlite3 calls in Promise.resolve)
- Add `close()` method for cleanup

**2. Create `src/lib/jobs/TursoJobStore.ts`** — libsql/Turso backed implementation:

- Import `createClient, Client` from `@libsql/client` and Drizzle schema
- Constructor takes `url: string` and optional `authToken: string`
- Use `@libsql/client` directly (NOT drizzle ORM for queries — raw SQL is simpler and avoids drizzle async issues with libsql). The Drizzle schema file serves as the source of truth for column definitions; queries use raw SQL against the same table.
- On construction: create libsql client, run CREATE TABLE IF NOT EXISTS
- Implement all `JobStore` methods with same logic as LocalJobStore but using async `client.execute()` instead of sync `db.prepare().run()`
- `claimNextPending()`: Use a transaction — SELECT pending LIMIT 1, then UPDATE that jobId to processing (libsql supports transactions via `client.transaction()`)
- `markStaleJobsFailed()`: Same logic, async
- `getQueuePosition()`: COUNT query, async
- Add `close()` method calling `client.close()`

**3. Create `src/lib/jobs/index.ts`** — Singleton factory (mirrors `src/lib/storage/index.ts`):

```typescript
import type { JobStore } from './types';

let _instance: JobStore | null = null;

export function getJobStore(): JobStore {
  if (_instance) return _instance;

  const backend = process.env.JOB_STORE_BACKEND || 'local';

  if (backend === 'turso') {
    const { TursoJobStore } = require('./TursoJobStore');
    _instance = new TursoJobStore(
      process.env.TURSO_DATABASE_URL!,
      process.env.TURSO_AUTH_TOKEN,
    );
  } else {
    const { LocalJobStore } = require('./LocalJobStore');
    _instance = new LocalJobStore(
      process.env.JOB_STORE_DB_PATH || './audio-prep-jobs.db',
    );
  }

  return _instance!;
}

export function resetJobStore(): void {
  _instance = null;
}
```

Re-export types: `export type { JobStore, AudioPrepJob, JobUpdate, ListOptions } from './types';`

Use dynamic `require()` to keep `@libsql/client` out of local dev bundle (matching StorageAdapter pattern per user decision).

**4. Create `src/lib/jobs/__tests__/JobStore.test.ts`** — Tests for LocalJobStore:

Test against LocalJobStore with temp DB path (same approach as existing `JobManager.test.ts`):

- `creates and retrieves a job` — create, get, verify fields including stage=null
- `updates job status, progress, and stage` — update with stage='downloading', verify
- `completes a job with result` — complete, verify status/progress/result
- `fails a job with error` — fail, verify status/error
- `cancels a pending job` — cancel, verify status
- `cancel is no-op on terminal jobs` — complete then cancel, verify still complete
- `claimNextPending returns oldest pending job as processing` — create 3 jobs, claim, verify FIFO order and status='processing'
- `claimNextPending returns undefined when no pending jobs` — empty queue
- `markStaleJobsFailed marks old processing jobs as failed` — create job, set to processing with old updatedAt, run reaper, verify failed
- `getQueuePosition returns correct position` — create 3 pending jobs, check positions
- `list filters by status` — create jobs with different statuses, list with filter
  </action>
  <verify>
- `npx jest src/lib/jobs/__tests__/JobStore.test.ts` — all tests pass
- `npx tsc --noEmit src/lib/jobs/index.ts` compiles without errors
- `getJobStore()` returns LocalJobStore by default, TursoJobStore when JOB_STORE_BACKEND=turso
- `resetJobStore()` clears the singleton
- `claimNextPending()` atomically claims the oldest pending job
  </verify>
  <done>
LocalJobStore and TursoJobStore both implement the JobStore interface. Singleton factory at `src/lib/jobs/index.ts` switches between them via `JOB_STORE_BACKEND` env var. All tests pass confirming CRUD, atomic claim, reaper, and queue position operations work correctly.
  </done>
</task>

</tasks>

<verification>
1. `npx jest src/lib/jobs/__tests__/JobStore.test.ts` — all tests green
2. `npx tsc --noEmit` — no type errors across the project
3. `getJobStore()` with no env vars returns LocalJobStore
4. `getJobStore()` with `JOB_STORE_BACKEND=turso` + `TURSO_DATABASE_URL` returns TursoJobStore
5. JobStore interface includes `stage` field and `claimNextPending()` / `markStaleJobsFailed()` methods
</verification>

<success_criteria>
- JobStore interface fully defined with all CRUD + worker operations
- LocalJobStore passes all tests using temp SQLite DB
- TursoJobStore compiles and implements same interface
- Singleton factory mirrors StorageAdapter pattern (dynamic require, resetJobStore)
- Drizzle schema includes `stage` and `retryCount` columns with proper indexes
</success_criteria>

<output>
After completion, create `.planning/phases/13-job-state-worker-infra/13-01-SUMMARY.md`
</output>
