---
phase: 17-integration-wiring-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - worker/index.ts
autonomous: true
requirements:
  - DEPLOY-01

must_haves:
  truths:
    - "Running `npm run worker` locally without TURSO_DATABASE_URL uses LocalJobStore and starts successfully"
    - "Running the worker with TURSO_DATABASE_URL set uses TursoJobStore as before"
    - "Setting JOB_STORE_BACKEND=local explicitly forces LocalJobStore regardless of other env vars"
    - "Worker shutdown still closes the database connection for both backends"
  artifacts:
    - path: "worker/index.ts"
      provides: "Worker entry point using getJobStore() factory"
      contains: "getJobStore"
  key_links:
    - from: "worker/index.ts"
      to: "src/lib/jobs/index.ts"
      via: "getJobStore() factory import"
      pattern: "import.*getJobStore.*from.*src/lib/jobs"
---

<objective>
Replace the hardcoded `new TursoJobStore()` in `worker/index.ts` with the `getJobStore()` factory so the worker automatically uses LocalJobStore in local development and TursoJobStore in production, based on environment variables.

Purpose: Closes CRIT-02 from the v2.0 milestone audit. Without this fix, `npm run worker` locally requires Turso credentials and exits with an error if TURSO_DATABASE_URL is not set. With the factory, local dev "just works" with the SQLite-backed LocalJobStore.

Output: `worker/index.ts` uses the same `getJobStore()` factory as all API routes.
</objective>

<execution_context>
@C:/Users/jonch/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jonch/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-integration-wiring-fixes/17-CONTEXT.md

# File to modify:
@worker/index.ts

# Factory to use:
@src/lib/jobs/index.ts
@src/lib/jobs/types.ts

# Both backends have close():
@src/lib/jobs/TursoJobStore.ts (line ~276: close() method)
@src/lib/jobs/LocalJobStore.ts (line ~230: close() method)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace hardcoded TursoJobStore with getJobStore() factory in worker</name>
  <files>worker/index.ts</files>
  <action>
Modify `worker/index.ts` with these specific changes:

1. **Remove** the `import { TursoJobStore } from '../src/lib/jobs/TursoJobStore'` import.
2. **Remove** the `import type { JobStore } from '../src/lib/jobs/types'` import.
3. **Add** `import { getJobStore } from '../src/lib/jobs'` (the factory re-exports the type too, but the worker only needs the function).
4. **Add** `import type { JobStore } from '../src/lib/jobs'` if needed for the `store` type annotation.

5. **Replace the `main()` function's store initialization** (currently lines ~47-55):
   - Remove the `dbUrl` and `authToken` env checks.
   - Remove the `if (!dbUrl) { ... process.exit(1) }` guard.
   - Remove `const store: JobStore = new TursoJobStore(dbUrl, authToken)`.
   - Replace with: `const store: JobStore = getJobStore()`.
   - Add a log line after: `console.log('[Worker] Using job store backend:', process.env.JOB_STORE_BACKEND || (process.env.DEPLOY_ENV === 'production' ? 'turso' : 'local'))` so operators can see which backend was selected.

6. **Fix the shutdown `close()` call** (currently line ~128):
   - The current code casts to `TursoJobStore` to call `.close()`. Since both LocalJobStore and TursoJobStore implement `close()` (not on the interface, but on both classes), change the check to:
     ```typescript
     if ('close' in store && typeof (store as { close: () => void }).close === 'function') {
       (store as { close: () => void }).close();
     }
     ```
   - This works for both backends without importing either class.

Everything else in `worker/index.ts` stays the same: the poll loop, reaper loop, shutdown handler, JOB_TIMEOUTS config, and all timers.

The `getJobStore()` factory reads `JOB_STORE_BACKEND` (explicit) or falls back to `DEPLOY_ENV` (convenience). Locally without either set, it defaults to `local` -> `LocalJobStore`. In production with `DEPLOY_ENV=production`, it selects `turso` -> `TursoJobStore`. No new env vars needed.
  </action>
  <verify>
1. Run `npx tsc --noEmit --project worker/tsconfig.json` (or the worker-specific TS config if it exists) and confirm no type errors. If the worker uses the root tsconfig, run `npx tsc --noEmit`.
2. Grep `worker/index.ts` to confirm:
   - No `TursoJobStore` import
   - `getJobStore` is imported from `../src/lib/jobs`
   - No `TURSO_DATABASE_URL` required check (the factory handles it internally)
3. Confirm the worker compiles and starts: `npx tsx worker/index.ts` (should start polling with LocalJobStore when no TURSO env vars are set, then Ctrl+C to stop).
  </verify>
  <done>
`worker/index.ts` uses `getJobStore()` from the factory module. Running the worker locally without Turso credentials starts successfully using LocalJobStore. Running with `DEPLOY_ENV=production` and Turso credentials uses TursoJobStore. The shutdown handler closes the database connection for both backends.
  </done>
</task>

</tasks>

<verification>
After task completion:
1. `worker/index.ts` has zero imports from `TursoJobStore` directly
2. `worker/index.ts` imports `getJobStore` from `../src/lib/jobs`
3. TypeScript compiles without errors
4. Worker starts locally without TURSO_DATABASE_URL (uses LocalJobStore)
5. Shutdown path calls `.close()` generically (works for both backends)
</verification>

<success_criteria>
- Worker uses `getJobStore()` factory, not hardcoded `new TursoJobStore()`
- Local development works without Turso credentials
- Production deployment works with `DEPLOY_ENV=production` and Turso credentials
- Database connection is properly closed on shutdown for both backends
- No direct imports of `TursoJobStore` remain in `worker/index.ts`
</success_criteria>

<output>
After completion, create `.planning/phases/17-integration-wiring-fixes/17-02-SUMMARY.md`
</output>
