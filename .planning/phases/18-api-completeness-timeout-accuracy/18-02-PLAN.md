---
phase: 18-api-completeness-timeout-accuracy
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - worker/reaper.ts
  - src/lib/jobs/types.ts
  - src/lib/jobs/LocalJobStore.ts
  - src/lib/jobs/TursoJobStore.ts
autonomous: true
requirements:
  - JOB-05

must_haves:
  truths:
    - "Ingest jobs stuck processing for >10 minutes are marked failed"
    - "Preview jobs stuck processing for >5 minutes are marked failed"
    - "Save jobs stuck processing for >15 minutes are marked failed"
    - "Each job type uses its own timeout threshold, not a single default"
  artifacts:
    - path: "worker/reaper.ts"
      provides: "Per-type reaper loop calling markStaleJobsFailed once per job type"
      contains: "for.*of.*Object"
    - path: "src/lib/jobs/types.ts"
      provides: "Updated markStaleJobsFailed signature with optional type parameter"
      contains: "markStaleJobsFailed.*type"
    - path: "src/lib/jobs/LocalJobStore.ts"
      provides: "LocalJobStore markStaleJobsFailed with type filter in WHERE clause"
      contains: "AND type = ?"
    - path: "src/lib/jobs/TursoJobStore.ts"
      provides: "TursoJobStore markStaleJobsFailed with type filter in WHERE clause"
      contains: "AND type = ?"
  key_links:
    - from: "worker/reaper.ts"
      to: "src/lib/jobs/types.ts"
      via: "markStaleJobsFailed(timeoutMs, type) calls per job type"
      pattern: "markStaleJobsFailed"
    - from: "worker/index.ts"
      to: "worker/reaper.ts"
      via: "runReaper(store, JOB_TIMEOUTS) — existing call, no change needed"
      pattern: "runReaper"
---

<objective>
Fix the reaper to enforce per-type job timeouts instead of using a single default timeout for all job types.

Purpose: Closes GAP-03 from the v2.0 milestone audit. The JOB_TIMEOUTS map in worker/index.ts already configures per-type values (ingest: 10min, preview: 5min, save: 15min) but the reaper ignores them, using only `timeouts.default`. This plan wires the per-type values through to the database query. Completes requirement JOB-05: jobs stuck in processing longer than a configurable timeout are automatically marked failed.

Output: Four files modified — JobStore interface gains optional type parameter on markStaleJobsFailed, both implementations add type filter to SQL, reaper iterates over type-specific timeouts.
</objective>

<execution_context>
@C:/Users/jonch/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jonch/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/v2.0-MILESTONE-AUDIT.md
@worker/reaper.ts
@worker/index.ts
@src/lib/jobs/types.ts
@src/lib/jobs/LocalJobStore.ts
@src/lib/jobs/TursoJobStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add optional type parameter to markStaleJobsFailed interface and implementations</name>
  <files>
    src/lib/jobs/types.ts
    src/lib/jobs/LocalJobStore.ts
    src/lib/jobs/TursoJobStore.ts
  </files>
  <action>
**1. Update the interface in `src/lib/jobs/types.ts`:**

Change the `markStaleJobsFailed` signature from:
```typescript
markStaleJobsFailed(timeoutMs: number): Promise<number>;
```
to:
```typescript
/** Mark processing jobs as failed if their updatedAt exceeds timeoutMs. Optionally filter by job type. Returns count affected. */
markStaleJobsFailed(timeoutMs: number, type?: AudioPrepJob['type']): Promise<number>;
```

This is backward-compatible — existing callers that pass only `timeoutMs` continue to work.

**2. Update `LocalJobStore.markStaleJobsFailed` in `src/lib/jobs/LocalJobStore.ts`:**

Change the method signature to accept the optional `type` parameter. When `type` is provided, add `AND type = ?` to the WHERE clause:

```typescript
async markStaleJobsFailed(timeoutMs: number, type?: AudioPrepJob['type']): Promise<number> {
  const cutoff = new Date(Date.now() - timeoutMs).toISOString();
  const now = new Date().toISOString();

  let sql = `UPDATE audio_prep_jobs
    SET status = 'failed', error = 'Timeout: job exceeded processing time limit', updatedAt = ?
    WHERE status = 'processing' AND updatedAt < ?`;
  const params: unknown[] = [now, cutoff];

  if (type) {
    sql += ' AND type = ?';
    params.push(type);
  }

  const result = this.db.prepare(sql).run(...params);
  return result.changes;
}
```

**3. Update `TursoJobStore.markStaleJobsFailed` in `src/lib/jobs/TursoJobStore.ts`:**

Same pattern — add optional `type` parameter and conditional WHERE clause:

```typescript
async markStaleJobsFailed(timeoutMs: number, type?: AudioPrepJob['type']): Promise<number> {
  await this.ready();

  const cutoff = new Date(Date.now() - timeoutMs).toISOString();
  const now = new Date().toISOString();

  let sql = `UPDATE audio_prep_jobs
    SET status = 'failed', error = 'Timeout: job exceeded processing time limit', updatedAt = ?
    WHERE status = 'processing' AND updatedAt < ?`;
  const args: Array<string | number | null> = [now, cutoff];

  if (type) {
    sql += ' AND type = ?';
    args.push(type);
  }

  const result = await this.client.execute({ sql, args });
  return result.rowsAffected;
}
```

Import `AudioPrepJob` type in both implementation files if not already imported (both already import it from `./types`).
  </action>
  <verify>
Run `npx tsc --noEmit` to verify the interface change is compatible with both implementations and all existing callers. Grep for `markStaleJobsFailed` across the codebase to confirm no callers break.
  </verify>
  <done>
`markStaleJobsFailed` accepts an optional `type` parameter. When called with a type, only jobs of that type are checked against the timeout. Existing callers without a type argument continue to work (all processing jobs checked).
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite reaper to iterate per-type timeouts</name>
  <files>worker/reaper.ts</files>
  <action>
The current `runReaper` function (worker/reaper.ts) uses only `timeouts.default`:

```typescript
const timeoutMs = timeouts.default || 600_000;
const count = await store.markStaleJobsFailed(timeoutMs);
```

Rewrite to iterate over all non-`default` entries in the timeouts map, calling `markStaleJobsFailed` once per type with that type's specific timeout. Then call once more WITHOUT a type filter using the `default` timeout to catch any job types not in the map (e.g., render jobs or future types).

New implementation:

```typescript
import type { JobStore } from '../src/lib/jobs/types';

/**
 * Run a reaper pass: mark stale processing jobs as failed.
 *
 * Iterates per-type timeouts first (ingest, preview, save, etc.), then
 * sweeps remaining types with the default timeout.
 *
 * @param store - The JobStore to query and update
 * @param timeouts - Per-type timeout map; 'default' key used as fallback
 * @returns Total number of jobs marked as failed
 */
export async function runReaper(
  store: JobStore,
  timeouts: Record<string, number>,
): Promise<number> {
  let total = 0;
  const handledTypes = new Set<string>();

  // Pass 1: Per-type timeouts
  for (const [type, timeoutMs] of Object.entries(timeouts)) {
    if (type === 'default') continue;
    handledTypes.add(type);
    const count = await store.markStaleJobsFailed(timeoutMs, type as 'ingest' | 'preview' | 'save' | 'render');
    total += count;
  }

  // Pass 2: Default timeout for any remaining types not explicitly configured
  const defaultTimeout = timeouts.default || 600_000;
  const remainingCount = await store.markStaleJobsFailed(defaultTimeout);
  // The default pass may double-count types already handled, but since
  // those jobs were already marked failed in Pass 1, the WHERE clause
  // (status='processing') means they won't match again. Safe overlap.
  total += remainingCount;

  if (total > 0) {
    console.log(`[Reaper] Marked ${total} stale job(s) as failed`);
  }

  return total;
}
```

Wait — the "safe overlap" comment above is correct: Pass 1 marks matching jobs as failed (status changes from 'processing' to 'failed'), so Pass 2's WHERE status='processing' won't re-match them. However, Pass 2 WILL also catch jobs of types that were already handled in Pass 1 but with a SHORTER default timeout. This could mark a job failed too early if the default is shorter than the per-type timeout.

Better approach: Skip Pass 2 entirely if all known types are covered. OR, only apply the default to types NOT already handled. Since the SQL cannot easily do "type NOT IN (...)" without knowing which types exist, the simplest correct approach is:

- For each type in the timeouts map (excluding 'default'), call markStaleJobsFailed with that type's timeout and type filter.
- Then call markStaleJobsFailed WITHOUT a type filter using the default timeout. Since Pass 1 already failed the matching typed jobs, the default pass only catches: (a) types not in the map (like 'render' if not configured), and (b) the same typed jobs that ALSO exceed the default timeout (which is a no-op since they're already failed).

Actually this IS correct as-is. A job of type 'save' with a 15-min timeout: Pass 1 marks it failed after 15 min. Pass 2 with 10-min default finds no 'save' processing jobs (they're already failed). No early failures possible.

But what about the reverse? A job of type 'preview' with 5-min timeout is handled in Pass 1 at 5 min. Pass 2 at 10 min would find no preview jobs still processing (they were failed at 5 min). Correct.

The implementation above is correct. Use it as written.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify the reaper compiles against the updated interface. Verify the reaper file contains `Object.entries(timeouts)` loop and per-type `markStaleJobsFailed` calls.
  </verify>
  <done>
Reaper calls `markStaleJobsFailed` with per-type timeouts: ingest at 10min, preview at 5min, save at 15min. Unconfigured types fall back to default (10min). No job type uses an incorrect timeout.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors across all four modified files
2. `markStaleJobsFailed` in types.ts accepts optional `type` parameter
3. Both LocalJobStore and TursoJobStore add `AND type = ?` when type is provided
4. worker/reaper.ts iterates over JOB_TIMEOUTS entries and calls markStaleJobsFailed per type
5. worker/index.ts is NOT modified (existing JOB_TIMEOUTS config and runReaper call are already correct)
</verification>

<success_criteria>
- Preview jobs stuck >5 minutes are reaped (not waiting 10 minutes like before)
- Save jobs stuck >15 minutes are reaped (not prematurely at 10 minutes)
- Ingest jobs still reap at 10 minutes (unchanged effective behavior, now explicit)
- Unconfigured job types (e.g., render) reap at the default 10-minute timeout
- All TypeScript types compile cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/18-api-completeness-timeout-accuracy/18-02-SUMMARY.md`
</output>
