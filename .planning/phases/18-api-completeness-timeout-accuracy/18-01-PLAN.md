---
phase: 18-api-completeness-timeout-accuracy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - "src/app/api/audio/jobs/[jobId]/route.ts"
  - "src/app/api/render/route.ts"
autonomous: true
requirements:
  - API-02

must_haves:
  truths:
    - "Poll response for a completed ingest job includes a downloadUrl pointing to /api/audio/assets/<assetId>/stream"
    - "Poll response for completed preview, save, and render jobs still includes downloadUrl (no regression)"
    - "GET /api/render returns the actual render job list from getJobStore() with type=render filter"
  artifacts:
    - path: "src/app/api/audio/jobs/[jobId]/route.ts"
      provides: "assetId branch in downloadUrl resolution"
      contains: "result.assetId"
    - path: "src/app/api/render/route.ts"
      provides: "GET handler using getJobStore().list({ type: 'render' })"
      contains: "getJobStore"
  key_links:
    - from: "src/app/api/audio/jobs/[jobId]/route.ts"
      to: "/api/audio/assets/{assetId}/stream"
      via: "URL synthesis from result.assetId"
      pattern: "api/audio/assets.*stream"
    - from: "src/app/api/render/route.ts"
      to: "src/lib/jobs/index.ts"
      via: "getJobStore() factory import"
      pattern: "getJobStore"
---

<objective>
Add the missing assetId-to-downloadUrl branch in the poll endpoint for completed ingest jobs, and rewrite GET /api/render to read from getJobStore() instead of the legacy in-memory ServerJobStore.

Purpose: Closes GAP-01 (render list always empty) and GAP-02 (ingest jobs have no downloadUrl) from the v2.0 milestone audit. Completes requirement API-02: poll endpoint returns download URL on completion for ALL job types.

Output: Two files modified — poll endpoint has full downloadUrl coverage, render list returns real jobs.
</objective>

<execution_context>
@C:/Users/jonch/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jonch/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/v2.0-MILESTONE-AUDIT.md
@src/app/api/audio/jobs/[jobId]/route.ts
@src/app/api/render/route.ts
@src/lib/jobs/types.ts
@src/lib/jobs/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add assetId downloadUrl branch to poll endpoint</name>
  <files>src/app/api/audio/jobs/[jobId]/route.ts</files>
  <action>
In the poll endpoint GET handler, the `storageKey` resolution block (lines 65-68) checks `result.videoKey`, `result.previewKey`, and `result.preparedKey` — but NOT `result.assetId`. The ingest pipeline (`worker/pipelines/ingest.ts`) stores `result.assetId` on completion. No signed R2 URL is needed for ingest results because the asset is served via the streaming endpoint.

Add an `else if` branch AFTER the existing `storageKey` resolution that checks for `result.assetId`. When present, synthesize the downloadUrl as a relative URL: `/api/audio/assets/${result.assetId}/stream`.

Specific change to the block starting at line 64:

```typescript
// Generate a signed download URL if the result contains a storage key.
// Workers store results with keys like previewKey, preparedKey, videoKey, or assetId.
const storageKey =
  (job.result.videoKey as string | undefined) ||
  (job.result.previewKey as string | undefined) ||
  (job.result.preparedKey as string | undefined);

if (storageKey) {
  try {
    const storage = getStorageAdapter();
    const expirySeconds = job.result.videoKey ? 7 * 24 * 3600 : undefined;
    response.downloadUrl = await storage.getSignedUrl(storageKey, expirySeconds);
  } catch {
    // Non-fatal
  }
} else if (job.result.assetId) {
  // Ingest jobs store an assetId — serve via the streaming endpoint
  response.downloadUrl = `/api/audio/assets/${job.result.assetId}/stream`;
}
```

This is the ONLY change to this file. Do NOT modify the JobPollResponse interface (downloadUrl is already an optional string field).
  </action>
  <verify>
Run `npx tsc --noEmit` to verify types compile. Grep the file for `result.assetId` to confirm the branch exists.
  </verify>
  <done>
Poll response for a completed ingest job with `result.assetId` includes `downloadUrl` pointing to `/api/audio/assets/<assetId>/stream`. Existing preview/save/render downloadUrl behavior is unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite GET /api/render to use getJobStore()</name>
  <files>src/app/api/render/route.ts</files>
  <action>
The current GET handler (lines 312-383) calls `ServerJobStore.list()` and `ServerJobStore.getStatusCounts()`. ServerJobStore is a legacy in-memory singleton from Phase 3/4 that is never populated by the v2.0 job flow. This means the render list always returns empty.

Rewrite the GET handler to use `getJobStore().list({ type: 'render' })` from `@/lib/jobs`. The JobStore `list()` method accepts `ListOptions` with `status`, `type`, and `limit` fields. It returns `AudioPrepJob[]`.

The existing response shape (`ListJobsResponse`) expects `RenderJobSummary[]`, pagination, and summary counts. Since the JobStore does not have pagination or status counts natively, adapt as follows:

1. Call `getJobStore().list({ type: 'render' })` to get all render jobs (no limit in store call — we paginate in-memory after).
2. Apply status filter from query params (if provided) in-memory.
3. Sort by createdAt descending (default) or by the requested sortBy/sortOrder.
4. Compute pagination (total, offset, limit, hasMore) from the filtered list.
5. Compute status summary by counting statuses across the full (pre-paginated) list. Map AudioPrepJob statuses to the RenderJobSummary statuses. The legacy `JobStatus` type has many states (queued, analyzing, etc.) but AudioPrepJob only uses 5 (pending, processing, complete, failed, cancelled). Map `processing` -> `rendering` and `complete` -> `completed` for the summary counts, or simplify the summary to only include AudioPrepJob statuses.
6. Map each `AudioPrepJob` to `RenderJobSummary` shape: `{ id: job.jobId, batchId: null, status: mapStatus(job.status), progress: job.progress, currentStage: job.stage || 'Unknown', audioName: job.metadata.audioName || 'Unknown', outputFormat: job.metadata.outputFormat || 'unknown', createdAt: job.createdAt, completedAt: job.status === 'complete' ? job.updatedAt : null, errorMessage: job.error || null }`.

The status mapping function should map: pending->pending, processing->rendering, complete->completed, failed->failed, cancelled->cancelled.

Remove the `ServerJobStore` import since it is no longer used by the GET handler. The POST handler already uses `getJobStore()` so `ServerJobStore` may still be imported — check if POST uses it. Looking at the current code: POST does NOT use ServerJobStore (it uses getJobStore()), so the `ServerJobStore` import can be removed entirely.

IMPORTANT: Do NOT change the POST handler. Only rewrite the GET handler and clean up unused imports.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify types compile. Run `grep -n "ServerJobStore" src/app/api/render/route.ts` to confirm it is no longer imported. Run `grep -n "getJobStore" src/app/api/render/route.ts` to confirm it is used in GET.
  </verify>
  <done>
GET /api/render returns render jobs from getJobStore() (not empty in-memory store). Response shape matches existing ListJobsResponse contract. POST handler is unchanged.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors in either modified file
2. Poll endpoint code has `result.assetId` branch that synthesizes `/api/audio/assets/{assetId}/stream` URL
3. GET /api/render imports and calls `getJobStore().list({ type: 'render' })`
4. ServerJobStore is no longer imported in `src/app/api/render/route.ts`
5. POST /api/render is unchanged
</verification>

<success_criteria>
- Poll response for completed ingest jobs with assetId includes downloadUrl
- Poll response for completed preview/save/render jobs still includes downloadUrl (no regression)
- GET /api/render returns real render jobs from the shared JobStore
- All TypeScript types compile cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/18-api-completeness-timeout-accuracy/18-01-SUMMARY.md`
</output>
