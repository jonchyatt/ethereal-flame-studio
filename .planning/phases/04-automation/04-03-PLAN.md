---
phase: 04-automation
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - src/lib/queue/renderWorker.ts
  - src/lib/queue/postProcessor.ts
  - scripts/start-worker.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Queued render jobs are processed automatically"
    - "Render status updates in SQLite as job progresses"
    - "Completed renders have correct file names"
    - "Failed jobs retry with exponential backoff"
  artifacts:
    - path: "src/lib/queue/renderWorker.ts"
      provides: "BullMQ worker that processes render jobs"
      exports: ["startWorker", "stopWorker"]
    - path: "src/lib/queue/postProcessor.ts"
      provides: "Post-render operations (naming, metadata)"
      exports: ["postProcessRender"]
    - path: "scripts/start-worker.ts"
      provides: "CLI entry point for worker process"
  key_links:
    - from: "src/lib/queue/renderWorker.ts"
      to: "src/lib/db/index.ts"
      via: "status updates"
      pattern: "updateRender"
    - from: "src/lib/queue/postProcessor.ts"
      to: "src/lib/utils/fileNaming.ts"
      via: "file name generation"
      pattern: "generateFileName"
---

<objective>
Create BullMQ worker to process render jobs from the queue.

Purpose: Automatically process queued render jobs, update metadata in SQLite, and apply file naming conventions. This is the execution engine that turns batch requests into rendered videos.

Output: Worker process that consumes render jobs, integrates with Phase 3 rendering pipeline (stubbed for now), and handles post-processing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-automation/04-RESEARCH.md
@.planning/phases/04-automation/04-01-SUMMARY.md (when exists)
@.planning/phases/04-automation/04-02-SUMMARY.md (when exists)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create post-processor for render output</name>
  <files>src/lib/queue/postProcessor.ts</files>
  <action>
Create `src/lib/queue/postProcessor.ts`:

```typescript
import { rename, stat } from 'fs/promises';
import { join, dirname } from 'path';
import { generateFileName } from '@/lib/utils/fileNaming';
import { updateRender, getRenderById } from '@/lib/db';

export interface PostProcessResult {
  finalPath: string;
  fileName: string;
  fileSizeBytes: number;
}

export async function postProcessRender(
  renderDbId: string,
  tempOutputPath: string
): Promise<PostProcessResult> {
  // Get render details from database
  const render = getRenderById(renderDbId);
  if (!render) {
    throw new Error(`Render not found: ${renderDbId}`);
  }

  // Generate proper file name
  const fileName = generateFileName(
    render.audio_name,
    render.output_format,
    new Date(render.created_at)
  );

  // Determine output directory (same as temp for now, configurable later)
  const outputDir = process.env.RENDER_OUTPUT_DIR || dirname(tempOutputPath);
  const finalPath = join(outputDir, fileName);

  // Rename temp file to final name
  await rename(tempOutputPath, finalPath);

  // Get file size
  const stats = await stat(finalPath);

  // Update database with final path
  updateRender(renderDbId, {
    output_path: finalPath,
    status: 'completed',
    render_completed_at: new Date().toISOString(),
  });

  return {
    finalPath,
    fileName,
    fileSizeBytes: stats.size,
  };
}

export async function markRenderFailed(
  renderDbId: string,
  errorMessage: string
): Promise<void> {
  updateRender(renderDbId, {
    status: 'failed',
    error_message: errorMessage,
    render_completed_at: new Date().toISOString(),
  });
}

export async function markRenderProcessing(renderDbId: string): Promise<void> {
  updateRender(renderDbId, {
    status: 'processing',
    render_started_at: new Date().toISOString(),
  });
}
```

This handles:
- Generating standardized file name from render metadata
- Renaming temp output to final path
- Updating SQLite with completion status
- Error handling with proper status updates
  </action>
  <verify>
Unit test:
```typescript
import { generateFileName } from '@/lib/utils/fileNaming';

// Verify naming integrates correctly
const name = generateFileName('Test Audio', '1080p', new Date('2026-01-27'));
console.log(name); // 20260127_test_audio_1080p_v1.mp4
```

Integration test requires mock render output (tested in Task 2).
  </verify>
  <done>
Post-processor handles file naming, renaming, and database updates for completed renders.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BullMQ render worker</name>
  <files>src/lib/queue/renderWorker.ts</files>
  <action>
Create `src/lib/queue/renderWorker.ts`:

```typescript
import { Worker, Job } from 'bullmq';
import { redisConnection } from './connection';
import { RenderJobData } from './types';
import { insertRender, updateRender } from '@/lib/db';
import { postProcessRender, markRenderFailed, markRenderProcessing } from './postProcessor';

let worker: Worker<RenderJobData> | null = null;

async function processRenderJob(job: Job<RenderJobData>): Promise<void> {
  const { batchId, audioFile, template, outputFormat } = job.data;

  console.log(`[Worker] Processing job ${job.id}: ${audioFile.originalName} -> ${outputFormat}`);

  // Create database record if not exists
  let renderDbId = job.data.renderDbId;
  if (!renderDbId) {
    const render = insertRender({
      batch_id: batchId,
      audio_name: audioFile.originalName.replace(/\.[^/.]+$/, ''), // Remove extension
      audio_path: audioFile.path,
      template,
      output_format: outputFormat,
    });
    renderDbId = render.id;

    // Update job data with DB ID for potential retries
    await job.updateData({ ...job.data, renderDbId });
  }

  try {
    // Mark as processing
    await markRenderProcessing(renderDbId);
    await job.updateProgress(10);

    // TODO: Replace with actual render call from Phase 3
    // For now, simulate rendering with delay
    const tempOutputPath = await simulateRender(
      audioFile.path,
      template,
      outputFormat,
      (progress) => job.updateProgress(10 + progress * 0.8) // 10-90% for render
    );

    await job.updateProgress(90);

    // Post-process: rename, update metadata
    const result = await postProcessRender(renderDbId, tempOutputPath);

    await job.updateProgress(100);

    console.log(`[Worker] Completed: ${result.fileName} (${(result.fileSizeBytes / 1024 / 1024).toFixed(1)} MB)`);

  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    console.error(`[Worker] Failed job ${job.id}:`, message);
    await markRenderFailed(renderDbId, message);
    throw error; // Re-throw for BullMQ retry handling
  }
}

// Temporary simulation - replace with Phase 3 render pipeline
async function simulateRender(
  audioPath: string,
  template: string,
  format: string,
  onProgress: (progress: number) => void
): Promise<string> {
  const steps = 10;
  for (let i = 0; i < steps; i++) {
    await new Promise(r => setTimeout(r, 500)); // 5 seconds total
    onProgress((i + 1) / steps);
  }

  // Create a dummy output file for testing
  const { writeFile } = await import('fs/promises');
  const tempPath = `/tmp/render_${Date.now()}.mp4`;
  await writeFile(tempPath, `Simulated render: ${audioPath} -> ${template} -> ${format}`);

  return tempPath;
}

export function startWorker(): Worker<RenderJobData> {
  if (worker) {
    console.warn('[Worker] Already running');
    return worker;
  }

  worker = new Worker<RenderJobData>('render-queue', processRenderJob, {
    connection: redisConnection,
    concurrency: 1, // Process one job at a time (GPU-bound)
    lockDuration: 300000, // 5 minutes lock (long renders)
  });

  worker.on('completed', (job) => {
    console.log(`[Worker] Job ${job.id} completed`);
  });

  worker.on('failed', (job, err) => {
    console.error(`[Worker] Job ${job?.id} failed:`, err.message);
  });

  worker.on('error', (err) => {
    console.error('[Worker] Error:', err);
  });

  console.log('[Worker] Started, waiting for jobs...');
  return worker;
}

export async function stopWorker(): Promise<void> {
  if (worker) {
    await worker.close();
    worker = null;
    console.log('[Worker] Stopped');
  }
}
```

Key design decisions:
- `concurrency: 1` - Only one render at a time (GPU is the bottleneck)
- `lockDuration: 300000` - 5 minute lock for long renders
- Progress updates at 10%, 10-90%, 90%, 100% stages
- Database record created on first attempt, reused on retries
- simulateRender is a placeholder for Phase 3 integration
  </action>
  <verify>
Integration test (requires Redis running):
```bash
# Terminal 1: Start worker
npx ts-node scripts/start-worker.ts

# Terminal 2: Add test job
npx ts-node -e "
const { addBatchJob } = require('./src/lib/queue/renderQueue');
addBatchJob(
  [{ id: 'test-1', path: '/tmp/test.mp3', originalName: 'Test Audio.mp3' }],
  'flame',
  ['1080p']
).then(console.log);
"
```

Worker should:
1. Pick up the job
2. Show progress logs
3. Create database record
4. Complete with proper file name
  </verify>
  <done>
Worker processes render jobs, updates progress, creates database records, handles failures with retry.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create worker CLI script</name>
  <files>scripts/start-worker.ts, package.json</files>
  <action>
Create `scripts/start-worker.ts`:

```typescript
#!/usr/bin/env node
import { startWorker, stopWorker } from '../src/lib/queue/renderWorker';
import { setupGracefulShutdown } from '../src/lib/queue/shutdown';

console.log('Starting Ethereal Flame render worker...');

// Setup graceful shutdown
setupGracefulShutdown();

// Override shutdown to also stop worker
const originalExit = process.exit;
process.on('SIGTERM', async () => {
  console.log('Stopping worker...');
  await stopWorker();
});
process.on('SIGINT', async () => {
  console.log('Stopping worker...');
  await stopWorker();
});

// Start the worker
startWorker();

console.log('Worker running. Press Ctrl+C to stop.');
```

Update `package.json` scripts:
```json
{
  "scripts": {
    "worker": "ts-node scripts/start-worker.ts",
    "worker:prod": "node dist/scripts/start-worker.js"
  }
}
```

This provides a dedicated CLI entry point for running the worker independently of the web server.
  </action>
  <verify>
```bash
npm run worker
# Should output:
# Starting Ethereal Flame render worker...
# [Worker] Started, waiting for jobs...
# Worker running. Press Ctrl+C to stop.

# Ctrl+C should show:
# Stopping worker...
# [Worker] Stopped
```
  </verify>
  <done>
Worker can be started via `npm run worker`, handles graceful shutdown on Ctrl+C.
  </done>
</task>

</tasks>

<verification>
1. `npm run worker` starts the worker process
2. Worker picks up jobs from Redis queue
3. Job progress updates visible (10%, then incremental, then 100%)
4. Completed renders have correct file names in database
5. Failed jobs show error message in database
6. Worker gracefully shuts down on Ctrl+C
7. Database record created/updated through job lifecycle
</verification>

<success_criteria>
- Worker processes render jobs sequentially (concurrency: 1)
- Database records created and updated at each stage
- File naming convention applied via post-processor
- Failed jobs recorded with error message
- Worker has dedicated CLI entry point
- Graceful shutdown prevents orphaned jobs
- Ready for Phase 3 render pipeline integration (currently simulated)
</success_criteria>

<output>
After completion, create `.planning/phases/04-automation/04-03-SUMMARY.md`
</output>
