---
phase: 04-automation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/queue/connection.ts
  - src/lib/queue/renderQueue.ts
  - src/lib/queue/types.ts
  - docker-compose.yml
autonomous: true
user_setup:
  - service: redis
    why: "BullMQ requires Redis for job persistence"
    dashboard_config:
      - task: "Start Redis via Docker"
        location: "Run: docker-compose up -d redis"

must_haves:
  truths:
    - "User can queue multiple audio files for batch processing"
    - "Jobs persist across server restarts"
    - "Queue shows job status (pending, processing, completed, failed)"
  artifacts:
    - path: "src/lib/queue/renderQueue.ts"
      provides: "BullMQ queue for batch render jobs"
      exports: ["renderQueue", "addBatchJob", "addRenderJob"]
    - path: "src/lib/queue/connection.ts"
      provides: "Redis connection configuration"
      exports: ["redisConnection"]
    - path: "docker-compose.yml"
      provides: "Redis service for development"
      contains: "redis:"
  key_links:
    - from: "src/lib/queue/renderQueue.ts"
      to: "src/lib/queue/connection.ts"
      via: "Redis connection"
      pattern: "import.*connection"
    - from: "src/lib/queue/renderQueue.ts"
      to: "bullmq"
      via: "job queue"
      pattern: "new Queue"
---

<objective>
Set up BullMQ batch queue infrastructure for processing multiple audio files.

Purpose: Enable users to upload multiple audio files and have them processed sequentially or in batches. Jobs persist in Redis so renders survive browser close and server restarts.

Output: Redis Docker setup, BullMQ queue with batch job support, job type definitions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-automation/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up Redis with Docker Compose</name>
  <files>docker-compose.yml</files>
  <action>
Create or update `docker-compose.yml`:

```yaml
version: '3.8'

services:
  redis:
    image: redis:7-alpine
    container_name: ethereal-redis
    command: redis-server --maxmemory-policy noeviction --appendonly yes
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  redis-data:
```

Key settings:
- `maxmemory-policy noeviction`: CRITICAL for BullMQ - prevents Redis from evicting job data
- `appendonly yes`: Persistence to disk
- `redis:7-alpine`: Lightweight, production-ready
- Health check for container orchestration

Add to `.env.example`:
```
REDIS_URL=redis://localhost:6379
```
  </action>
  <verify>
```bash
docker-compose up -d redis
docker-compose ps
# redis should show as "healthy" or "running"

docker exec ethereal-redis redis-cli ping
# Should return PONG

docker exec ethereal-redis redis-cli CONFIG GET maxmemory-policy
# Should return "noeviction"
```
  </verify>
  <done>
Redis container running with noeviction policy, persistence enabled, health checks passing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BullMQ queue infrastructure</name>
  <files>src/lib/queue/connection.ts, src/lib/queue/types.ts, src/lib/queue/renderQueue.ts</files>
  <action>
Install BullMQ:
```bash
npm install bullmq
```

Create `src/lib/queue/connection.ts`:
```typescript
import { ConnectionOptions } from 'bullmq';

export const redisConnection: ConnectionOptions = {
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  maxRetriesPerRequest: null, // Required for BullMQ workers
};
```

Create `src/lib/queue/types.ts`:
```typescript
export interface AudioFile {
  id: string;
  path: string;
  originalName: string;
}

export interface BatchJobData {
  batchId: string;
  audioFiles: AudioFile[];
  template: string;
  outputFormats: string[]; // ['1080p', '4k', '360stereo']
  createdAt: string;
}

export interface RenderJobData {
  batchId: string;
  audioFile: AudioFile;
  template: string;
  outputFormat: string;
  renderDbId: string; // ID in SQLite renders table
}

export type JobStatus = 'pending' | 'processing' | 'completed' | 'failed';
```

Create `src/lib/queue/renderQueue.ts`:
```typescript
import { Queue, QueueEvents, Job } from 'bullmq';
import { redisConnection } from './connection';
import { BatchJobData, RenderJobData, AudioFile } from './types';
import { v4 as uuid } from 'uuid';

export const renderQueue = new Queue<RenderJobData>('render-queue', {
  connection: redisConnection,
  defaultJobOptions: {
    removeOnComplete: { count: 100 }, // Keep last 100 completed
    removeOnFail: { count: 500 },     // Keep failed for debugging
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 10000, // 10s initial, then 20s, 40s
    },
  },
});

export const queueEvents = new QueueEvents('render-queue', {
  connection: redisConnection,
});

export async function addBatchJob(
  audioFiles: AudioFile[],
  template: string,
  outputFormats: string[]
): Promise<{ batchId: string; jobIds: string[] }> {
  const batchId = uuid();
  const jobIds: string[] = [];

  // Create individual render jobs for each audio/format combination
  for (const audioFile of audioFiles) {
    for (const format of outputFormats) {
      const job = await renderQueue.add(
        'render',
        {
          batchId,
          audioFile,
          template,
          outputFormat: format,
          renderDbId: '', // Set by worker after DB insert
        },
        {
          jobId: `${batchId}-${audioFile.id}-${format}`,
        }
      );
      jobIds.push(job.id || '');
    }
  }

  return { batchId, jobIds };
}

export async function getJobStatus(jobId: string): Promise<{
  state: string;
  progress: number;
  failedReason?: string;
} | null> {
  const job = await renderQueue.getJob(jobId);
  if (!job) return null;

  return {
    state: await job.getState(),
    progress: job.progress as number || 0,
    failedReason: job.failedReason,
  };
}

export async function getBatchStatus(batchId: string): Promise<{
  total: number;
  completed: number;
  failed: number;
  pending: number;
  processing: number;
}> {
  const jobs = await renderQueue.getJobs(['waiting', 'active', 'completed', 'failed']);
  const batchJobs = jobs.filter(j => j.data.batchId === batchId);

  const states = await Promise.all(batchJobs.map(j => j.getState()));

  return {
    total: batchJobs.length,
    completed: states.filter(s => s === 'completed').length,
    failed: states.filter(s => s === 'failed').length,
    pending: states.filter(s => s === 'waiting' || s === 'delayed').length,
    processing: states.filter(s => s === 'active').length,
  };
}

// Graceful shutdown helper
export async function closeQueue(): Promise<void> {
  await renderQueue.close();
  await queueEvents.close();
}
```

Install uuid for batch IDs:
```bash
npm install uuid
npm install -D @types/uuid
```
  </action>
  <verify>
Create test script `scripts/test-queue.ts`:
```typescript
import { addBatchJob, getBatchStatus, closeQueue } from '../src/lib/queue/renderQueue';

async function test() {
  // Add a test batch
  const result = await addBatchJob(
    [{ id: 'test-1', path: '/tmp/test.mp3', originalName: 'test.mp3' }],
    'flame',
    ['1080p', '4k']
  );
  console.log('Batch created:', result.batchId);
  console.log('Jobs created:', result.jobIds.length);

  // Check status
  const status = await getBatchStatus(result.batchId);
  console.log('Status:', status);
  // { total: 2, completed: 0, failed: 0, pending: 2, processing: 0 }

  await closeQueue();
}

test().catch(console.error);
```

Run:
```bash
npx ts-node scripts/test-queue.ts
```

Verify jobs appear in Redis:
```bash
docker exec ethereal-redis redis-cli KEYS "bull:render-queue:*"
```
  </verify>
  <done>
BullMQ queue initialized, batch job creation works, job status queryable, jobs persist in Redis.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add queue graceful shutdown</name>
  <files>src/lib/queue/shutdown.ts</files>
  <action>
Create `src/lib/queue/shutdown.ts`:

```typescript
import { closeQueue } from './renderQueue';

let isShuttingDown = false;

export function setupGracefulShutdown(): void {
  const shutdown = async (signal: string) => {
    if (isShuttingDown) return;
    isShuttingDown = true;

    console.log(`\n[${signal}] Graceful shutdown initiated...`);

    try {
      // Close queue connections (waits for active jobs)
      await closeQueue();
      console.log('Queue connections closed');

      process.exit(0);
    } catch (error) {
      console.error('Error during shutdown:', error);
      process.exit(1);
    }
  };

  process.on('SIGTERM', () => shutdown('SIGTERM'));
  process.on('SIGINT', () => shutdown('SIGINT'));
}
```

This prevents stalled jobs when the server restarts - BullMQ will wait for the current job to complete before exiting.

Update exports in `src/lib/queue/index.ts`:
```typescript
export * from './connection';
export * from './types';
export * from './renderQueue';
export * from './shutdown';
```
  </action>
  <verify>
Manual test:
1. Start a long-running job simulation
2. Send SIGINT (Ctrl+C)
3. Verify "Graceful shutdown initiated" message appears
4. Verify process waits briefly then exits cleanly
  </verify>
  <done>
Graceful shutdown handlers registered, queue closes cleanly on SIGTERM/SIGINT, prevents stalled jobs.
  </done>
</task>

</tasks>

<verification>
1. `docker-compose up -d redis` starts Redis with correct configuration
2. Redis ping returns PONG
3. BullMQ queue can add and query jobs
4. Jobs persist in Redis (visible via redis-cli KEYS)
5. Batch job creates correct number of individual render jobs (audioFiles x formats)
6. Graceful shutdown waits for queue to close
</verification>

<success_criteria>
- Redis running in Docker with noeviction policy and persistence
- BullMQ queue operational with retry logic (3 attempts, exponential backoff)
- Batch jobs create individual render jobs for each audio/format combination
- Job status queryable (pending, processing, completed, failed)
- Graceful shutdown prevents stalled jobs
- Foundation ready for worker implementation
</success_criteria>

<output>
After completion, create `.planning/phases/04-automation/04-02-SUMMARY.md`
</output>
