---
phase: 04-automation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/lib/db/index.ts
  - src/lib/utils/fileNaming.ts
  - src/lib/utils/fileNaming.test.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Completed renders have standardized file names"
    - "All render metadata is queryable in SQLite"
    - "File names follow [YYYYMMDD]_[AudioName]_[Format]_vN.mp4 convention"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "SQLite schema definition for renders table"
      contains: "CREATE TABLE renders"
    - path: "src/lib/db/index.ts"
      provides: "Database connection and query functions"
      exports: ["db", "insertRender", "updateRender", "getRendersByBatch"]
    - path: "src/lib/utils/fileNaming.ts"
      provides: "File naming convention utilities"
      exports: ["generateFileName", "sanitizeName", "parseFileName"]
  key_links:
    - from: "src/lib/db/index.ts"
      to: "better-sqlite3"
      via: "database driver"
      pattern: "require.*better-sqlite3"
    - from: "src/lib/utils/fileNaming.ts"
      to: "render jobs"
      via: "called during post-processing"
      pattern: "generateFileName"
---

<objective>
Set up SQLite metadata database and file naming convention utilities.

Purpose: Foundation for tracking all batch renders and ensuring consistent file organization. These utilities are used by all subsequent automation features.

Output: SQLite database schema with renders table, database query helpers, and file naming utility functions with tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-automation/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQLite metadata database</name>
  <files>src/lib/db/schema.ts, src/lib/db/index.ts</files>
  <action>
Install better-sqlite3 as production dependency:
```bash
npm install better-sqlite3
npm install -D @types/better-sqlite3
```

Create `src/lib/db/schema.ts`:
- Define SQL schema string for renders table with columns:
  - id TEXT PRIMARY KEY (UUID)
  - batch_id TEXT (nullable, for grouping)
  - audio_name TEXT NOT NULL
  - audio_path TEXT NOT NULL
  - template TEXT NOT NULL
  - output_format TEXT NOT NULL (1080p, 4k, 360mono, 360stereo)
  - output_path TEXT (nullable, set after render)
  - gdrive_url TEXT (nullable, set after sync)
  - status TEXT DEFAULT 'pending' (pending, processing, completed, failed)
  - whisper_description TEXT (nullable, set after transcription)
  - duration_seconds REAL (nullable)
  - render_started_at TEXT (nullable)
  - render_completed_at TEXT (nullable)
  - error_message TEXT (nullable)
  - created_at TEXT DEFAULT CURRENT_TIMESTAMP
- Include CREATE INDEX statements for batch_id, status, created_at

Create `src/lib/db/index.ts`:
- Initialize database at `data/renders.db` using better-sqlite3
- Enable WAL mode for concurrent read safety: `db.pragma('journal_mode = WAL')`
- Run schema migration on init (CREATE TABLE IF NOT EXISTS)
- Export functions:
  - `insertRender(render: NewRender): Render` - inserts new record
  - `updateRender(id: string, updates: Partial<Render>): void` - partial update
  - `getRenderById(id: string): Render | null`
  - `getRendersByBatch(batchId: string): Render[]`
  - `getRendersByStatus(status: string): Render[]`
  - `getRecentRenders(limit: number): Render[]`

Important: Use synchronous better-sqlite3 API (not async). It's faster and simpler for this use case.
  </action>
  <verify>
Create test file that:
```typescript
import { insertRender, getRenderById, updateRender } from '@/lib/db';

const render = insertRender({
  audio_name: 'test',
  audio_path: '/tmp/test.mp3',
  template: 'flame',
  output_format: '1080p'
});
console.log('Inserted:', render.id);

updateRender(render.id, { status: 'processing' });
const updated = getRenderById(render.id);
console.log('Status:', updated?.status); // 'processing'
```
Run with ts-node and verify no errors, data persists in data/renders.db
  </verify>
  <done>
SQLite database initializes with WAL mode, renders table exists with all columns, CRUD operations work correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement file naming convention utilities</name>
  <files>src/lib/utils/fileNaming.ts, src/lib/utils/fileNaming.test.ts</files>
  <action>
Create `src/lib/utils/fileNaming.ts`:

```typescript
/**
 * File naming convention: [YYYYMMDD]_[AudioName]_[Format]_v[N].mp4
 * Examples:
 *   20260127_MorningMeditation_1080p_v1.mp4
 *   20260127_deep_space_ambient_4k_v2.mp4
 */

export function sanitizeName(name: string): string {
  // Remove file extension if present
  // Replace non-alphanumeric with underscores
  // Collapse multiple underscores
  // Lowercase
  // Trim underscores from ends
}

export function generateFileName(
  audioName: string,
  format: string,
  date?: Date,
  version?: number
): string {
  // Default date to now, version to 1
  // Format date as YYYYMMDD
  // Sanitize audio name
  // Return formatted string
}

export interface ParsedFileName {
  date: string;      // YYYYMMDD
  audioName: string; // sanitized name
  format: string;    // 1080p, 4k, 360mono, 360stereo
  version: number;   // 1, 2, 3...
}

export function parseFileName(fileName: string): ParsedFileName | null {
  // Parse existing file name back into components
  // Return null if doesn't match convention
}

export function getNextVersion(existingFiles: string[], baseName: string): number {
  // Find highest version number for same base name, return +1
}
```

Create `src/lib/utils/fileNaming.test.ts`:
- Test sanitizeName with various inputs (spaces, special chars, extensions)
- Test generateFileName output format
- Test parseFileName roundtrip
- Test getNextVersion increments correctly
  </action>
  <verify>
Run tests:
```bash
npm test -- fileNaming
```
All tests pass. Verify manually:
```typescript
import { generateFileName, parseFileName } from './fileNaming';
const name = generateFileName('Morning Meditation!!.mp3', '1080p');
console.log(name); // 20260127_morning_meditation_1080p_v1.mp4
const parsed = parseFileName(name);
console.log(parsed); // { date: '20260127', audioName: 'morning_meditation', format: '1080p', version: 1 }
```
  </verify>
  <done>
File naming utilities correctly sanitize names, generate convention-compliant file names, and can parse them back. All edge cases handled (special chars, spaces, extensions).
  </done>
</task>

<task type="auto">
  <name>Task 3: Add .gitignore entries and create data directory</name>
  <files>.gitignore, data/.gitkeep</files>
  <action>
Update `.gitignore` to include:
```
# Database files
data/*.db
data/*.db-wal
data/*.db-shm

# Keep the data directory structure
!data/.gitkeep
```

Create `data/.gitkeep` (empty file) to ensure the data directory exists in git but database files are ignored.

This prevents accidental commit of SQLite database while ensuring the directory structure exists for fresh clones.
  </action>
  <verify>
```bash
git status
# data/.gitkeep should be untracked (to be added)
# data/renders.db should NOT appear (ignored)

# Create test db to verify ignore works
touch data/renders.db
git status
# renders.db should not show
```
  </verify>
  <done>
Database files are gitignored, data directory structure preserved with .gitkeep.
  </done>
</task>

</tasks>

<verification>
1. `npm test -- fileNaming` passes all tests
2. `data/renders.db` file can be created and queried
3. Database operations (insert, update, query) work correctly
4. File naming generates consistent format: `YYYYMMDD_name_format_vN.mp4`
5. `.gitignore` properly excludes database files
</verification>

<success_criteria>
- SQLite database initializes with renders table schema
- WAL mode enabled for concurrent access safety
- File naming follows [YYYYMMDD]_[AudioName]_[Format]_vN.mp4 convention
- All naming edge cases handled (special chars, spaces, extensions)
- Database files are gitignored
- Foundation ready for batch queue implementation
</success_criteria>

<output>
After completion, create `.planning/phases/04-automation/04-01-SUMMARY.md`
</output>
