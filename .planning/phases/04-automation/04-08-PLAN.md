---
phase: 04-automation
plan: 08
type: execute
wave: 4
depends_on: ["04-01", "04-05", "04-06"]
files_modified:
  - src/lib/services/googleSheets.ts
  - src/lib/db/export.ts
  - src/app/api/export/sheets/route.ts
autonomous: true
user_setup:
  - service: google-sheets
    why: "Export metadata to Google Sheets for visibility"
    env_vars:
      - name: GOOGLE_SERVICE_ACCOUNT_EMAIL
        source: "Google Cloud Console > IAM > Service Accounts"
      - name: GOOGLE_PRIVATE_KEY
        source: "Service account JSON key file (copy private_key value)"
      - name: GOOGLE_SHEETS_ID
        source: "Spreadsheet ID from URL (docs.google.com/spreadsheets/d/{ID}/...)"
    dashboard_config:
      - task: "Create Google Cloud service account"
        location: "Google Cloud Console > IAM > Service Accounts > Create"
      - task: "Create and download JSON key for service account"
        location: "Service Account > Keys > Add Key > JSON"
      - task: "Share spreadsheet with service account email"
        location: "Google Sheets > Share > Add service account email with Editor access"

must_haves:
  truths:
    - "Render metadata exportable to Google Sheets"
    - "Export includes file names, status, descriptions, Google Drive URLs"
    - "Export can be triggered manually via API"
  artifacts:
    - path: "src/lib/services/googleSheets.ts"
      provides: "Google Sheets API integration"
      exports: ["exportToGoogleSheets", "appendToGoogleSheets"]
    - path: "src/app/api/export/sheets/route.ts"
      provides: "API endpoint for manual export trigger"
  key_links:
    - from: "src/lib/services/googleSheets.ts"
      to: "googleapis"
      via: "Sheets API"
      pattern: "google.sheets"
    - from: "src/lib/db/export.ts"
      to: "src/lib/services/googleSheets.ts"
      via: "data formatting"
      pattern: "exportToGoogleSheets"
---

<objective>
Implement Google Sheets export for render metadata visibility.

Purpose: Provides a human-readable view of all renders with descriptions, status, and Google Drive links. Useful for tracking, sharing with collaborators, and integration with other workflows.

Output: Google Sheets integration with on-demand export API.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-automation/04-RESEARCH.md
@.planning/phases/04-automation/04-01-SUMMARY.md (when exists)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Google Sheets service</name>
  <files>src/lib/services/googleSheets.ts</files>
  <action>
Install Google APIs:
```bash
npm install googleapis
```

Create `src/lib/services/googleSheets.ts`:

```typescript
import { google, sheets_v4 } from 'googleapis';

const SCOPES = ['https://www.googleapis.com/auth/spreadsheets'];

function getAuth() {
  const email = process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL;
  const key = process.env.GOOGLE_PRIVATE_KEY?.replace(/\\n/g, '\n');

  if (!email || !key) {
    throw new Error('Google Sheets credentials not configured');
  }

  return new google.auth.JWT({
    email,
    key,
    scopes: SCOPES,
  });
}

function getSheets(): sheets_v4.Sheets {
  const auth = getAuth();
  return google.sheets({ version: 'v4', auth });
}

export interface RenderRow {
  date: string;
  audioName: string;
  template: string;
  format: string;
  status: string;
  fileName: string;
  gdriveUrl: string;
  description: string;
  duration: string;
  batchId: string;
}

const HEADER_ROW = [
  'Date',
  'Audio Name',
  'Template',
  'Format',
  'Status',
  'File Name',
  'Google Drive URL',
  'Description',
  'Duration',
  'Batch ID',
];

export async function ensureSheetHeaders(
  spreadsheetId: string,
  sheetName: string = 'Renders'
): Promise<void> {
  const sheets = getSheets();

  // Check if sheet exists and has headers
  const response = await sheets.spreadsheets.values.get({
    spreadsheetId,
    range: `${sheetName}!A1:J1`,
  });

  if (!response.data.values || response.data.values.length === 0) {
    // Add headers
    await sheets.spreadsheets.values.update({
      spreadsheetId,
      range: `${sheetName}!A1:J1`,
      valueInputOption: 'RAW',
      requestBody: {
        values: [HEADER_ROW],
      },
    });
    console.log('[Sheets] Headers added');
  }
}

export async function appendToGoogleSheets(
  spreadsheetId: string,
  rows: RenderRow[],
  sheetName: string = 'Renders'
): Promise<number> {
  if (rows.length === 0) return 0;

  const sheets = getSheets();

  // Ensure headers exist
  await ensureSheetHeaders(spreadsheetId, sheetName);

  // Convert rows to array format
  const values = rows.map(row => [
    row.date,
    row.audioName,
    row.template,
    row.format,
    row.status,
    row.fileName,
    row.gdriveUrl,
    row.description,
    row.duration,
    row.batchId,
  ]);

  // Append rows
  const response = await sheets.spreadsheets.values.append({
    spreadsheetId,
    range: `${sheetName}!A:J`,
    valueInputOption: 'RAW',
    insertDataOption: 'INSERT_ROWS',
    requestBody: {
      values,
    },
  });

  const rowsAdded = response.data.updates?.updatedRows || 0;
  console.log(`[Sheets] Appended ${rowsAdded} rows`);
  return rowsAdded;
}

export async function exportToGoogleSheets(
  spreadsheetId: string,
  rows: RenderRow[],
  sheetName: string = 'Renders',
  clearExisting: boolean = false
): Promise<number> {
  const sheets = getSheets();

  if (clearExisting) {
    // Clear all data except headers
    await sheets.spreadsheets.values.clear({
      spreadsheetId,
      range: `${sheetName}!A2:J`,
    });
    console.log('[Sheets] Cleared existing data');
  }

  return appendToGoogleSheets(spreadsheetId, rows, sheetName);
}

export function isGoogleSheetsConfigured(): boolean {
  return Boolean(
    process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL &&
    process.env.GOOGLE_PRIVATE_KEY &&
    process.env.GOOGLE_SHEETS_ID
  );
}
```

Add to `.env.example`:
```
GOOGLE_SERVICE_ACCOUNT_EMAIL=service-account@project.iam.gserviceaccount.com
GOOGLE_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n"
GOOGLE_SHEETS_ID=your-spreadsheet-id-here
```
  </action>
  <verify>
Test script:
```typescript
import { appendToGoogleSheets, isGoogleSheetsConfigured } from './googleSheets';

if (!isGoogleSheetsConfigured()) {
  console.log('Google Sheets not configured');
  process.exit(0);
}

const testRows = [{
  date: '2026-01-27',
  audioName: 'Test Audio',
  template: 'flame',
  format: '1080p',
  status: 'completed',
  fileName: '20260127_test_audio_1080p_v1.mp4',
  gdriveUrl: 'https://drive.google.com/...',
  description: 'Test description',
  duration: '5:30',
  batchId: 'test-batch-123',
}];

const count = await appendToGoogleSheets(
  process.env.GOOGLE_SHEETS_ID!,
  testRows
);
console.log(`Added ${count} rows`);
```
  </verify>
  <done>
Google Sheets service appends render metadata with automatic header creation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create database export utilities</name>
  <files>src/lib/db/export.ts</files>
  <action>
Create `src/lib/db/export.ts`:

```typescript
import { getRecentRenders, getRendersByBatch, getRendersByStatus } from './index';
import { RenderRow, appendToGoogleSheets, exportToGoogleSheets, isGoogleSheetsConfigured } from '@/lib/services/googleSheets';
import { Render } from './types';

function formatDuration(seconds: number | null): string {
  if (!seconds) return '';
  const mins = Math.floor(seconds / 60);
  const secs = Math.round(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

function formatDate(isoDate: string): string {
  return isoDate.slice(0, 10);
}

function renderToRow(render: Render): RenderRow {
  return {
    date: formatDate(render.created_at),
    audioName: render.audio_name,
    template: render.template,
    format: render.output_format,
    status: render.status,
    fileName: render.output_path?.split('/').pop() || '',
    gdriveUrl: render.gdrive_url || '',
    description: render.whisper_description?.slice(0, 500) || '',
    duration: formatDuration(render.duration_seconds),
    batchId: render.batch_id || '',
  };
}

export interface ExportOptions {
  spreadsheetId?: string;
  sheetName?: string;
  clearExisting?: boolean;
}

export async function exportRecentToSheets(
  limit: number = 100,
  options: ExportOptions = {}
): Promise<{ exported: number; error?: string }> {
  if (!isGoogleSheetsConfigured()) {
    return { exported: 0, error: 'Google Sheets not configured' };
  }

  const spreadsheetId = options.spreadsheetId || process.env.GOOGLE_SHEETS_ID!;

  try {
    const renders = getRecentRenders(limit);
    const rows = renders.map(renderToRow);

    const exported = options.clearExisting
      ? await exportToGoogleSheets(spreadsheetId, rows, options.sheetName, true)
      : await appendToGoogleSheets(spreadsheetId, rows, options.sheetName);

    return { exported };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return { exported: 0, error: message };
  }
}

export async function exportBatchToSheets(
  batchId: string,
  options: ExportOptions = {}
): Promise<{ exported: number; error?: string }> {
  if (!isGoogleSheetsConfigured()) {
    return { exported: 0, error: 'Google Sheets not configured' };
  }

  const spreadsheetId = options.spreadsheetId || process.env.GOOGLE_SHEETS_ID!;

  try {
    const renders = getRendersByBatch(batchId);
    const rows = renders.map(renderToRow);

    const exported = await appendToGoogleSheets(spreadsheetId, rows, options.sheetName);
    return { exported };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return { exported: 0, error: message };
  }
}

export async function exportCompletedToSheets(
  options: ExportOptions = {}
): Promise<{ exported: number; error?: string }> {
  if (!isGoogleSheetsConfigured()) {
    return { exported: 0, error: 'Google Sheets not configured' };
  }

  const spreadsheetId = options.spreadsheetId || process.env.GOOGLE_SHEETS_ID!;

  try {
    const renders = getRendersByStatus('completed');
    const rows = renders.map(renderToRow);

    const exported = options.clearExisting
      ? await exportToGoogleSheets(spreadsheetId, rows, options.sheetName, true)
      : await appendToGoogleSheets(spreadsheetId, rows, options.sheetName);

    return { exported };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return { exported: 0, error: message };
  }
}
```

This provides multiple export modes:
- Recent renders (last N)
- Specific batch
- All completed renders
- Option to clear existing or append
  </action>
  <verify>
```typescript
import { exportRecentToSheets, exportBatchToSheets } from './export';

// Export last 50 renders
const result = await exportRecentToSheets(50);
console.log('Exported:', result.exported, result.error || '');

// Export specific batch
const batchResult = await exportBatchToSheets('batch-id-here');
console.log('Batch exported:', batchResult.exported);
```
  </verify>
  <done>
Database export utilities convert renders to sheet rows with formatting.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create API endpoint for manual export</name>
  <files>src/app/api/export/sheets/route.ts</files>
  <action>
Create `src/app/api/export/sheets/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { exportRecentToSheets, exportBatchToSheets, exportCompletedToSheets } from '@/lib/db/export';
import { isGoogleSheetsConfigured } from '@/lib/services/googleSheets';

export async function GET(request: NextRequest) {
  // Check configuration
  if (!isGoogleSheetsConfigured()) {
    return NextResponse.json(
      { error: 'Google Sheets not configured' },
      { status: 503 }
    );
  }

  return NextResponse.json({
    configured: true,
    endpoints: {
      'POST /api/export/sheets': 'Export renders to Google Sheets',
    },
    params: {
      type: 'recent | batch | completed',
      limit: 'number (for recent, default 100)',
      batchId: 'string (required for batch type)',
      clear: 'boolean (clear existing data first)',
    },
  });
}

export async function POST(request: NextRequest) {
  // Check configuration
  if (!isGoogleSheetsConfigured()) {
    return NextResponse.json(
      { error: 'Google Sheets not configured' },
      { status: 503 }
    );
  }

  try {
    const body = await request.json();
    const { type = 'recent', limit = 100, batchId, clear = false } = body;

    let result;

    switch (type) {
      case 'recent':
        result = await exportRecentToSheets(limit, { clearExisting: clear });
        break;

      case 'batch':
        if (!batchId) {
          return NextResponse.json(
            { error: 'batchId required for batch export' },
            { status: 400 }
          );
        }
        result = await exportBatchToSheets(batchId);
        break;

      case 'completed':
        result = await exportCompletedToSheets({ clearExisting: clear });
        break;

      default:
        return NextResponse.json(
          { error: `Invalid type: ${type}. Use: recent, batch, or completed` },
          { status: 400 }
        );
    }

    if (result.error) {
      return NextResponse.json(
        { error: result.error },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      exported: result.exported,
      type,
    });

  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return NextResponse.json(
      { error: message },
      { status: 500 }
    );
  }
}
```

This provides:
- GET: Check if configured and show usage
- POST: Trigger export with options
  </action>
  <verify>
```bash
# Check configuration
curl http://localhost:3000/api/export/sheets

# Export recent renders
curl -X POST http://localhost:3000/api/export/sheets \
  -H "Content-Type: application/json" \
  -d '{"type": "recent", "limit": 50}'

# Export specific batch
curl -X POST http://localhost:3000/api/export/sheets \
  -H "Content-Type: application/json" \
  -d '{"type": "batch", "batchId": "abc-123"}'

# Export all completed, clearing existing data
curl -X POST http://localhost:3000/api/export/sheets \
  -H "Content-Type: application/json" \
  -d '{"type": "completed", "clear": true}'
```
  </verify>
  <done>
API endpoint allows manual Google Sheets export with multiple options.
  </done>
</task>

</tasks>

<verification>
1. Google Sheets service authenticates with service account
2. Headers auto-created on first export
3. Render data formatted correctly (dates, durations)
4. API endpoint returns helpful error if not configured
5. Multiple export modes work (recent, batch, completed)
6. Clear option wipes existing data before export
</verification>

<success_criteria>
- Google Sheets integration works with service account auth
- Metadata exported includes all relevant fields
- Descriptions truncated to fit sheet cells
- API endpoint provides on-demand export
- Export modes cover common use cases
- Errors handled gracefully with clear messages
</success_criteria>

<output>
After completion, create `.planning/phases/04-automation/04-08-SUMMARY.md`
</output>
