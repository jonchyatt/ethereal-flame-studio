---
phase: 15-modal-render-dispatch
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/jobs/types.ts
  - src/app/api/render/route.ts
  - worker/pipelines/render.ts
  - worker/process-job.ts
  - src/lib/render/modalClient.ts
autonomous: true
requirements: [WORK-04]
must_haves:
  truths:
    - "Worker render pipeline uploads prepared audio to R2 and generates a signed URL"
    - "Worker dispatches a render job to Modal with the R2 signed audio URL"
    - "Render API route creates a render job in the JobStore so the worker can pick it up"
  artifacts:
    - path: "worker/pipelines/render.ts"
      provides: "Render pipeline that uploads audio to R2 and dispatches to Modal"
      min_lines: 60
    - path: "src/app/api/render/route.ts"
      provides: "Render POST route creating jobs in JobStore"
      contains: "getJobStore"
    - path: "src/lib/render/modalClient.ts"
      provides: "Updated Modal client accepting audioSignedUrl"
      contains: "audioSignedUrl"
  key_links:
    - from: "src/app/api/render/route.ts"
      to: "JobStore"
      via: "getJobStore().create('render', ...)"
      pattern: "create.*render"
    - from: "worker/pipelines/render.ts"
      to: "src/lib/render/modalClient.ts"
      via: "submitToModal with signed URL"
      pattern: "submitToModal"
    - from: "worker/process-job.ts"
      to: "worker/pipelines/render.ts"
      via: "case 'render' dispatch"
      pattern: "case.*render"
---

<objective>
Wire GPU render job dispatch through the v2.0 cloud pipeline: API route creates a render job in JobStore, worker picks it up, uploads the audio asset to R2, generates a signed URL, and dispatches the render to Modal.

Purpose: WORK-04 requires the worker to dispatch GPU render jobs to Modal by uploading audio to R2 and passing a signed URL. The existing render route dispatches directly to Modal from the API route (v1.0 pattern) -- this plan refactors it to flow through the JobStore -> worker -> Modal chain.

Output: Worker render pipeline module, updated render API route, and updated modalClient.
</objective>

<execution_context>
@C:/Users/jonch/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jonch/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-api-worker-processing-pipeline/14-02-SUMMARY.md
@worker/process-job.ts
@worker/pipelines/ingest.ts
@src/lib/jobs/types.ts
@src/lib/storage/index.ts
@src/lib/storage/types.ts
@src/lib/render/modalClient.ts
@src/app/api/render/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add render job type and create render API route with JobStore dispatch</name>
  <files>
    src/lib/jobs/types.ts
    src/app/api/render/route.ts
  </files>
  <action>
1. In `src/lib/jobs/types.ts`, add `'render'` to the `AudioPrepJob.type` union:
   - Change `type: 'ingest' | 'preview' | 'save'` to `type: 'ingest' | 'preview' | 'save' | 'render'`

2. In `src/app/api/render/route.ts`, refactor the POST handler to dispatch through JobStore instead of directly calling Modal:
   - Import `getJobStore` from `@/lib/jobs`
   - Keep the existing audio input handling (base64, url, path, asset) and validation
   - For audio inputs that are files (base64, path, asset), upload the audio to the StorageAdapter under key `renders/{jobId}/audio.{ext}` before creating the job
   - Create a job in JobStore with `type: 'render'` and metadata containing: `audioStorageKey` (the R2 key), `outputFormat`, `fps`, `quality`, `visualConfig` (the render settings/visual mode/skybox etc), `callbackUrl` (derived from NEXT_PUBLIC_APP_URL or VERCEL_URL)
   - For URL-type audio, store the URL in metadata as `audioUrl` (worker will download and re-upload to R2)
   - Return `{ jobId, status: 'pending' }` immediately
   - Remove the direct Modal dispatch code (the `if (process.env.MODAL_ENDPOINT_URL)` block) -- the worker handles this now
   - Remove the BullMQ dispatch code -- the worker handles this now
   - Keep the ServerJobStore.create call for backward compatibility with the v1.0 render job list/status UI, but the primary dispatch is through JobStore
   - Actually, to avoid dual-write complexity: remove ServerJobStore entirely from POST. The render job flows through JobStore only. The GET endpoint on this route can remain as-is for now (it queries ServerJobStore for legacy jobs).

3. The key pattern for audio storage: `renders/{jobId}/audio.{ext}` where ext is derived from the original filename or defaults to `mp3`.
  </action>
  <verify>
    `npx tsc --noEmit` compiles without errors. The render type union includes 'render'. The POST handler imports getJobStore and creates a render job.
  </verify>
  <done>
    POST /api/render creates a render job in JobStore with audio uploaded to storage (or URL in metadata), returns jobId immediately without blocking on Modal or BullMQ.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create worker render pipeline and wire into process-job dispatcher</name>
  <files>
    worker/pipelines/render.ts
    worker/process-job.ts
    src/lib/render/modalClient.ts
  </files>
  <action>
1. Update `src/lib/render/modalClient.ts`:
   - Add `audio_signed_url?: string` to `ModalSubmitRequest` interface
   - In `submitToModal`, accept a new optional parameter `audioSignedUrl?: string`
   - When `audioSignedUrl` is provided, include it as `audio_signed_url` in the request body (this is the R2 presigned download URL)
   - Keep existing `audioUrl` and `audioBase64` for backward compatibility

2. Create `worker/pipelines/render.ts` following the existing pipeline pattern (see ingest.ts for reference):
   - Export `async function runRenderPipeline(store: JobStore, job: AudioPrepJob, childRef: { current: ChildProcess | null }): Promise<void>`
   - Step 1 - Resolve audio: If job metadata has `audioStorageKey`, download from storage to temp dir. If it has `audioUrl`, download via fetch to temp dir. Update progress to 10%.
   - Step 2 - Ensure audio is in R2: Use `getStorageAdapter()` to check if audio is already at the storage key. If local-only (downloaded from URL), upload it to `renders/{jobId}/audio.{ext}`. Update progress to 20%.
   - Step 3 - Generate signed URL: Call `getStorageAdapter().getSignedUrl(audioStorageKey, 3600)` to get a 1-hour download URL for Modal. Update progress to 25%.
   - Step 4 - Build render config: Extract `outputFormat`, `fps`, `quality`, `visualConfig` from job.metadata. Construct the config object matching modal-render-entry.ts expectations.
   - Step 5 - Dispatch to Modal: Call `submitToModal({ config, jobId: job.jobId, audioSignedUrl: signedUrl })`. Store the `call_id` from the response in the job metadata via `store.update(job.jobId, { stage: 'dispatched', progress: 30, result: { modalCallId: response.call_id } })`.
   - Step 6 - The pipeline returns at this point. The worker does NOT wait for Modal to finish. Modal will call the webhook when done. Mark stage as 'dispatched-to-modal' and progress at 30.
   - Note: Do NOT call `store.complete()` here -- the webhook callback will do that when Modal finishes.
   - Use `os.tmpdir()` for temp files and clean up in `finally` block.
   - Import `getStorageAdapter` from the storage module path that worker tsconfig can resolve.

3. In `worker/process-job.ts`:
   - Import `runRenderPipeline` from `./pipelines/render`
   - Add `case 'render':` to the switch statement, calling `runRenderPipeline(store, job, childRef)`
   - After the render pipeline returns (it returns after dispatching to Modal, not after render completes), do NOT call `store.complete()` -- the job stays in 'processing' status until the webhook callback marks it complete. Add a comment explaining this: "Render jobs are completed by the webhook callback, not here."

4. Special handling in processJob: After the switch/case for render, skip the implicit completion that other pipelines might trigger. The render pipeline sets its own stage and progress. The job must remain in 'processing' status with stage 'dispatched-to-modal' until the webhook fires.
  </action>
  <verify>
    `npx tsc --noEmit` compiles without errors. `worker/pipelines/render.ts` exists and exports `runRenderPipeline`. `worker/process-job.ts` has a `case 'render'` that dispatches to the render pipeline. `modalClient.ts` accepts `audioSignedUrl`.
  </verify>
  <done>
    Worker render pipeline downloads audio from storage, uploads to R2 if needed, generates signed URL, dispatches to Modal via submitToModal with signed URL, and leaves the job in 'processing/dispatched-to-modal' state for webhook completion.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `npx tsc --noEmit`
2. JobStore type union includes 'render'
3. POST /api/render creates a job in JobStore (not direct Modal dispatch)
4. worker/pipelines/render.ts follows the established pipeline pattern
5. process-job.ts dispatches render jobs to runRenderPipeline
6. modalClient.ts supports audio_signed_url parameter
</verification>

<success_criteria>
- Render job created in JobStore when POST /api/render is called
- Worker picks up render job and dispatches to Modal with R2 signed audio URL
- Job remains in 'processing' state after Modal dispatch (webhook will complete it)
- No direct Modal calls from API route (all through worker)
</success_criteria>

<output>
After completion, create `.planning/phases/15-modal-render-dispatch/15-01-SUMMARY.md`
</output>
