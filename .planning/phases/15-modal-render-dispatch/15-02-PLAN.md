---
phase: 15-modal-render-dispatch
plan: 02
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - scripts/modal-render-entry.ts
  - src/app/api/webhooks/worker/route.ts
  - src/app/api/audio/jobs/[jobId]/route.ts
autonomous: true
requirements: [WORK-05]
must_haves:
  truths:
    - "Modal entry point downloads audio from a signed URL instead of requiring a local file"
    - "Modal entry point uploads the rendered video to R2 and calls the webhook with the R2 key"
    - "Webhook endpoint handles render completion by storing the R2 video key in the job result"
    - "User polls the render job and receives a download URL for the finished video"
  artifacts:
    - path: "scripts/modal-render-entry.ts"
      provides: "Modal container entry with R2 upload and webhook callback"
      contains: "audio-signed-url"
    - path: "src/app/api/webhooks/worker/route.ts"
      provides: "Webhook handling render completion with R2 video key"
      contains: "videoKey"
    - path: "src/app/api/audio/jobs/[jobId]/route.ts"
      provides: "Poll endpoint returning download URL for completed render jobs"
      contains: "videoKey"
  key_links:
    - from: "scripts/modal-render-entry.ts"
      to: "R2 storage"
      via: "S3 PutObject for video upload"
      pattern: "PutObjectCommand|upload"
    - from: "scripts/modal-render-entry.ts"
      to: "src/app/api/webhooks/worker/route.ts"
      via: "POST with Bearer token and R2 key"
      pattern: "webhooks/worker"
    - from: "src/app/api/audio/jobs/[jobId]/route.ts"
      to: "StorageAdapter"
      via: "getSignedUrl for videoKey"
      pattern: "getSignedUrl.*videoKey"
---

<objective>
Update the Modal container entry point to download audio from R2 signed URL, upload rendered video to R2, and call the webhook on completion. Enhance the webhook and poll endpoints to handle render results with R2 video keys.

Purpose: WORK-05 requires Modal to call a secure webhook on render completion, providing the R2 key of the output video. The user must be able to poll the render job and receive a download URL for the finished video.

Output: Updated modal-render-entry.ts with R2 I/O, enhanced webhook and poll endpoints.
</objective>

<execution_context>
@C:/Users/jonch/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jonch/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-api-worker-processing-pipeline/14-03-SUMMARY.md
@scripts/modal-render-entry.ts
@src/app/api/webhooks/worker/route.ts
@src/app/api/audio/jobs/[jobId]/route.ts
@src/lib/storage/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Modal entry point for R2 audio download and video upload with webhook callback</name>
  <files>
    scripts/modal-render-entry.ts
  </files>
  <action>
1. Add new CLI arguments to `parseArgs()`:
   - `--audio-signed-url` — R2 presigned URL to download audio from (alternative to `--audio` local path)
   - `--webhook-url` — Full URL of the webhook endpoint (e.g., `https://app.vercel.app/api/webhooks/worker`)
   - `--webhook-secret` — Bearer token for webhook authentication (INTERNAL_WEBHOOK_SECRET)
   - `--r2-upload-key` — R2 key where the rendered video should be uploaded (e.g., `renders/{jobId}/output.mp4`)

2. Add R2 upload configuration via env vars (these will be set in the Modal container environment):
   - `R2_ACCOUNT_ID`, `R2_ACCESS_KEY_ID`, `R2_SECRET_ACCESS_KEY`, `R2_BUCKET_NAME`
   - Create a helper function `uploadToR2(filePath: string, r2Key: string): Promise<void>` that:
     - Uses `@aws-sdk/client-s3` with `PutObjectCommand`
     - Reads the file from disk and uploads to the configured R2 bucket
     - Sets `Content-Type: video/mp4`
   - This is a standalone function (not using StorageAdapter) because the Modal container is a minimal environment that doesn't load the full app

3. Add audio download from signed URL:
   - If `--audio-signed-url` is provided (and `--audio` is not), download the audio from the signed URL to a temp file at `/tmp/audio.{ext}`
   - Use `fetch()` to download, pipe to file via `fs.createWriteStream`
   - Determine extension from URL or default to `.mp3`
   - Set `audioPath` to the downloaded temp file path

4. After successful render:
   - If `--r2-upload-key` is provided, call `uploadToR2(outputPath, r2UploadKey)` to upload the rendered video to R2
   - Log the upload: `[modal-render] Uploaded video to R2: {r2UploadKey}`

5. After R2 upload (or after render if no R2 upload), call the webhook:
   - If `--webhook-url` and `--webhook-secret` and `--job-id` are all provided:
   - POST to `{webhookUrl}` with:
     - Header: `Authorization: Bearer {webhookSecret}`
     - Header: `Content-Type: application/json`
     - Body: `{ "jobId": "{jobId}", "status": "complete", "result": { "videoKey": "{r2UploadKey}", "format": "{format}", "durationSeconds": result.duration } }`
   - On render failure, POST with `{ "jobId": "{jobId}", "status": "failed", "error": "{errorMessage}" }`
   - Wrap webhook call in try/catch -- log but don't fail if webhook call fails

6. Update the `reportProgressCallback` function:
   - Replace the existing PATCH-based progress reporting with a call to the webhook URL using the same Bearer token auth pattern
   - OR: Keep existing PATCH to `/api/render/{jobId}` for backward compatibility, AND also send progress via the webhook. Since the webhook schema expects only `complete`/`failed`, keep progress reporting via PATCH and only use webhook for final status.
   - Decision: Keep PATCH for progress (backward compat), use webhook only for final complete/failed.

7. Derive the R2 upload key: If `--r2-upload-key` is not provided, derive it as `renders/{jobId}/output.mp4` when `--job-id` is given.
  </action>
  <verify>
    `npx tsc --noEmit --project scripts/tsconfig.json 2>/dev/null || npx tsc --noEmit` compiles. The script accepts `--audio-signed-url`, `--webhook-url`, `--webhook-secret`, and `--r2-upload-key` arguments.
  </verify>
  <done>
    Modal entry point can download audio from R2 signed URL, render the video, upload the output to R2, and call the webhook with the R2 video key on completion or error.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance webhook and poll endpoints for render completion with R2 video key</name>
  <files>
    src/app/api/webhooks/worker/route.ts
    src/app/api/audio/jobs/[jobId]/route.ts
  </files>
  <action>
1. In `src/app/api/audio/jobs/[jobId]/route.ts`, update the `JobPollResponse` type:
   - Change `type: 'ingest' | 'preview' | 'save'` to `type: 'ingest' | 'preview' | 'save' | 'render'`
   - This aligns with the `AudioPrepJob.type` union updated in plan 15-01 Task 1, so that polling a render job does not produce a TypeScript type error when assigning `job.type` to `response.type`.

2. In `src/app/api/webhooks/worker/route.ts`:
   - The existing webhook already handles `complete` and `failed` statuses and stores the `result` object via `store.complete(jobId, result)`. This means when Modal sends `{ jobId, status: "complete", result: { videoKey: "renders/xxx/output.mp4" } }`, the videoKey will be stored in the job result automatically.
   - Add a log line specifically for render completions: if `result` contains a `videoKey` field, log `[Webhook] Render complete for job ${jobId}, video at ${result.videoKey}`.
   - No structural changes needed -- the existing webhook is generic enough. Just ensure the Zod schema allows `videoKey` in the result (it does -- `z.record(z.string(), z.unknown())` accepts any keys).

3. In `src/app/api/audio/jobs/[jobId]/route.ts` (the poll endpoint), enhance the download URL logic:
   - After retrieving a completed job, check if `job.result` contains a `videoKey` field
   - If `videoKey` exists, generate a signed download URL: `const downloadUrl = await getStorageAdapter().getSignedUrl(videoKey as string, 7 * 24 * 3600)` (7-day download URL)
   - Include `downloadUrl` in the response alongside the existing fields
   - The existing response already has a pattern for enriching with `downloadUrl` for `previewKey` and `preparedKey` -- extend this to also check for `videoKey`
   - Wrap the getSignedUrl call in try/catch (non-fatal, consistent with existing pattern)
   - Import `getStorageAdapter` from `@/lib/storage` (may already be imported)

4. Structure of the enriched poll response for a completed render job:
   ```json
   {
     "jobId": "...",
     "status": "complete",
     "progress": 100,
     "stage": null,
     "result": {
       "videoKey": "renders/xxx/output.mp4",
       "format": "flat-1080p-landscape",
       "durationSeconds": 45.2
     },
     "downloadUrl": "https://r2-signed-url...",
     ...
   }
   ```
  </action>
  <verify>
    `npx tsc --noEmit` compiles. The poll endpoint checks for `videoKey` in job results and generates a signed URL. The webhook logs render-specific completions.
  </verify>
  <done>
    Webhook accepts render completion callbacks with R2 video key. Poll endpoint returns a signed download URL for the rendered video when the job is complete.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `npx tsc --noEmit`
2. modal-render-entry.ts accepts --audio-signed-url and downloads from R2
3. modal-render-entry.ts uploads rendered video to R2 via PutObjectCommand
4. modal-render-entry.ts calls webhook with Bearer token and R2 video key
5. Webhook stores videoKey in job result
6. Poll endpoint generates signed download URL from videoKey
</verification>

<success_criteria>
- Modal container downloads audio from R2 signed URL (not just local files)
- Modal container uploads rendered video to R2 after completion
- Modal container calls webhook with R2 video key and proper auth
- Webhook marks job complete with video key in result
- Poll endpoint returns signed download URL for completed render jobs
- Complete flow: API -> JobStore -> Worker -> Modal -> R2 upload -> Webhook -> Poll with download URL
</success_criteria>

<output>
After completion, create `.planning/phases/15-modal-render-dispatch/15-02-SUMMARY.md`
</output>
