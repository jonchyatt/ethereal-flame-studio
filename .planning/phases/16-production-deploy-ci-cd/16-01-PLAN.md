---
phase: 16-production-deploy-ci-cd
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/storage/index.ts
  - src/lib/jobs/index.ts
  - .env.example
autonomous: true
requirements:
  - DEPLOY-01
  - DEPLOY-02

must_haves:
  truths:
    - "Setting DEPLOY_ENV=production causes StorageAdapter to use R2 and JobStore to use Turso without setting individual backend vars"
    - "Omitting DEPLOY_ENV (or setting it to anything else) defaults to local backends, preserving existing dev workflow"
    - ".env.example contains every v2.0 production variable with descriptions and grouping"
  artifacts:
    - path: "src/lib/storage/index.ts"
      provides: "DEPLOY_ENV fallback for STORAGE_BACKEND"
      contains: "DEPLOY_ENV"
    - path: "src/lib/jobs/index.ts"
      provides: "DEPLOY_ENV fallback for JOB_STORE_BACKEND"
      contains: "DEPLOY_ENV"
    - path: ".env.example"
      provides: "Complete v2.0 environment variable documentation"
      contains: "STORAGE_BACKEND"
  key_links:
    - from: "src/lib/storage/index.ts"
      to: "DEPLOY_ENV env var"
      via: "fallback logic"
      pattern: "DEPLOY_ENV.*production.*r2"
    - from: "src/lib/jobs/index.ts"
      to: "DEPLOY_ENV env var"
      via: "fallback logic"
      pattern: "DEPLOY_ENV.*production.*turso"
---

<objective>
Wire a single DEPLOY_ENV=production convenience variable that sets both storage and job backends to cloud mode, and rewrite .env.example to document every v2.0 production variable.

Purpose: DEPLOY-01 requires switching to production mode via env vars with no code changes. DEPLOY-02 requires .env.example to document all production variables. Currently STORAGE_BACKEND and JOB_STORE_BACKEND are independent; a single DEPLOY_ENV reduces operator error.

Output: Updated storage/jobs factory files with DEPLOY_ENV fallback; complete .env.example.
</objective>

<execution_context>
@C:/Users/jonch/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jonch/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/storage/index.ts
@src/lib/jobs/index.ts
@.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DEPLOY_ENV fallback to storage and job adapters</name>
  <files>src/lib/storage/index.ts, src/lib/jobs/index.ts</files>
  <action>
In `src/lib/storage/index.ts`, change the backend resolution line to:

```ts
const deployEnv = process.env.DEPLOY_ENV;
const backend = process.env.STORAGE_BACKEND || (deployEnv === 'production' ? 'r2' : 'local');
```

This means: explicit STORAGE_BACKEND always wins. If not set, DEPLOY_ENV=production implies 'r2', otherwise 'local'. Existing behavior is preserved because STORAGE_BACKEND defaults to 'local' when neither var is set.

In `src/lib/jobs/index.ts`, apply the same pattern:

```ts
const deployEnv = process.env.DEPLOY_ENV;
const backend = process.env.JOB_STORE_BACKEND || (deployEnv === 'production' ? 'turso' : 'local');
```

Do NOT change any other logic in these files. The existing singleton pattern, dynamic require(), reset functions, and re-exports remain untouched.
  </action>
  <verify>
Run `npm run build` to confirm no TypeScript errors. Grep both files for "DEPLOY_ENV" to confirm the pattern is applied.
  </verify>
  <done>
Both adapter factories respect DEPLOY_ENV=production as a fallback when individual backend vars are not set. Existing behavior (no DEPLOY_ENV set) defaults to local backends.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite .env.example with all v2.0 production variables</name>
  <files>.env.example</files>
  <action>
Replace the entire .env.example with a comprehensive file covering ALL variables used across the v2.0 cloud stack. Organize into these sections:

1. **Deployment Mode** (new section)
   - `DEPLOY_ENV` — Set to "production" for cloud mode (R2 + Turso). Omit or set to anything else for local dev. Optional: individual overrides below take precedence.

2. **Storage (Cloudflare R2)**
   - `STORAGE_BACKEND` — Override: "local" or "r2". Defaults based on DEPLOY_ENV.
   - `R2_ACCOUNT_ID` — Cloudflare account ID (R2 dashboard)
   - `R2_ACCESS_KEY_ID` — R2 API token access key
   - `R2_SECRET_ACCESS_KEY` — R2 API token secret key
   - `R2_BUCKET_NAME` — R2 bucket name (default: ethereal-flame-studio)
   - `STORAGE_LOCAL_PATH` — Local storage directory (default: ./storage)
   - `NEXT_PUBLIC_BASE_URL` — App base URL for local asset URLs (default: http://localhost:3000)

3. **Job Store (Turso)**
   - `JOB_STORE_BACKEND` — Override: "local" or "turso". Defaults based on DEPLOY_ENV.
   - `TURSO_DATABASE_URL` — Turso database URL (e.g., libsql://db-name.turso.io)
   - `TURSO_AUTH_TOKEN` — Turso auth token from CLI
   - `JOB_STORE_DB_PATH` — Local SQLite path (default: ./audio-prep-jobs.db)

4. **Modal (GPU Rendering)**
   - `MODAL_ENDPOINT_URL` — Modal submit endpoint URL
   - `MODAL_STATUS_URL` — Modal status endpoint URL (optional, derived from submit URL)
   - `MODAL_AUTH_TOKEN` — Modal auth token

5. **Worker (Render.com)**
   - `WORKER_POLL_INTERVAL_MS` — Poll interval in ms (default: 3000)
   - `WORKER_REAPER_INTERVAL_MS` — Reaper interval in ms (default: 30000)
   - `WORKER_INGEST_TIMEOUT_MS` — Ingest job timeout (default: 600000)
   - `WORKER_PREVIEW_TIMEOUT_MS` — Preview job timeout (default: 300000)
   - `WORKER_SAVE_TIMEOUT_MS` — Save job timeout (default: 900000)
   - `WORKER_DEFAULT_TIMEOUT_MS` — Default job timeout (default: 600000)

6. **Webhooks & URLs**
   - `INTERNAL_WEBHOOK_SECRET` — Shared secret for worker/Modal webhook auth (generate with: openssl rand -hex 32)
   - `NEXT_PUBLIC_APP_URL` — Public app URL (e.g., https://ethereal-flame-studio.vercel.app)
   - `VERCEL_URL` — Set automatically by Vercel; fallback for NEXT_PUBLIC_APP_URL

7. **Legacy v1.0** (condensed block)
   Keep a collapsed section referencing Redis, Whisper, Google Drive, n8n, Jarvis, Notion, Telegram variables. Don't remove them -- just group under a "Legacy / v1.0 features" header with a note that these are not required for v2.0 cloud production.

Each variable should have:
- A comment explaining what it is
- Where to get the value (dashboard URL, CLI command)
- Default value if applicable
- Whether it's required for production

Do NOT include actual secret values. Use placeholder patterns like `your_value_here`.
  </action>
  <verify>
Read the file and confirm: (1) Every env var from the planning context "Environment variables already used" section appears. (2) All 6 v2.0 sections are present. (3) No actual secrets are in the file.
  </verify>
  <done>
.env.example contains every v2.0 production variable with descriptions, source instructions, and defaults. Legacy v1.0 variables are preserved in a separate section.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with no TypeScript errors
2. Setting `DEPLOY_ENV=production` (without STORAGE_BACKEND or JOB_STORE_BACKEND) would cause storage to use 'r2' and jobs to use 'turso'
3. Not setting DEPLOY_ENV keeps both at 'local' (backward compatible)
4. .env.example has all variables from: storage adapter, job store, modal client, worker, webhook, render pipeline
</verification>

<success_criteria>
- DEPLOY-01 satisfied: DEPLOY_ENV=production activates all cloud backends
- DEPLOY-02 satisfied: .env.example is a complete reference for all production variables
- No existing behavior broken (local dev defaults unchanged)
</success_criteria>

<output>
After completion, create `.planning/phases/16-production-deploy-ci-cd/16-01-SUMMARY.md`
</output>
