---
phase: 14-api-worker-processing-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/audio/ingest/route.ts
  - src/app/api/audio/edit/preview/route.ts
  - src/app/api/audio/edit/save/route.ts
  - src/app/api/audio/jobs/[jobId]/route.ts
  - src/app/api/audio/edit/preview/[jobId]/audio/route.ts
autonomous: true
requirements: [API-01, API-02]

must_haves:
  truths:
    - "POST /api/audio/ingest returns a jobId within 2 seconds without blocking on download/ffmpeg"
    - "POST /api/audio/edit/preview returns a jobId within 2 seconds without blocking on ffmpeg render"
    - "POST /api/audio/edit/save returns a jobId within 2 seconds without blocking on ffmpeg render"
    - "GET /api/audio/jobs/[jobId] returns downloadUrl in result when job is complete and result contains a storage key"
    - "GET /api/audio/edit/preview/[jobId]/audio serves audio from storage adapter (not local filesystem path)"
  artifacts:
    - path: "src/app/api/audio/ingest/route.ts"
      provides: "Async ingest endpoint creating job in JobStore"
      contains: "getJobStore"
    - path: "src/app/api/audio/edit/preview/route.ts"
      provides: "Async preview endpoint creating job in JobStore"
      contains: "getJobStore"
    - path: "src/app/api/audio/edit/save/route.ts"
      provides: "Async save endpoint creating job in JobStore"
      contains: "getJobStore"
    - path: "src/app/api/audio/jobs/[jobId]/route.ts"
      provides: "Poll endpoint with R2 download URL in result"
      contains: "downloadUrl"
  key_links:
    - from: "src/app/api/audio/ingest/route.ts"
      to: "src/lib/jobs/index.ts"
      via: "getJobStore().create()"
      pattern: "getJobStore.*create"
    - from: "src/app/api/audio/jobs/[jobId]/route.ts"
      to: "src/lib/storage/index.ts"
      via: "getStorageAdapter().getSignedUrl()"
      pattern: "getSignedUrl"
---

<objective>
Refactor all audio API routes (ingest, edit/preview, edit/save) to use the Phase 13 JobStore for async job dispatch, and enhance the poll endpoint to return R2 download URLs on completion.

Purpose: Currently, the API routes use the old synchronous `audioPrepJobs` (local JobManager) and process work inline within the request handler. This blocks Vercel serverless functions for minutes. Phase 14 switches them to create a job in the shared JobStore (Turso in production) and return a jobId immediately. The actual processing moves to the worker (plan 14-02).

Output: All three POST endpoints return `{ jobId, status: 'pending' }` within 2 seconds. Poll endpoint returns `downloadUrl` when a job completes with a storage key in its result.
</objective>

<execution_context>
@C:/Users/jonch/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jonch/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-job-state-worker-infra/13-01-SUMMARY.md
@.planning/phases/13-job-state-worker-infra/13-02-SUMMARY.md
@src/lib/jobs/types.ts
@src/lib/jobs/index.ts
@src/app/api/audio/ingest/route.ts
@src/app/api/audio/edit/preview/route.ts
@src/app/api/audio/edit/save/route.ts
@src/app/api/audio/jobs/[jobId]/route.ts
@src/app/api/audio/edit/preview/[jobId]/audio/route.ts
@src/lib/audio-prep/JobManager.ts
@src/lib/storage/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor ingest/preview/save API routes to async job dispatch via JobStore</name>
  <files>
    src/app/api/audio/ingest/route.ts
    src/app/api/audio/edit/preview/route.ts
    src/app/api/audio/edit/save/route.ts
  </files>
  <action>
Refactor all three POST handlers to use `getJobStore()` (from `@/lib/jobs`) instead of the old `audioPrepJobs` singleton (from `@/lib/audio-prep/JobManager`). The routes must:

1. **Ingest route** (`src/app/api/audio/ingest/route.ts`):
   - Keep the existing validation logic (Zod schema, content type detection, quota check).
   - For multipart file uploads: accept the file, upload it to storage via `getStorageAdapter().put()` to a temp ingest key like `ingest-uploads/{jobId}/original.{ext}`, then store the `storageKey` in job metadata.
   - For YouTube/URL sources: store the source type and URL directly in job metadata (worker will download).
   - Create the job via `await getJobStore().create('ingest', metadata)` where metadata includes `{ sourceType, url?, storageKey?, rightsAttested?, originalFilename? }`.
   - Return `{ success: true, data: { jobId, status: 'pending' } }` immediately.
   - Remove ALL inline processing logic (the `processIngest` function, `streamFileToDisk`, `extractAudioFromVideo`). These will be extracted to the worker in plan 14-02.
   - Remove the `audioPrepJobs` import entirely.

2. **Preview route** (`src/app/api/audio/edit/preview/route.ts`):
   - Keep the existing Zod validation, asset existence check, and recipe cache check.
   - For cache hits: still create an instantly-completed job but via `getJobStore()` instead of `audioPrepJobs`.
   - For cache misses: create job via `await getJobStore().create('preview', { recipe: parsed.data, recipeHash })` and return immediately.
   - Remove ALL inline render logic (the renderPromise async block, temp file downloads, renderRecipe calls).
   - Remove the `audioPrepJobs` import.

3. **Save route** (`src/app/api/audio/edit/save/route.ts`):
   - Keep the existing Zod validation and asset existence check.
   - Create job via `await getJobStore().create('save', { recipe: parsed.data })` and return immediately.
   - Remove ALL inline render logic.
   - Remove the `audioPrepJobs` import.

For all three routes, the import changes from:
```typescript
import { audioPrepJobs } from '@/lib/audio-prep/JobManager';
```
to:
```typescript
import { getJobStore } from '@/lib/jobs';
```

IMPORTANT: The ingest route must handle multipart file uploads by buffering to storage BEFORE creating the job. This ensures the worker can access the file via storage adapter. For JSON-body requests (youtube, url), no pre-upload is needed -- just pass the URL in metadata.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify all three routes compile without errors. Grep for `audioPrepJobs` in the three files to confirm the old import is gone. Grep for `getJobStore` to confirm the new import is present.
  </verify>
  <done>
All three POST endpoints create a job in JobStore and return `{ jobId, status }` without blocking. No inline processing logic remains in any API route. Old `audioPrepJobs` import removed from all three files.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance poll endpoint with download URL and update preview audio route</name>
  <files>
    src/app/api/audio/jobs/[jobId]/route.ts
    src/app/api/audio/edit/preview/[jobId]/audio/route.ts
  </files>
  <action>
1. **Poll endpoint** (`src/app/api/audio/jobs/[jobId]/route.ts`):
   - This route already uses `getJobStore()` from Phase 13. Enhance it to generate a download URL when the job result contains a storage key.
   - After fetching the job, check if `job.status === 'complete'` and `job.result` contains a key like `previewKey`, `preparedKey`, or `assetId`.
   - If a storage key is found in the result, call `getStorageAdapter().getSignedUrl(key)` to generate a time-limited download URL.
   - Add `downloadUrl` to the response data alongside the existing fields.
   - Import `getStorageAdapter` from `@/lib/storage`.
   - The response shape becomes:
   ```typescript
   {
     jobId, status, progress, stage, queuePosition,
     result, error,
     downloadUrl?: string  // NEW: signed URL when job complete with storage key
   }
   ```

2. **Preview audio route** (`src/app/api/audio/edit/preview/[jobId]/audio/route.ts`):
   - This route currently uses the old `audioPrepJobs` and reads from `job.result.previewPath` (local filesystem).
   - Refactor to use `getJobStore()` and read from `job.result.previewKey` (storage key).
   - If the storage backend is local, use `getStorageAdapter().get()` to read the file and serve it directly.
   - If the storage backend is R2, redirect to the signed URL via `getStorageAdapter().getSignedUrl()`.
   - Replace:
     ```typescript
     import { audioPrepJobs } from '@/lib/audio-prep/JobManager';
     ```
     with:
     ```typescript
     import { getJobStore } from '@/lib/jobs';
     import { getStorageAdapter } from '@/lib/storage';
     ```
   - Update the check from `job.result?.previewPath` to `job.result?.previewKey`.
   - For serving: use the storage download pattern already established in the `/api/storage/download` route (signed URL for R2, direct serve for local).
  </action>
  <verify>
Run `npx tsc --noEmit` to verify both routes compile. Grep for `audioPrepJobs` in both files to confirm old import removed. Grep for `downloadUrl` in the poll route to confirm the enhancement exists.
  </verify>
  <done>
Poll endpoint returns `downloadUrl` field when job is complete with a storage key in result. Preview audio route serves audio from storage adapter instead of local filesystem path. Both routes use `getJobStore()` instead of old `audioPrepJobs`.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `grep -r "audioPrepJobs" src/app/api/audio/ingest/route.ts src/app/api/audio/edit/preview/route.ts src/app/api/audio/edit/save/route.ts src/app/api/audio/edit/preview/\[jobId\]/audio/route.ts` returns no matches
3. `grep -r "getJobStore" src/app/api/audio/ingest/route.ts src/app/api/audio/edit/preview/route.ts src/app/api/audio/edit/save/route.ts` returns matches in all three files
4. `grep "downloadUrl" src/app/api/audio/jobs/\[jobId\]/route.ts` returns a match
</verification>

<success_criteria>
- All three audio API POST routes return within 2 seconds (no inline processing)
- Poll endpoint enriches completed job results with a signed download URL
- Preview audio route serves from storage adapter (not filesystem)
- Zero references to old `audioPrepJobs` in any modified file
- TypeScript compilation passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/14-api-worker-processing-pipeline/14-01-SUMMARY.md`
</output>
