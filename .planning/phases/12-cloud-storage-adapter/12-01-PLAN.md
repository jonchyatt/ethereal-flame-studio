---
phase: 12-cloud-storage-adapter
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/storage/types.ts
  - src/lib/storage/LocalStorageAdapter.ts
  - src/lib/storage/R2StorageAdapter.ts
  - src/lib/storage/index.ts
autonomous: true
requirements: [STOR-01, STOR-02, STOR-03]

must_haves:
  truths:
    - "Writing a file via the adapter persists it to local filesystem in development"
    - "Writing a file via the adapter persists it to R2 in production"
    - "Reading a file via the adapter returns the same bytes that were written"
    - "Listing files by prefix returns all matching keys"
    - "Deleting a file removes it from the backing store"
    - "The adapter selection is driven by a single environment variable"
  artifacts:
    - path: "src/lib/storage/types.ts"
      provides: "StorageAdapter interface definition"
      contains: "StorageAdapter"
    - path: "src/lib/storage/LocalStorageAdapter.ts"
      provides: "Filesystem-backed adapter for local development"
      exports: ["LocalStorageAdapter"]
    - path: "src/lib/storage/R2StorageAdapter.ts"
      provides: "R2-backed adapter for production"
      exports: ["R2StorageAdapter"]
    - path: "src/lib/storage/index.ts"
      provides: "Factory function that returns the correct adapter based on environment"
      exports: ["getStorageAdapter", "StorageAdapter"]
  key_links:
    - from: "src/lib/storage/index.ts"
      to: "src/lib/storage/LocalStorageAdapter.ts"
      via: "conditional import based on STORAGE_BACKEND env var"
      pattern: "STORAGE_BACKEND.*local"
    - from: "src/lib/storage/index.ts"
      to: "src/lib/storage/R2StorageAdapter.ts"
      via: "conditional import based on STORAGE_BACKEND env var"
      pattern: "STORAGE_BACKEND.*r2"
    - from: "src/lib/storage/R2StorageAdapter.ts"
      to: "@aws-sdk/client-s3"
      via: "S3Client with R2 endpoint"
      pattern: "S3Client"
---

<objective>
Create the StorageAdapter interface and both implementations (local filesystem and Cloudflare R2) with a factory function that selects the correct adapter based on environment variables.

Purpose: This is the foundational abstraction that allows all file I/O (audio assets, rendered videos, metadata, peaks) to transparently target either local disk or R2 cloud storage. Every subsequent plan in this phase and downstream phases depends on this interface.

Output: `src/lib/storage/` module with interface, two implementations, and factory function.
</objective>

<execution_context>
@C:/Users/jonch/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jonch/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/audio-prep/AudioAssetService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define StorageAdapter interface and types</name>
  <files>src/lib/storage/types.ts</files>
  <action>
Create `src/lib/storage/types.ts` with a `StorageAdapter` interface that covers all operations needed by AudioAssetService and render output:

```typescript
export interface StorageAdapter {
  /** Write bytes to a key. Creates parent "directories" as needed. */
  put(key: string, data: Buffer | Uint8Array, options?: PutOptions): Promise<void>;

  /** Read the full contents of a key. Returns null if not found. */
  get(key: string): Promise<Buffer | null>;

  /** Delete a single key. No-op if key doesn't exist. */
  delete(key: string): Promise<void>;

  /** Delete all keys under a prefix (recursive). */
  deletePrefix(prefix: string): Promise<void>;

  /** List all keys under a prefix. Returns relative keys (not full paths). */
  list(prefix: string): Promise<string[]>;

  /** Check if a key exists. */
  exists(key: string): Promise<boolean>;

  /** Get metadata (size, lastModified) for a key. Returns null if not found. */
  stat(key: string): Promise<FileStat | null>;

  /** Generate a time-limited signed URL for downloading a key.
   *  For LocalStorageAdapter this returns a local API route URL.
   *  For R2StorageAdapter this returns a presigned S3 GetObject URL. */
  getSignedUrl(key: string, expiresInSeconds?: number): Promise<string>;

  /** Generate a presigned URL for uploading directly to the storage backend.
   *  For LocalStorageAdapter this returns a local API route URL.
   *  For R2StorageAdapter this returns a presigned S3 PutObject URL. */
  getUploadUrl(key: string, options?: UploadUrlOptions): Promise<string>;
}

export interface PutOptions {
  contentType?: string;
}

export interface UploadUrlOptions {
  contentType?: string;
  maxSizeBytes?: number;
  expiresInSeconds?: number;
}

export interface FileStat {
  size: number;
  lastModified: Date;
}

export interface StorageConfig {
  backend: 'local' | 'r2';
  // Local config
  localBasePath?: string;
  localBaseUrl?: string;    // e.g., "http://localhost:3000"
  // R2 config
  r2AccountId?: string;
  r2AccessKeyId?: string;
  r2SecretAccessKey?: string;
  r2BucketName?: string;
  r2Endpoint?: string;      // e.g., "https://{accountId}.r2.cloudflarestorage.com"
}
```

Keep types clean and dependency-free (no runtime imports). Include JSDoc comments on every method so the executor can understand the contract without reading implementation.
  </action>
  <verify>Run `npx tsc --noEmit src/lib/storage/types.ts` (or check that `npm run build` passes type-check). File should compile with zero errors.</verify>
  <done>StorageAdapter interface exists with put, get, delete, deletePrefix, list, exists, stat, getSignedUrl, getUploadUrl methods. FileStat, PutOptions, UploadUrlOptions, StorageConfig types exported.</done>
</task>

<task type="auto">
  <name>Task 2: Implement LocalStorageAdapter, R2StorageAdapter, and factory</name>
  <files>
    src/lib/storage/LocalStorageAdapter.ts
    src/lib/storage/R2StorageAdapter.ts
    src/lib/storage/index.ts
  </files>
  <action>
**Install dependency first:** `npm install @aws-sdk/client-s3 @aws-sdk/s3-request-presigner`

**LocalStorageAdapter (`src/lib/storage/LocalStorageAdapter.ts`):**
- Constructor takes `basePath` (defaults to `./storage`) and `baseUrl` (defaults to `http://localhost:3000`)
- `put`: Write to `{basePath}/{key}` using `fs.writeFile`, creating parent dirs with `fs.mkdir` recursive
- `get`: Read from `{basePath}/{key}`, return null on ENOENT
- `delete`: `fs.unlink`, swallow ENOENT
- `deletePrefix`: Find all files under `{basePath}/{prefix}`, delete each, then rmdir empty parents
- `list`: `fs.readdir` recursive under `{basePath}/{prefix}`, return keys relative to basePath
- `exists`: `fs.access` check
- `stat`: `fs.stat`, return `{ size, lastModified: mtime }`
- `getSignedUrl`: Return `{baseUrl}/api/storage/download?key={encodeURIComponent(key)}` (local dev serves files directly via API route -- this route will be created in plan 12-03)
- `getUploadUrl`: Return `{baseUrl}/api/storage/upload?key={encodeURIComponent(key)}` (local dev receives uploads via API route)

**R2StorageAdapter (`src/lib/storage/R2StorageAdapter.ts`):**
- Constructor takes `{ accountId, accessKeyId, secretAccessKey, bucketName }` and creates an `S3Client` with:
  - `region: 'auto'`
  - `endpoint: https://{accountId}.r2.cloudflarestorage.com`
  - `credentials: { accessKeyId, secretAccessKey }`
- `put`: `PutObjectCommand` with key and Body
- `get`: `GetObjectCommand`, stream body to Buffer. Return null on NoSuchKey
- `delete`: `DeleteObjectCommand`
- `deletePrefix`: `ListObjectsV2Command` with Prefix, then `DeleteObjectsCommand` batch delete (loop if >1000 keys)
- `list`: `ListObjectsV2Command` with Prefix, paginate with ContinuationToken, return all Key values
- `exists`: `HeadObjectCommand`, catch NotFound -> false
- `stat`: `HeadObjectCommand`, return `{ size: ContentLength, lastModified: LastModified }`
- `getSignedUrl`: Use `@aws-sdk/s3-request-presigner` `getSignedUrl` with `GetObjectCommand`, default expiry 7 days (604800 seconds)
- `getUploadUrl`: Use `getSignedUrl` with `PutObjectCommand`, default expiry 1 hour (3600 seconds)

**Factory (`src/lib/storage/index.ts`):**
```typescript
import type { StorageAdapter } from './types';

let _instance: StorageAdapter | null = null;

export function getStorageAdapter(): StorageAdapter {
  if (_instance) return _instance;

  const backend = process.env.STORAGE_BACKEND || 'local';

  if (backend === 'r2') {
    const { R2StorageAdapter } = require('./R2StorageAdapter');
    _instance = new R2StorageAdapter({
      accountId: process.env.R2_ACCOUNT_ID!,
      accessKeyId: process.env.R2_ACCESS_KEY_ID!,
      secretAccessKey: process.env.R2_SECRET_ACCESS_KEY!,
      bucketName: process.env.R2_BUCKET_NAME || 'ethereal-flame-studio',
    });
  } else {
    const { LocalStorageAdapter } = require('./LocalStorageAdapter');
    _instance = new LocalStorageAdapter(
      process.env.STORAGE_LOCAL_PATH || './storage',
      process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'
    );
  }

  return _instance;
}

export type { StorageAdapter } from './types';
export type { FileStat, PutOptions, UploadUrlOptions, StorageConfig } from './types';
```

Use `require()` (not static import) for conditional loading so that `@aws-sdk/client-s3` is not imported in local dev and does not bloat the client bundle.

**Key structure convention (Claude's discretion):**
- Audio assets: `assets/{assetId}/original.mp3`, `assets/{assetId}/metadata.json`, `assets/{assetId}/peaks.json`, `assets/{assetId}/prepared.wav`
- Rendered videos: `renders/{renderId}/{filename}.mp4`
- This mirrors the current filesystem layout but uses forward-slash keys suitable for both FS and S3.
  </action>
  <verify>
1. `npm run build` passes (no type errors, no missing imports)
2. Quick smoke test in a scratch script: instantiate `LocalStorageAdapter`, call `put('test/hello.txt', Buffer.from('hello'))`, then `get('test/hello.txt')` and assert content matches, then `delete('test/hello.txt')`.
  </verify>
  <done>
- LocalStorageAdapter reads/writes files under a configurable base directory
- R2StorageAdapter reads/writes objects to Cloudflare R2 via S3-compatible SDK
- `getStorageAdapter()` returns the correct implementation based on `STORAGE_BACKEND` env var
- `@aws-sdk/client-s3` and `@aws-sdk/s3-request-presigner` installed
- Default key structure documented for assets and renders
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with no type errors
2. `LocalStorageAdapter` can round-trip a file (put + get + delete)
3. `getStorageAdapter()` returns `LocalStorageAdapter` when `STORAGE_BACKEND` is unset
4. `getStorageAdapter()` returns `R2StorageAdapter` when `STORAGE_BACKEND=r2` (assuming env vars present)
5. Both adapters implement every method in the `StorageAdapter` interface
</verification>

<success_criteria>
- StorageAdapter interface is defined with all required operations
- LocalStorageAdapter works for all operations against the local filesystem
- R2StorageAdapter compiles and targets Cloudflare R2 via S3-compatible SDK
- Factory function selects adapter based on `STORAGE_BACKEND` environment variable
- No changes to existing code -- this plan is purely additive
</success_criteria>

<output>
After completion, create `.planning/phases/12-cloud-storage-adapter/12-01-SUMMARY.md`
</output>
