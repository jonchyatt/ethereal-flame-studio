---
phase: 12-cloud-storage-adapter
plan: 02
type: execute
wave: 2
depends_on: [12-01]
files_modified:
  - src/lib/audio-prep/AudioAssetService.ts
  - src/lib/audio-prep/types.ts
  - src/app/api/audio/ingest/route.ts
  - src/app/api/audio/assets/[id]/stream/route.ts
  - src/app/api/audio/assets/[id]/route.ts
  - src/app/api/audio/assets/route.ts
  - src/app/api/audio/edit/save/route.ts
  - src/app/api/audio/edit/preview/route.ts
  - src/app/api/render/local/route.ts
  - src/app/api/render/route.ts
autonomous: true
requirements: [STOR-01, STOR-02, STOR-03]

must_haves:
  truths:
    - "AudioAssetService uses StorageAdapter instead of direct fs calls"
    - "Creating an asset writes original file and metadata.json via the adapter"
    - "Reading an asset reads metadata.json via the adapter"
    - "Listing assets queries the adapter for keys under the assets prefix"
    - "Deleting an asset removes all files under the asset prefix via the adapter"
    - "All API routes work unchanged in local development (no behavior regression)"
    - "In production, assets would be stored in R2 via the same code path"
    - "Rendered video output is uploaded to storage via storage.put() after render completion"
    - "Job record is updated with the storage key for the rendered video"
  artifacts:
    - path: "src/lib/audio-prep/AudioAssetService.ts"
      provides: "Asset service refactored to use StorageAdapter"
      contains: "getStorageAdapter"
    - path: "src/app/api/audio/ingest/route.ts"
      provides: "Ingest route using adapter-backed asset service"
      contains: "assetService"
    - path: "src/app/api/audio/assets/[id]/stream/route.ts"
      provides: "Stream route reading from adapter"
      contains: "getStorageAdapter"
  key_links:
    - from: "src/lib/audio-prep/AudioAssetService.ts"
      to: "src/lib/storage/index.ts"
      via: "import getStorageAdapter"
      pattern: "getStorageAdapter"
    - from: "src/app/api/audio/assets/[id]/stream/route.ts"
      to: "src/lib/storage/index.ts"
      via: "redirect to storage.getSignedUrl for streaming"
      pattern: "getSignedUrl"
    - from: "src/app/api/render/local/route.ts"
      to: "src/lib/storage/index.ts"
      via: "storage.put for uploading rendered video output"
      pattern: "storage\\.put.*renders/"
---

<objective>
Refactor AudioAssetService and all API routes to use the StorageAdapter instead of direct filesystem calls, so that the same code path works for both local development and R2 production.

Purpose: This is the critical wiring that connects the storage abstraction (plan 12-01) to the existing audio-prep pipeline. After this plan, all asset operations (create, read, list, delete, stream) go through the adapter, meaning assets are automatically stored in R2 when `STORAGE_BACKEND=r2`.

Output: Refactored AudioAssetService and updated API routes.
</objective>

<execution_context>
@C:/Users/jonch/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jonch/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-cloud-storage-adapter/12-01-SUMMARY.md
@src/lib/audio-prep/AudioAssetService.ts
@src/lib/audio-prep/types.ts
@src/app/api/audio/ingest/route.ts
@src/app/api/audio/assets/[id]/stream/route.ts
@src/app/api/audio/edit/save/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor AudioAssetService to use StorageAdapter</name>
  <files>
    src/lib/audio-prep/AudioAssetService.ts
  </files>
  <action>
Rewrite AudioAssetService to use the StorageAdapter interface instead of direct `fs` calls. The class should obtain a storage adapter via `getStorageAdapter()` from `src/lib/storage/index.ts`.

**Key mapping (old filesystem -> new storage keys):**
- Old: `{assetsDir}/{assetId}/original.mp3` -> New key: `assets/{assetId}/original.mp3`
- Old: `{assetsDir}/{assetId}/metadata.json` -> New key: `assets/{assetId}/metadata.json`
- Old: `{assetsDir}/{assetId}/peaks.json` -> New key: `assets/{assetId}/peaks.json`
- Old: `{assetsDir}/{assetId}/prepared.wav` -> New key: `assets/{assetId}/prepared.wav`
- Old: `{assetsDir}/{assetId}/edits.json` -> New key: `assets/{assetId}/edits.json`

**Method rewrites:**
- `init()`: No-op (storage adapter handles directory creation)
- `createAsset(audioBuffer, filename, provenance)`:
  - Generate assetId, build metadata object
  - `storage.put('assets/{assetId}/original{ext}', audioBuffer)`
  - `storage.put('assets/{assetId}/metadata.json', Buffer.from(JSON.stringify(metadata, null, 2)))`
  - Return metadata
- `getAsset(assetId)`:
  - `storage.get('assets/{assetId}/metadata.json')` -> parse JSON -> return AssetMetadata or null
- `listAssets()`:
  - `storage.list('assets/')` -> extract unique assetId segments -> call `getAsset()` for each
- `deleteAsset(assetId)`:
  - `storage.deletePrefix('assets/{assetId}/')`
- `resolveAssetPath(assetId)`:
  - `storage.list('assets/{assetId}/')` -> find key starting with `prepared.`
  - **Important:** This method currently returns a filesystem path. For cloud storage, the return value needs to change. Two strategies:
    1. Return a signed URL when backend is R2
    2. Download to a temp file and return temp path
  - **Choose option 2** (download to temp) for backward compatibility with ffmpeg-based processing that expects file paths. Add a `resolveAssetToTempFile(assetId)` method that downloads to `os.tmpdir()` and returns the local temp path. Keep `resolveAssetPath` working for local adapter by delegating to the underlying filesystem path. Mark this as a transitional approach -- Phase 14 worker will handle temp file lifecycle.
- `updateMetadata(assetId, updates)`:
  - Get existing, merge, `storage.put('assets/{assetId}/metadata.json', ...)`
- `getAssetDir(assetId)`:
  - **Deprecation note:** This method returns a filesystem path and is used by ingest/edit routes to read/write files within an asset directory. For local adapter, it still works (return `{basePath}/assets/{assetId}`). For R2, it should throw or return a prefix. Add a `getAssetPrefix(assetId)` method that returns `assets/{assetId}/` (the storage key prefix). Keep `getAssetDir` working for local dev but add a deprecation JSDoc comment.
- `getDiskUsage()`: Use `storage.list('assets/')` + `storage.stat()` on each key, sum sizes
- `checkQuota()`: Unchanged logic, calls `getDiskUsage()`
- `isReferenced()`: Read `edits.json` via `storage.get()`
- `cleanupExpired()`: Use `listAssets()` + metadata timestamps, same logic

**Constructor change:**
- Accept optional `StorageAdapter` parameter for testability
- Default to `getStorageAdapter()` if not provided
- Remove `assetsDir` from constructor (now driven by adapter)

**Important: Keep the `config` property** for `maxFileSizeMB`, `maxDurationMinutes`, etc. Only the storage-related config (`assetsDir`) is replaced by the adapter.
  </action>
  <verify>
1. `npm run build` passes with no type errors
2. Existing test `src/lib/audio-prep/__tests__/AudioAssetService.test.ts` still passes (it will use LocalStorageAdapter automatically since STORAGE_BACKEND is unset)
  </verify>
  <done>
- AudioAssetService uses StorageAdapter for all file I/O
- All methods rewritten to use storage keys instead of filesystem paths
- Constructor accepts optional StorageAdapter for testing
- `getAssetPrefix()` method added for key-based access
- Local development behavior unchanged (LocalStorageAdapter is default)
  </done>
</task>

<task type="auto">
  <name>Task 2: Update all API routes to work with refactored AudioAssetService</name>
  <files>
    src/app/api/audio/ingest/route.ts
    src/app/api/audio/assets/[id]/stream/route.ts
    src/app/api/audio/assets/[id]/route.ts
    src/app/api/audio/assets/route.ts
    src/app/api/audio/edit/save/route.ts
    src/app/api/audio/edit/preview/route.ts
    src/app/api/render/local/route.ts
    src/app/api/render/route.ts
  </files>
  <action>
Update all API routes that import `AudioAssetService` to work with the refactored version. The key changes:

**`src/app/api/audio/ingest/route.ts`:**
- `processIngest()` writes peaks to `assets/{assetId}/peaks.json` via `storage.put()` instead of `fs.writeFile(path.join(assetDir, 'peaks.json'), ...)`
- Remove direct `fs` imports where replaced by storage adapter calls
- The temp directory workflow (download to tempDir, probe, then create asset) stays the same -- only the final asset persistence changes
- Where `assetService.getAssetDir(id)` is used to construct paths for `original{ext}`, switch to using `assetService.getAssetPrefix(id) + 'original{ext}'` with `storage.put()`

**`src/app/api/audio/assets/[id]/stream/route.ts`:**
- Instead of `fs.readdir` + `createReadStream`, always redirect to the adapter's signed URL:
  ```typescript
  const storage = getStorageAdapter();
  const key = `assets/${assetId}/prepared.wav`; // or find via storage.list()
  const signedUrl = await storage.getSignedUrl(key);
  return NextResponse.redirect(signedUrl, 302);
  ```
- This works transparently in both environments: `LocalStorageAdapter.getSignedUrl()` returns a local API route URL (`/api/storage/download?key=...`) which serves the file with Range support (implemented in plan 12-03 Task 2), and `R2StorageAdapter.getSignedUrl()` returns a presigned S3 URL that offloads bandwidth to R2/CDN.
- **Do NOT branch on `STORAGE_BACKEND`** -- the adapter abstraction handles the difference. One code path for both environments.

**`src/app/api/audio/assets/[id]/route.ts`:**
- `getAsset()` call is unchanged (it already returns metadata)
- If this route handles file content, update to use storage adapter

**`src/app/api/audio/assets/route.ts`:**
- `listAssets()` call is unchanged (refactored internally)

**`src/app/api/audio/edit/save/route.ts`:**
- Where it reads `original` files from `assetService.getAssetDir(id)`, use storage adapter to download to temp files for ffmpeg processing
- Where it writes `prepared.{ext}` and `edits.json`, use `storage.put()` with the appropriate key
- The ffmpeg rendering still needs local temp files -- download source assets to temp, run ffmpeg, upload result via storage adapter

**`src/app/api/audio/edit/preview/route.ts`:**
- Same pattern as save: download sources to temp, process, return result

**`src/app/api/render/local/route.ts` and `src/app/api/render/route.ts`:**
- Where they call `AudioAssetService` to resolve audio paths, use the refactored methods
- `resolveAssetPath` may need to be replaced with temp file download for cloud compatibility
- **STOR-03: Upload finished render output to storage after completion.** On render completion (after the mp4 file is written to `outputPath`):
  1. Read the finished mp4 file from `outputPath` into a Buffer
  2. Upload via `storage.put('renders/{jobId}/{filename}.mp4', buffer, { contentType: 'video/mp4' })`
  3. Update the job record with the storage key (e.g., set `storageKey: 'renders/{jobId}/{filename}.mp4'` on the job)
  4. Generate a signed download URL via `storage.getSignedUrl(storageKey)` and include it in the job status response so clients can access the rendered video
  5. Delete the local temp output file after successful upload to avoid disk buildup
  ```typescript
  // After render completes and outputPath has the .mp4:
  const storage = getStorageAdapter();
  const renderBuffer = await fs.readFile(outputPath);
  const storageKey = `renders/${jobId}/${path.basename(outputPath)}`;
  await storage.put(storageKey, renderBuffer, { contentType: 'video/mp4' });
  // Update job record with storageKey for later retrieval
  // Clean up local temp file
  await fs.unlink(outputPath);
  ```

**General pattern for routes that need filesystem paths (ffmpeg):**
```typescript
const storage = getStorageAdapter();
const data = await storage.get(`assets/${assetId}/original.mp3`);
if (!data) throw new Error('Asset not found');
const tempPath = path.join(os.tmpdir(), `asset-${assetId}-original.mp3`);
await fs.writeFile(tempPath, data);
// ... use tempPath with ffmpeg ...
// ... cleanup temp after processing ...
```

This is the transitional pattern until Phase 14 where the worker handles all processing with proper temp file lifecycle management.
  </action>
  <verify>
1. `npm run build` passes
2. Start dev server (`npm run dev`), verify API routes respond:
   - `GET /api/audio/assets` returns 200
   - Audio streaming endpoint returns audio content
3. Existing AudioAssetService tests pass
  </verify>
  <done>
- All 8 API routes updated to use StorageAdapter-backed AudioAssetService
- Stream route always redirects to adapter's getSignedUrl() (works transparently in both local and R2)
- Edit/save routes use temp file pattern for ffmpeg compatibility
- Render routes upload finished .mp4 to storage via storage.put('renders/{jobId}/...') after completion
- Job record updated with storage key for rendered video retrieval
- Local temp render output cleaned up after upload
- No behavioral regression in local development
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. `npm run dev` starts without errors
3. All audio API routes respond correctly (assets list, asset get, stream, ingest)
4. AudioAssetService tests pass
5. No direct `fs` calls remain in AudioAssetService (all I/O goes through StorageAdapter)
</verification>

<success_criteria>
- AudioAssetService is fully decoupled from the filesystem
- All 8 API routes work without regression in local development
- The same code path would work with R2 in production (just change STORAGE_BACKEND env var)
- Temp file pattern established for ffmpeg-dependent operations
</success_criteria>

<output>
After completion, create `.planning/phases/12-cloud-storage-adapter/12-02-SUMMARY.md`
</output>
