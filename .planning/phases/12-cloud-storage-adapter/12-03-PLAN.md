---
phase: 12-cloud-storage-adapter
plan: 03
type: execute
wave: 2
depends_on: [12-01]
files_modified:
  - src/app/api/storage/upload/route.ts
  - src/app/api/storage/download/route.ts
  - src/lib/storage/R2StorageAdapter.ts
autonomous: true
requirements: [STOR-04]
user_setup:
  - service: cloudflare-r2
    why: "Cloud storage for audio assets and rendered videos"
    env_vars:
      - name: STORAGE_BACKEND
        source: "Set to 'r2' for production, omit or 'local' for development"
      - name: R2_ACCOUNT_ID
        source: "Cloudflare Dashboard -> R2 -> Overview -> Account ID (in sidebar)"
      - name: R2_ACCESS_KEY_ID
        source: "Cloudflare Dashboard -> R2 -> Overview -> Manage R2 API Tokens -> Create API Token"
      - name: R2_SECRET_ACCESS_KEY
        source: "Shown once when creating the API token above"
      - name: R2_BUCKET_NAME
        source: "Name of the R2 bucket (default: ethereal-flame-studio)"
    dashboard_config:
      - task: "Create R2 bucket named 'ethereal-flame-studio'"
        location: "Cloudflare Dashboard -> R2 -> Overview -> Create bucket"
      - task: "Create R2 API token with read/write permissions for the bucket"
        location: "Cloudflare Dashboard -> R2 -> Overview -> Manage R2 API Tokens"
      - task: "Configure CORS for the bucket to allow browser uploads"
        location: "Cloudflare Dashboard -> R2 -> {bucket} -> Settings -> CORS Policy"

must_haves:
  truths:
    - "Browser can upload a file directly to R2 via presigned URL without proxying through the API server"
    - "Browser can download a file from R2 via a time-limited signed URL"
    - "Signed URLs expire after 7 days for downloads"
    - "Upload presigned URLs expire after 1 hour"
    - "Local development has equivalent upload/download routes that work without R2"
    - "Upload is limited to 500 MB maximum file size"
  artifacts:
    - path: "src/app/api/storage/upload/route.ts"
      provides: "API route that generates presigned upload URL (R2) or accepts direct upload (local)"
      exports: ["POST"]
    - path: "src/app/api/storage/download/route.ts"
      provides: "API route that generates signed download URL (R2) or serves file directly (local)"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/storage/upload/route.ts"
      to: "src/lib/storage/index.ts"
      via: "getStorageAdapter().getUploadUrl()"
      pattern: "getUploadUrl"
    - from: "src/app/api/storage/download/route.ts"
      to: "src/lib/storage/index.ts"
      via: "getStorageAdapter().getSignedUrl()"
      pattern: "getSignedUrl"
---

<objective>
Create API routes for presigned upload and signed download URLs, and configure R2 CORS for direct browser-to-R2 uploads.

Purpose: Per locked user decision, file uploads go directly from the browser to R2 via presigned URLs (not proxied through the API server). Downloads use time-limited signed URLs valid for 7 days. This plan creates the API routes that generate these URLs and ensures the local development equivalents work seamlessly.

Output: Two new API routes (`/api/storage/upload` and `/api/storage/download`) and R2 CORS configuration documentation.
</objective>

<execution_context>
@C:/Users/jonch/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jonch/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-cloud-storage-adapter/12-01-SUMMARY.md
@src/lib/storage/types.ts
@src/lib/storage/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create presigned upload API route</name>
  <files>src/app/api/storage/upload/route.ts</files>
  <action>
Create `src/app/api/storage/upload/route.ts` that handles two flows:

**POST /api/storage/upload** (JSON body):
```json
{
  "key": "assets/{assetId}/original.mp3",
  "contentType": "audio/mpeg",
  "size": 12345678
}
```

**Validation:**
- `key` must be a non-empty string, max 1024 chars
- `key` must start with `assets/` or `renders/` (prevent writing to arbitrary locations)
- `key` must not contain `..` (path traversal prevention)
- `size` must be <= 500 MB (500 * 1024 * 1024 = 524288000 bytes) per user decision
- `contentType` is optional, defaults to `application/octet-stream`

**R2 mode (`STORAGE_BACKEND=r2`):**
- Call `storage.getUploadUrl(key, { contentType, maxSizeBytes: 524288000, expiresInSeconds: 3600 })`
- Return `{ success: true, data: { uploadUrl, method: 'PUT', key } }`
- The browser will PUT the file directly to this URL

**Local mode (default):**
- Return `{ success: true, data: { uploadUrl: '/api/storage/upload/direct', method: 'PUT', key } }`
- Also handle **PUT /api/storage/upload/direct?key={key}**: accept the file body and write it via `storage.put(key, body)` -- this is the local dev equivalent of the presigned R2 PUT

**For the local direct upload handler**, create a separate route or handle PUT in the same route:
- Read the raw body as a Buffer
- Validate size <= 500 MB
- Call `storage.put(key, buffer, { contentType })`
- Return 200

**Error responses:**
- 400 for validation errors (missing key, invalid prefix, size exceeded)
- 500 for storage errors

Use zod for input validation.
  </action>
  <verify>
1. `npm run build` passes
2. Start dev server, test with curl:
   - `curl -X POST http://localhost:3000/api/storage/upload -H "Content-Type: application/json" -d '{"key":"assets/test/hello.txt","size":5}'` returns 200 with uploadUrl
   - Follow the uploadUrl with a PUT to upload a small test file
  </verify>
  <done>
- POST /api/storage/upload returns presigned URL (R2) or local upload URL (dev)
- Size validation enforces 500 MB limit
- Key validation prevents path traversal and restricts to assets/renders prefixes
- Local dev upload handler accepts PUT with file body
  </done>
</task>

<task type="auto">
  <name>Task 2: Create signed download API route and document R2 CORS</name>
  <files>
    src/app/api/storage/download/route.ts
    src/lib/storage/R2StorageAdapter.ts
  </files>
  <action>
**Create `src/app/api/storage/download/route.ts`:**

**GET /api/storage/download?key={key}:**

**Validation:**
- `key` query param required, non-empty
- `key` must start with `assets/` or `renders/`
- `key` must not contain `..`

**R2 mode:**
- Call `storage.getSignedUrl(key, 604800)` (7 days = 604800 seconds per user decision)
- Return redirect (302) to the signed URL
- OR return JSON `{ success: true, data: { downloadUrl, expiresAt } }` (let the client decide whether to redirect or fetch)
- **Choose JSON response** -- more flexible for the client, and avoids CORS issues with redirects

**Local mode:**
- Read the file via `storage.get(key)`
- If null, return 404
- Serve the file directly with appropriate Content-Type headers
- Support Range requests for audio streaming (important for WaveSurfer playback):
  - Parse `Range` header
  - Return 206 with `Content-Range`
  - If no Range header, return 200 with full content

**Content-Type detection:**
- `.mp3` -> `audio/mpeg`
- `.wav` -> `audio/wav`
- `.ogg` -> `audio/ogg`
- `.m4a` -> `audio/mp4`
- `.aac` -> `audio/aac`
- `.flac` -> `audio/flac`
- `.json` -> `application/json`
- `.mp4` -> `video/mp4`
- Default: `application/octet-stream`

**Update R2StorageAdapter signed URL defaults:**
- Ensure `getSignedUrl` default expiry is 604800 seconds (7 days) per user decision
- Ensure `getUploadUrl` default expiry is 3600 seconds (1 hour)

**CORS documentation for R2 bucket:**
Add a comment block at the top of `R2StorageAdapter.ts` documenting the required CORS configuration that must be applied to the R2 bucket via the Cloudflare Dashboard:

```
/*
 * R2 CORS Configuration (apply via Cloudflare Dashboard -> R2 -> {bucket} -> Settings -> CORS Policy):
 *
 * [
 *   {
 *     "AllowedOrigins": ["http://localhost:3000", "https://your-vercel-domain.vercel.app"],
 *     "AllowedMethods": ["GET", "PUT", "HEAD"],
 *     "AllowedHeaders": ["Content-Type", "Content-Length"],
 *     "MaxAgeSeconds": 86400
 *   }
 * ]
 *
 * Update AllowedOrigins with your actual production domain before deploying.
 */
```
  </action>
  <verify>
1. `npm run build` passes
2. Start dev server, test:
   - First upload a test file via the upload route
   - `curl http://localhost:3000/api/storage/download?key=assets/test/hello.txt` returns the file content
   - Test Range request: `curl -H "Range: bytes=0-4" http://localhost:3000/api/storage/download?key=assets/test/hello.txt` returns 206
  </verify>
  <done>
- GET /api/storage/download serves files directly in local dev with Range support
- GET /api/storage/download returns signed R2 URL in production
- Signed URLs expire after 7 days per user decision
- R2 CORS configuration documented in R2StorageAdapter.ts
- Content-Type detection handles all audio, video, and JSON formats
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. Upload route generates valid presigned URL (R2) or local upload endpoint
3. Download route serves files with correct Content-Type and Range support in local dev
4. Download route generates 7-day signed URLs in R2 mode
5. Size validation rejects files over 500 MB
6. Key validation prevents path traversal
</verification>

<success_criteria>
- Direct browser-to-R2 upload flow works via presigned URL (per user locked decision)
- 500 MB maximum file size enforced (per user locked decision)
- 7-day signed URL expiry for all downloads (per user locked decision)
- Local development equivalent works without R2 credentials
- CORS configuration documented for R2 bucket setup
</success_criteria>

<output>
After completion, create `.planning/phases/12-cloud-storage-adapter/12-03-SUMMARY.md`
</output>
