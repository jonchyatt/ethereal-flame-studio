---
phase: 12-cloud-storage-adapter
plan: 03
type: execute
wave: 2
depends_on: [12-01]
files_modified:
  - src/app/api/storage/upload/route.ts
  - src/app/api/storage/download/route.ts
  - src/lib/storage/R2StorageAdapter.ts
  - src/lib/hooks/useStorageUpload.ts
  - src/components/ui/AudioPrepEditor.tsx
autonomous: true
requirements: [STOR-04]
user_setup:
  - service: cloudflare-r2
    why: "Cloud storage for audio assets and rendered videos"
    env_vars:
      - name: STORAGE_BACKEND
        source: "Set to 'r2' for production, omit or 'local' for development"
      - name: R2_ACCOUNT_ID
        source: "Cloudflare Dashboard -> R2 -> Overview -> Account ID (in sidebar)"
      - name: R2_ACCESS_KEY_ID
        source: "Cloudflare Dashboard -> R2 -> Overview -> Manage R2 API Tokens -> Create API Token"
      - name: R2_SECRET_ACCESS_KEY
        source: "Shown once when creating the API token above"
      - name: R2_BUCKET_NAME
        source: "Name of the R2 bucket (default: ethereal-flame-studio)"
    dashboard_config:
      - task: "Create R2 bucket named 'ethereal-flame-studio'"
        location: "Cloudflare Dashboard -> R2 -> Overview -> Create bucket"
      - task: "Create R2 API token with read/write permissions for the bucket"
        location: "Cloudflare Dashboard -> R2 -> Overview -> Manage R2 API Tokens"
      - task: "Configure CORS for the bucket to allow browser uploads"
        location: "Cloudflare Dashboard -> R2 -> {bucket} -> Settings -> CORS Policy"

must_haves:
  truths:
    - "Browser can upload a file directly to R2 via presigned URL without proxying through the API server"
    - "Browser can download a file from R2 via a time-limited signed URL"
    - "Signed URLs expire after 7 days for downloads"
    - "Upload presigned URLs expire after 1 hour"
    - "Local development has equivalent upload/download routes that work without R2"
    - "Upload is limited to 500 MB maximum file size"
    - "Upload progress bar is shown to the user during file upload"
  artifacts:
    - path: "src/app/api/storage/upload/route.ts"
      provides: "API route that generates presigned upload URL (R2) or accepts direct upload (local)"
      exports: ["POST"]
    - path: "src/app/api/storage/download/route.ts"
      provides: "API route that generates signed download URL (R2) or serves file directly (local)"
      exports: ["GET"]
    - path: "src/lib/hooks/useStorageUpload.ts"
      provides: "React hook for uploading files with XHR progress tracking"
      exports: ["useStorageUpload"]
  key_links:
    - from: "src/app/api/storage/upload/route.ts"
      to: "src/lib/storage/index.ts"
      via: "getStorageAdapter().getUploadUrl()"
      pattern: "getUploadUrl"
    - from: "src/app/api/storage/download/route.ts"
      to: "src/lib/storage/index.ts"
      via: "getStorageAdapter().getSignedUrl()"
      pattern: "getSignedUrl"
    - from: "src/components/ui/AudioPrepEditor.tsx"
      to: "src/lib/hooks/useStorageUpload.ts"
      via: "useStorageUpload hook for progress-tracked uploads"
      pattern: "useStorageUpload"
---

<objective>
Create API routes for presigned upload and signed download URLs, configure R2 CORS for direct browser-to-R2 uploads, and implement client-side upload progress tracking.

Purpose: Per locked user decision, file uploads go directly from the browser to R2 via presigned URLs (not proxied through the API server). Downloads use time-limited signed URLs valid for 7 days. An upload progress bar is shown to the user during upload (locked decision). This plan creates the API routes that generate these URLs, the client-side upload hook with progress tracking, and ensures the local development equivalents work seamlessly.

Output: Two new API routes (`/api/storage/upload` and `/api/storage/download`), a `useStorageUpload` React hook with progress tracking, updated AudioPrepEditor with progress bar, and R2 CORS configuration documentation.
</objective>

<execution_context>
@C:/Users/jonch/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jonch/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-cloud-storage-adapter/12-01-SUMMARY.md
@src/lib/storage/types.ts
@src/lib/storage/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create presigned upload API route</name>
  <files>src/app/api/storage/upload/route.ts</files>
  <action>
Create `src/app/api/storage/upload/route.ts` that handles two flows:

**POST /api/storage/upload** (JSON body):
```json
{
  "key": "assets/{assetId}/original.mp3",
  "contentType": "audio/mpeg",
  "size": 12345678
}
```

**Validation:**
- `key` must be a non-empty string, max 1024 chars
- `key` must start with `assets/` or `renders/` (prevent writing to arbitrary locations)
- `key` must not contain `..` (path traversal prevention)
- `size` must be <= 500 MB (500 * 1024 * 1024 = 524288000 bytes) per user decision
- `contentType` is optional, defaults to `application/octet-stream`

**R2 mode (`STORAGE_BACKEND=r2`):**
- Call `storage.getUploadUrl(key, { contentType, maxSizeBytes: 524288000, expiresInSeconds: 3600 })`
- Return `{ success: true, data: { uploadUrl, method: 'PUT', key } }`
- The browser will PUT the file directly to this URL

**Local mode (default):**
- Return `{ success: true, data: { uploadUrl: '/api/storage/upload/direct', method: 'PUT', key } }`
- Also handle **PUT /api/storage/upload/direct?key={key}**: accept the file body and write it via `storage.put(key, body)` -- this is the local dev equivalent of the presigned R2 PUT

**For the local direct upload handler**, create a separate route or handle PUT in the same route:
- Read the raw body as a Buffer
- Validate size <= 500 MB
- Call `storage.put(key, buffer, { contentType })`
- Return 200

**Error responses:**
- 400 for validation errors (missing key, invalid prefix, size exceeded)
- 500 for storage errors

Use zod for input validation.
  </action>
  <verify>
1. `npm run build` passes
2. Start dev server, test with curl:
   - `curl -X POST http://localhost:3000/api/storage/upload -H "Content-Type: application/json" -d '{"key":"assets/test/hello.txt","size":5}'` returns 200 with uploadUrl
   - Follow the uploadUrl with a PUT to upload a small test file
  </verify>
  <done>
- POST /api/storage/upload returns presigned URL (R2) or local upload URL (dev)
- Size validation enforces 500 MB limit
- Key validation prevents path traversal and restricts to assets/renders prefixes
- Local dev upload handler accepts PUT with file body
  </done>
</task>

<task type="auto">
  <name>Task 2: Create signed download API route and document R2 CORS</name>
  <files>
    src/app/api/storage/download/route.ts
    src/lib/storage/R2StorageAdapter.ts
  </files>
  <action>
**Create `src/app/api/storage/download/route.ts`:**

**GET /api/storage/download?key={key}:**

**Validation:**
- `key` query param required, non-empty
- `key` must start with `assets/` or `renders/`
- `key` must not contain `..`

**R2 mode:**
- Call `storage.getSignedUrl(key, 604800)` (7 days = 604800 seconds per user decision)
- Return redirect (302) to the signed URL
- OR return JSON `{ success: true, data: { downloadUrl, expiresAt } }` (let the client decide whether to redirect or fetch)
- **Choose JSON response** -- more flexible for the client, and avoids CORS issues with redirects

**Local mode:**
- Read the file via `storage.get(key)`
- If null, return 404
- Serve the file directly with appropriate Content-Type headers
- Support Range requests for audio streaming (important for WaveSurfer playback):
  - Parse `Range` header
  - Return 206 with `Content-Range`
  - If no Range header, return 200 with full content

**Content-Type detection:**
- `.mp3` -> `audio/mpeg`
- `.wav` -> `audio/wav`
- `.ogg` -> `audio/ogg`
- `.m4a` -> `audio/mp4`
- `.aac` -> `audio/aac`
- `.flac` -> `audio/flac`
- `.json` -> `application/json`
- `.mp4` -> `video/mp4`
- Default: `application/octet-stream`

**Update R2StorageAdapter signed URL defaults:**
- Ensure `getSignedUrl` default expiry is 604800 seconds (7 days) per user decision
- Ensure `getUploadUrl` default expiry is 3600 seconds (1 hour)

**CORS documentation for R2 bucket:**
Add a comment block at the top of `R2StorageAdapter.ts` documenting the required CORS configuration that must be applied to the R2 bucket via the Cloudflare Dashboard:

```
/*
 * R2 CORS Configuration (apply via Cloudflare Dashboard -> R2 -> {bucket} -> Settings -> CORS Policy):
 *
 * [
 *   {
 *     "AllowedOrigins": ["http://localhost:3000", "https://your-vercel-domain.vercel.app"],
 *     "AllowedMethods": ["GET", "PUT", "HEAD"],
 *     "AllowedHeaders": ["Content-Type", "Content-Length"],
 *     "MaxAgeSeconds": 86400
 *   }
 * ]
 *
 * Update AllowedOrigins with your actual production domain before deploying.
 */
```
  </action>
  <verify>
1. `npm run build` passes
2. Start dev server, test:
   - First upload a test file via the upload route
   - `curl http://localhost:3000/api/storage/download?key=assets/test/hello.txt` returns the file content
   - Test Range request: `curl -H "Range: bytes=0-4" http://localhost:3000/api/storage/download?key=assets/test/hello.txt` returns 206
  </verify>
  <done>
- GET /api/storage/download serves files directly in local dev with Range support
- GET /api/storage/download returns signed R2 URL in production
- Signed URLs expire after 7 days per user decision
- R2 CORS configuration documented in R2StorageAdapter.ts
- Content-Type detection handles all audio, video, and JSON formats
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useStorageUpload hook with progress bar and wire into AudioPrepEditor</name>
  <files>
    src/lib/hooks/useStorageUpload.ts
    src/components/ui/AudioPrepEditor.tsx
  </files>
  <action>
**Create `src/lib/hooks/useStorageUpload.ts`:**

A React hook that handles the two-step presigned upload flow with XHR progress tracking:

```typescript
import { useState, useCallback } from 'react';

interface UploadState {
  progress: number;       // 0-100
  status: 'idle' | 'requesting-url' | 'uploading' | 'complete' | 'error';
  error: string | null;
  key: string | null;
}

interface UseStorageUploadOptions {
  onComplete?: (key: string) => void;
  onError?: (error: string) => void;
}

export function useStorageUpload(options?: UseStorageUploadOptions) {
  // ... state management ...

  const upload = useCallback(async (file: File, key: string) => {
    // Step 1: Request presigned/upload URL from /api/storage/upload
    setStatus('requesting-url');
    const res = await fetch('/api/storage/upload', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        key,
        contentType: file.type || 'application/octet-stream',
        size: file.size,
      }),
    });
    if (!res.ok) { /* handle error, set status to 'error' */ }
    const { data } = await res.json();

    // Step 2: Upload file using XHR (not fetch) for progress tracking
    setStatus('uploading');
    return new Promise<string>((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.upload.addEventListener('progress', (e) => {
        if (e.lengthComputable) {
          setProgress(Math.round((e.loaded / e.total) * 100));
        }
      });
      xhr.addEventListener('load', () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          setStatus('complete');
          setProgress(100);
          options?.onComplete?.(key);
          resolve(key);
        } else {
          const error = `Upload failed: ${xhr.status}`;
          setStatus('error');
          setError(error);
          options?.onError?.(error);
          reject(new Error(error));
        }
      });
      xhr.addEventListener('error', () => {
        const error = 'Upload failed: network error';
        setStatus('error');
        setError(error);
        options?.onError?.(error);
        reject(new Error(error));
      });
      xhr.open(data.method, data.uploadUrl);
      xhr.setRequestHeader('Content-Type', file.type || 'application/octet-stream');
      xhr.send(file);
    });
  }, [options]);

  const reset = useCallback(() => {
    setProgress(0);
    setStatus('idle');
    setError(null);
    setKey(null);
  }, []);

  return { upload, reset, ...state };
}
```

Key design decisions:
- Uses XHR (not fetch) because `fetch` does not support upload progress events (this is a browser limitation -- `ReadableStream` upload progress is not widely supported)
- Returns `progress` (0-100), `status`, and `error` for UI binding
- The `upload` function is async and returns a promise that resolves with the storage key
- `reset()` clears state for re-use

**Update `src/components/ui/AudioPrepEditor.tsx`:**

Wire the upload hook into the existing file upload flow in AudioPrepEditor:

1. Import `useStorageUpload` at the top
2. Initialize the hook: `const { upload, progress, status, error, reset } = useStorageUpload();`
3. In the file upload handler (where `formData` is currently built and sent to `/api/audio/ingest`):
   - Before calling ingest, use the hook to upload the file to storage with progress tracking
   - The key should follow the convention: `assets/{generatedId}/original.{ext}`
   - After upload completes, call the ingest endpoint with the storage key reference instead of the raw file
   - This two-step flow (upload to storage -> tell ingest where the file is) replaces the current single-step FormData upload
4. Add a progress bar UI element that shows when `status === 'uploading'`:
   ```tsx
   {status === 'uploading' && (
     <div className="w-full bg-gray-700 rounded-full h-2 mt-2">
       <div
         className="bg-blue-500 h-2 rounded-full transition-all duration-200"
         style={{ width: `${progress}%` }}
       />
       <span className="text-xs text-gray-400 mt-1">{progress}% uploaded</span>
     </div>
   )}
   ```
5. Show error state if upload fails
6. Reset upload state when starting a new upload

**Note:** The existing ingest route may still handle FormData uploads for backward compatibility. The new flow uses presigned upload + ingest-by-key, but the old FormData flow should continue to work until fully deprecated.
  </action>
  <verify>
1. `npm run build` passes
2. Start dev server, open the AudioPrepEditor in the browser
3. Upload a file and verify the progress bar appears and fills from 0% to 100%
4. Verify the file is persisted in local storage after upload completes
  </verify>
  <done>
- useStorageUpload hook exists with XHR-based progress tracking (0-100%)
- Hook returns progress, status ('idle' | 'requesting-url' | 'uploading' | 'complete' | 'error'), and error state
- AudioPrepEditor uses the hook for file uploads
- Progress bar is visually displayed during upload (per locked user decision)
- Upload errors are surfaced to the user
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. Upload route generates valid presigned URL (R2) or local upload endpoint
3. Download route serves files with correct Content-Type and Range support in local dev
4. Download route generates 7-day signed URLs in R2 mode
5. Size validation rejects files over 500 MB
6. Key validation prevents path traversal
7. useStorageUpload hook reports progress 0-100% during upload via XHR
8. AudioPrepEditor shows progress bar during file upload
</verification>

<success_criteria>
- Direct browser-to-R2 upload flow works via presigned URL (per user locked decision)
- 500 MB maximum file size enforced (per user locked decision)
- 7-day signed URL expiry for all downloads (per user locked decision)
- Upload progress bar shown to user during upload (per user locked decision)
- Local development equivalent works without R2 credentials
- CORS configuration documented for R2 bucket setup
</success_criteria>

<output>
After completion, create `.planning/phases/12-cloud-storage-adapter/12-03-SUMMARY.md`
</output>
